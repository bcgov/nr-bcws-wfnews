{"version":3,"file":"calendar.component.d.ts","sources":["calendar.component.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["/**\r\n * calendar.component\r\n */\r\nimport { AfterContentInit, AfterViewChecked, ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnDestroy, OnInit } from '@angular/core';\r\nimport { OwlDateTimeIntl } from './date-time-picker-intl.service';\r\nimport { DateTimeAdapter } from './adapter/date-time-adapter.class';\r\nimport { OwlDateTimeFormats } from './adapter/date-time-format.class';\r\nimport { SelectMode } from './date-time.class';\r\nexport declare class OwlCalendarComponent<T> implements OnInit, AfterContentInit, AfterViewChecked, OnDestroy {\r\n    private elmRef;\r\n    private pickerIntl;\r\n    private ngZone;\r\n    private cdRef;\r\n    private dateTimeAdapter;\r\n    private dateTimeFormats;\r\n    /**\r\n     * Date filter for the month and year view\r\n     * @type {Function}\r\n     * */\r\n    dateFilter: Function;\r\n    /**\r\n     * Set the first day of week\r\n     * @default {0} -- 0: Sunday ~ 6: Saturday\r\n     * @type {number}\r\n     * */\r\n    firstDayOfWeek: number;\r\n    /** The minimum selectable date. */\r\n    private _minDate;\r\n    get minDate(): T | null;\r\n    set minDate(value: T | null);\r\n    /** The maximum selectable date. */\r\n    private _maxDate;\r\n    get maxDate(): T | null;\r\n    set maxDate(value: T | null);\r\n    /** The current picker moment */\r\n    private _pickerMoment;\r\n    get pickerMoment(): T;\r\n    set pickerMoment(value: T);\r\n    selectMode: SelectMode;\r\n    /** The currently selected moment. */\r\n    private _selected;\r\n    get selected(): T | null;\r\n    set selected(value: T | null);\r\n    private _selecteds;\r\n    get selecteds(): T[];\r\n    set selecteds(values: T[]);\r\n    /**\r\n     * The view that the calendar should start in.\r\n     * @default {'month'}\r\n     * @type {'month' | 'year'}\r\n     * */\r\n    startView: 'month' | 'year' | 'multi-years';\r\n    /**\r\n     * Whether to hide dates in other months at the start or end of the current month.\r\n     * */\r\n    hideOtherMonths: boolean;\r\n    /** Emits when the currently picker moment changes. */\r\n    pickerMomentChange: EventEmitter<T>;\r\n    /** Emits when the currently selected date changes. */\r\n    selectedChange: EventEmitter<T>;\r\n    /** Emits when any date is selected. */\r\n    userSelection: EventEmitter<void>;\r\n    /**\r\n     * Emits the selected year. This doesn't imply a change on the selected date\r\n     * */\r\n    readonly yearSelected: EventEmitter<T>;\r\n    /**\r\n     * Emits the selected month. This doesn't imply a change on the selected date\r\n     * */\r\n    readonly monthSelected: EventEmitter<T>;\r\n    get periodButtonText(): string;\r\n    get periodButtonLabel(): string;\r\n    get prevButtonLabel(): string;\r\n    get nextButtonLabel(): string;\r\n    private _currentView;\r\n    get currentView(): 'month' | 'year' | 'multi-years';\r\n    set currentView(view: 'month' | 'year' | 'multi-years');\r\n    get isInSingleMode(): boolean;\r\n    get isInRangeMode(): boolean;\r\n    get showControlArrows(): boolean;\r\n    get isMonthView(): boolean;\r\n    /**\r\n     * Date filter for the month and year view\r\n     * @type {Function}\r\n     * */\r\n    dateFilterForViews: (date: T) => boolean;\r\n    /**\r\n     * Bind class 'owl-dt-calendar' to host\r\n     * */\r\n    get owlDTCalendarClass(): boolean;\r\n    private intlChangesSub;\r\n    /**\r\n     * Used for scheduling that focus should be moved to the active cell on the next tick.\r\n     * We need to schedule it, rather than do it immediately, because we have to wait\r\n     * for Angular to re-evaluate the view children.\r\n     */\r\n    private moveFocusOnNextTick;\r\n    constructor(elmRef: ElementRef, pickerIntl: OwlDateTimeIntl, ngZone: NgZone, cdRef: ChangeDetectorRef, dateTimeAdapter: DateTimeAdapter<T>, dateTimeFormats: OwlDateTimeFormats);\r\n    ngOnInit(): void;\r\n    ngAfterContentInit(): void;\r\n    ngAfterViewChecked(): void;\r\n    ngOnDestroy(): void;\r\n    /**\r\n     * Toggle between month view and year view\r\n     * @return {void}\r\n     * */\r\n    toggleViews(): void;\r\n    /**\r\n     * Handles user clicks on the previous button.\r\n     * */\r\n    previousClicked(): void;\r\n    /**\r\n     * Handles user clicks on the next button.\r\n     * */\r\n    nextClicked(): void;\r\n    dateSelected(date: T): void;\r\n    /**\r\n     * Change the pickerMoment value and switch to a specific view\r\n     * @param {T} date\r\n     * @param {'month' | 'year' | 'multi-years'} view\r\n     * @return {void}\r\n     * */\r\n    goToDateInView(date: T, view: 'month' | 'year' | 'multi-years'): void;\r\n    /**\r\n     * Change the pickerMoment value\r\n     * @return {void}\r\n     * */\r\n    handlePickerMomentChange(date: T): void;\r\n    userSelected(): void;\r\n    /**\r\n     * Whether the previous period button is enabled.\r\n     * @return {boolean}\r\n     * */\r\n    prevButtonEnabled(): boolean;\r\n    /**\r\n     * Whether the next period button is enabled.\r\n     * @return {boolean}\r\n     * */\r\n    nextButtonEnabled(): boolean;\r\n    /**\r\n     * Focus to the host element\r\n     * */\r\n    focusActiveCell(): void;\r\n    selectYearInMultiYearView(normalizedYear: T): void;\r\n    selectMonthInYearView(normalizedMonth: T): void;\r\n    /**\r\n     * Whether the two dates represent the same view in the current view mode (month or year).\r\n     * @param {Date} date1\r\n     * @param {Date} date2\r\n     * @return {boolean}\r\n     * */\r\n    private isSameView;\r\n    /**\r\n     * Get a valid date object\r\n     * @param {any} obj -- The object to check.\r\n     * @return {Date | null} -- The given object if it is both a date instance and valid, otherwise null.\r\n     */\r\n    private getValidDate;\r\n}\r\n"]}