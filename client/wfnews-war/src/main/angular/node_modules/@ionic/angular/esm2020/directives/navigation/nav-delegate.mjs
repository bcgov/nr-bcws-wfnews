import { __decorate } from "tslib";
import { Directive } from '@angular/core';
import { ProxyCmp, proxyOutputs } from '../angular-component-lib/utils';
import * as i0 from "@angular/core";
import * as i1 from "../../providers/angular-delegate";
let NavDelegate = class NavDelegate {
    constructor(ref, environmentInjector, injector, angularDelegate) {
        this.el = ref.nativeElement;
        ref.nativeElement.delegate = angularDelegate.create(environmentInjector, injector);
        proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);
    }
};
/** @nocollapse */ NavDelegate.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavDelegate, deps: [{ token: i0.ElementRef }, { token: i0.EnvironmentInjector }, { token: i0.Injector }, { token: i1.AngularDelegate }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NavDelegate.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.2.12", type: NavDelegate, selector: "ion-nav", ngImport: i0 });
NavDelegate = __decorate([
    ProxyCmp({
        inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'],
        methods: [
            'push',
            'insert',
            'insertPages',
            'pop',
            'popTo',
            'popToRoot',
            'removeIndex',
            'setRoot',
            'setPages',
            'getActive',
            'getByIndex',
            'canGoBack',
            'getPrevious',
        ],
    })
], NavDelegate);
export { NavDelegate };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavDelegate, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ion-nav',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.EnvironmentInjector }, { type: i0.Injector }, { type: i1.AngularDelegate }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LWRlbGVnYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2RpcmVjdGl2ZXMvbmF2aWdhdGlvbi9uYXYtZGVsZWdhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBd0IsU0FBUyxFQUF1QixNQUFNLGVBQWUsQ0FBQztBQUdyRixPQUFPLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxNQUFNLGdDQUFnQyxDQUFDOzs7SUF3QjNELFdBQVcsU0FBWCxXQUFXO0lBRXRCLFlBQ0UsR0FBZSxFQUNmLG1CQUF3QyxFQUN4QyxRQUFrQixFQUNsQixlQUFnQztRQUVoQyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUM7UUFDNUIsR0FBRyxDQUFDLGFBQWEsQ0FBQyxRQUFRLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUNuRixZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDLENBQUM7SUFDdkUsQ0FBQztDQUNGLENBQUE7NEhBWlksV0FBVztnSEFBWCxXQUFXO0FBQVgsV0FBVztJQXRCdkIsUUFBUSxDQUFDO1FBQ1IsTUFBTSxFQUFFLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLGNBQWMsQ0FBQztRQUN2RSxPQUFPLEVBQUU7WUFDUCxNQUFNO1lBQ04sUUFBUTtZQUNSLGFBQWE7WUFDYixLQUFLO1lBQ0wsT0FBTztZQUNQLFdBQVc7WUFDWCxhQUFhO1lBQ2IsU0FBUztZQUNULFVBQVU7WUFDVixXQUFXO1lBQ1gsWUFBWTtZQUNaLFdBQVc7WUFDWCxhQUFhO1NBQ2Q7S0FDRixDQUFDO0dBS1csV0FBVyxDQVl2QjtTQVpZLFdBQVc7NEZBQVgsV0FBVztrQkFKdkIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsU0FBUztpQkFDcEIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3RvciwgRGlyZWN0aXZlLCBFbnZpcm9ubWVudEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFuZ3VsYXJEZWxlZ2F0ZSB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9hbmd1bGFyLWRlbGVnYXRlJztcbmltcG9ydCB7IFByb3h5Q21wLCBwcm94eU91dHB1dHMgfSBmcm9tICcuLi9hbmd1bGFyLWNvbXBvbmVudC1saWIvdXRpbHMnO1xuXG5AUHJveHlDbXAoe1xuICBpbnB1dHM6IFsnYW5pbWF0ZWQnLCAnYW5pbWF0aW9uJywgJ3Jvb3QnLCAncm9vdFBhcmFtcycsICdzd2lwZUdlc3R1cmUnXSxcbiAgbWV0aG9kczogW1xuICAgICdwdXNoJyxcbiAgICAnaW5zZXJ0JyxcbiAgICAnaW5zZXJ0UGFnZXMnLFxuICAgICdwb3AnLFxuICAgICdwb3BUbycsXG4gICAgJ3BvcFRvUm9vdCcsXG4gICAgJ3JlbW92ZUluZGV4JyxcbiAgICAnc2V0Um9vdCcsXG4gICAgJ3NldFBhZ2VzJyxcbiAgICAnZ2V0QWN0aXZlJyxcbiAgICAnZ2V0QnlJbmRleCcsXG4gICAgJ2NhbkdvQmFjaycsXG4gICAgJ2dldFByZXZpb3VzJyxcbiAgXSxcbn0pXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdpb24tbmF2Jyxcbn0pXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L2RpcmVjdGl2ZS1jbGFzcy1zdWZmaXhcbmV4cG9ydCBjbGFzcyBOYXZEZWxlZ2F0ZSB7XG4gIHByb3RlY3RlZCBlbDogSFRNTEVsZW1lbnQ7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlZjogRWxlbWVudFJlZixcbiAgICBlbnZpcm9ubWVudEluamVjdG9yOiBFbnZpcm9ubWVudEluamVjdG9yLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBhbmd1bGFyRGVsZWdhdGU6IEFuZ3VsYXJEZWxlZ2F0ZVxuICApIHtcbiAgICB0aGlzLmVsID0gcmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgcmVmLm5hdGl2ZUVsZW1lbnQuZGVsZWdhdGUgPSBhbmd1bGFyRGVsZWdhdGUuY3JlYXRlKGVudmlyb25tZW50SW5qZWN0b3IsIGluamVjdG9yKTtcbiAgICBwcm94eU91dHB1dHModGhpcywgdGhpcy5lbCwgWydpb25OYXZEaWRDaGFuZ2UnLCAnaW9uTmF2V2lsbENoYW5nZSddKTtcbiAgfVxufVxuIl19