import { Injectable, Optional } from '@angular/core';
import { NavigationStart } from '@angular/router';
import * as i0 from "@angular/core";
import * as i1 from "./platform";
import * as i2 from "@angular/common";
import * as i3 from "@angular/router";
export class NavController {
    constructor(platform, location, serializer, router) {
        this.location = location;
        this.serializer = serializer;
        this.router = router;
        this.direction = DEFAULT_DIRECTION;
        this.animated = DEFAULT_ANIMATED;
        this.guessDirection = 'forward';
        this.lastNavId = -1;
        // Subscribe to router events to detect direction
        if (router) {
            router.events.subscribe((ev) => {
                if (ev instanceof NavigationStart) {
                    const id = ev.restoredState ? ev.restoredState.navigationId : ev.id;
                    this.guessDirection = id < this.lastNavId ? 'back' : 'forward';
                    this.guessAnimation = !ev.restoredState ? this.guessDirection : undefined;
                    this.lastNavId = this.guessDirection === 'forward' ? ev.id : id;
                }
            });
        }
        // Subscribe to backButton events
        platform.backButton.subscribeWithPriority(0, (processNextHandler) => {
            this.pop();
            processNextHandler();
        });
    }
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.
     *
     * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),
     * and that it will show a "forward" animation by default.
     *
     * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="forward">Link</a>
     * ```
     */
    navigateForward(url, options = {}) {
        this.setDirection('forward', options.animated, options.animationDirection, options.animation);
        return this.navigate(url, options);
    }
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('back');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **back** means that all the pages in the stack until the navigated page is found will be popped,
     * and that it will show a "back" animation by default.
     *
     * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="back">Link</a>
     * ```
     */
    navigateBack(url, options = {}) {
        this.setDirection('back', options.animated, options.animationDirection, options.animation);
        return this.navigate(url, options);
    }
    /**
     * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,
     * it's equivalent to calling:
     *
     * ```ts
     * this.navController.setDirection('root');
     * this.router.navigateByUrl(path);
     * ```
     *
     * Going **root** means that all existing pages in the stack will be removed,
     * and the navigated page will become the single page in the stack.
     *
     * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:
     *
     * ```html
     * <a routerLink="/path/to/page" routerDirection="root">Link</a>
     * ```
     */
    navigateRoot(url, options = {}) {
        this.setDirection('root', options.animated, options.animationDirection, options.animation);
        return this.navigate(url, options);
    }
    /**
     * Same as [Location](https://angular.io/api/common/Location)'s back() method.
     * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation
     * by default.
     */
    back(options = { animated: true, animationDirection: 'back' }) {
        this.setDirection('back', options.animated, options.animationDirection, options.animation);
        return this.location.back();
    }
    /**
     * This methods goes back in the context of Ionic's stack navigation.
     *
     * It recursively finds the top active `ion-router-outlet` and calls `pop()`.
     * This is the recommended way to go back when you are using `ion-router-outlet`.
     *
     * Resolves to `true` if it was able to pop.
     */
    async pop() {
        let outlet = this.topOutlet;
        while (outlet) {
            if (await outlet.pop()) {
                return true;
            }
            else {
                outlet = outlet.parentOutlet;
            }
        }
        return false;
    }
    /**
     * This methods specifies the direction of the next navigation performed by the Angular router.
     *
     * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.
     *
     * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.
     */
    setDirection(direction, animated, animationDirection, animationBuilder) {
        this.direction = direction;
        this.animated = getAnimation(direction, animated, animationDirection);
        this.animationBuilder = animationBuilder;
    }
    /**
     * @internal
     */
    setTopOutlet(outlet) {
        this.topOutlet = outlet;
    }
    /**
     * @internal
     */
    consumeTransition() {
        let direction = 'root';
        let animation;
        const animationBuilder = this.animationBuilder;
        if (this.direction === 'auto') {
            direction = this.guessDirection;
            animation = this.guessAnimation;
        }
        else {
            animation = this.animated;
            direction = this.direction;
        }
        this.direction = DEFAULT_DIRECTION;
        this.animated = DEFAULT_ANIMATED;
        this.animationBuilder = undefined;
        return {
            direction,
            animation,
            animationBuilder,
        };
    }
    navigate(url, options) {
        if (Array.isArray(url)) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.router.navigate(url, options);
        }
        else {
            /**
             * navigateByUrl ignores any properties that
             * would change the url, so things like queryParams
             * would be ignored unless we create a url tree
             * More Info: https://github.com/angular/angular/issues/18798
             */
            const urlTree = this.serializer.parse(url.toString());
            if (options.queryParams !== undefined) {
                urlTree.queryParams = { ...options.queryParams };
            }
            if (options.fragment !== undefined) {
                urlTree.fragment = options.fragment;
            }
            /**
             * `navigateByUrl` will still apply `NavigationExtras` properties
             * that do not modify the url, such as `replaceUrl` which is why
             * `options` is passed in here.
             */
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.router.navigateByUrl(urlTree, options);
        }
    }
}
/** @nocollapse */ NavController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavController, deps: [{ token: i1.Platform }, { token: i2.Location }, { token: i3.UrlSerializer }, { token: i3.Router, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NavController.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavController, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.12", ngImport: i0, type: NavController, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.Platform }, { type: i2.Location }, { type: i3.UrlSerializer }, { type: i3.Router, decorators: [{
                    type: Optional
                }] }]; } });
const getAnimation = (direction, animated, animationDirection) => {
    if (animated === false) {
        return undefined;
    }
    if (animationDirection !== undefined) {
        return animationDirection;
    }
    if (direction === 'forward' || direction === 'back') {
        return direction;
    }
    else if (direction === 'root' && animated === true) {
        return 'forward';
    }
    return undefined;
};
const DEFAULT_DIRECTION = 'auto';
const DEFAULT_ANIMATED = undefined;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2LWNvbnRyb2xsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJvdmlkZXJzL25hdi1jb250cm9sbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JELE9BQU8sRUFBb0QsZUFBZSxFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7O0FBa0JwRyxNQUFNLE9BQU8sYUFBYTtJQVN4QixZQUNFLFFBQWtCLEVBQ1YsUUFBa0IsRUFDbEIsVUFBeUIsRUFDYixNQUFlO1FBRjNCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsZUFBVSxHQUFWLFVBQVUsQ0FBZTtRQUNiLFdBQU0sR0FBTixNQUFNLENBQVM7UUFYN0IsY0FBUyxHQUF5QyxpQkFBaUIsQ0FBQztRQUNwRSxhQUFRLEdBQWtCLGdCQUFnQixDQUFDO1FBRTNDLG1CQUFjLEdBQW9CLFNBQVMsQ0FBQztRQUU1QyxjQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFRckIsaURBQWlEO1FBQ2pELElBQUksTUFBTSxFQUFFO1lBQ1YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRTtnQkFDN0IsSUFBSSxFQUFFLFlBQVksZUFBZSxFQUFFO29CQUNqQyxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztvQkFDcEUsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7b0JBQy9ELElBQUksQ0FBQyxjQUFjLEdBQUcsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMs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RDtZQUVELElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7Z0JBQ2xDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQzthQUNyQztZQUVEOzs7O2VBSUc7WUFDSCxvRUFBb0U7WUFDcEUsT0FBTyxJQUFJLENBQUMsTUFBTyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDckQ7SUFDSCxDQUFDOzs4SEF0TlUsYUFBYTtrSUFBYixhQUFhLGNBRlosTUFBTTs0RkFFUCxhQUFhO2tCQUh6QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7MEJBY0ksUUFBUTs7QUE0TWIsTUFBTSxZQUFZLEdBQUcsQ0FDbkIsU0FBMEIsRUFDMUIsUUFBNkIsRUFDN0Isa0JBQWtELEVBQ3hCLEVBQUU7SUFDNUIsSUFBSSxRQUFRLEtBQUssS0FBSyxFQUFFO1FBQ3RCLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsSUFBSSxrQkFBa0IsS0FBSyxTQUFTLEVBQUU7UUFDcEMsT0FBTyxrQkFBa0IsQ0FBQztLQUMzQjtJQUNELElBQUksU0FBUyxLQUFLLFNBQVMsSUFBSSxTQUFTLEtBQUssTUFBTSxFQUFFO1FBQ25ELE9BQU8sU0FBUyxDQUFDO0tBQ2xCO1NBQU0sSUFBSSxTQUFTLEtBQUssTUFBTSxJQUFJLFFBQVEsS0FBSyxJQUFJLEVBQUU7UUFDcEQsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFFRixNQUFNLGlCQUFpQixHQUFHLE1BQU0sQ0FBQztBQUNqQyxNQUFNLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExvY2F0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRXh0cmFzLCBSb3V0ZXIsIFVybFNlcmlhbGl6ZXIsIFVybFRyZWUsIE5hdmlnYXRpb25TdGFydCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBBbmltYXRpb25CdWlsZGVyLCBOYXZEaXJlY3Rpb24sIFJvdXRlckRpcmVjdGlvbiB9IGZyb20gJ0Bpb25pYy9jb3JlJztcblxuaW1wb3J0IHsgSW9uUm91dGVyT3V0bGV0IH0gZnJvbSAnLi4vZGlyZWN0aXZlcy9uYXZpZ2F0aW9uL2lvbi1yb3V0ZXItb3V0bGV0JztcblxuaW1wb3J0IHsgUGxhdGZvcm0gfSBmcm9tICcuL3BsYXRmb3JtJztcblxuZXhwb3J0IGludGVyZmFjZSBBbmltYXRpb25PcHRpb25zIHtcbiAgYW5pbWF0ZWQ/OiBib29sZWFuO1xuICBhbmltYXRpb24/OiBBbmltYXRpb25CdWlsZGVyO1xuICBhbmltYXRpb25EaXJlY3Rpb24/OiAnZm9yd2FyZCcgfCAnYmFjayc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGlvbk9wdGlvbnMgZXh0ZW5kcyBOYXZpZ2F0aW9uRXh0cmFzLCBBbmltYXRpb25PcHRpb25zIHt9XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBOYXZDb250cm9sbGVyIHtcbiAgcHJpdmF0ZSB0b3BPdXRsZXQ/OiBJb25Sb3V0ZXJPdXRsZXQ7XG4gIHByaXZhdGUgZGlyZWN0aW9uOiAnZm9yd2FyZCcgfCAnYmFjaycgfCAncm9vdCcgfCAnYXV0bycgPSBERUZBVUxUX0RJUkVDVElPTjtcbiAgcHJpdmF0ZSBhbmltYXRlZD86IE5hdkRpcmVjdGlvbiA9IERFRkFVTFRfQU5JTUFURUQ7XG4gIHByaXZhdGUgYW5pbWF0aW9uQnVpbGRlcj86IEFuaW1hdGlvbkJ1aWxkZXI7XG4gIHByaXZhdGUgZ3Vlc3NEaXJlY3Rpb246IFJvdXRlckRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgcHJpdmF0ZSBndWVzc0FuaW1hdGlvbj86IE5hdkRpcmVjdGlvbjtcbiAgcHJpdmF0ZSBsYXN0TmF2SWQgPSAtMTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwbGF0Zm9ybTogUGxhdGZvcm0sXG4gICAgcHJpdmF0ZSBsb2NhdGlvbjogTG9jYXRpb24sXG4gICAgcHJpdmF0ZSBzZXJpYWxpemVyOiBVcmxTZXJpYWxpemVyLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgcm91dGVyPzogUm91dGVyXG4gICkge1xuICAgIC8vIFN1YnNjcmliZSB0byByb3V0ZXIgZXZlbnRzIHRvIGRldGVjdCBkaXJlY3Rpb25cbiAgICBpZiAocm91dGVyKSB7XG4gICAgICByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZSgoZXYpID0+IHtcbiAgICAgICAgaWYgKGV2IGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgICAgICAgY29uc3QgaWQgPSBldi5yZXN0b3JlZFN0YXRlID8gZXYucmVzdG9yZWRTdGF0ZS5uYXZpZ2F0aW9uSWQgOiBldi5pZDtcbiAgICAgICAgICB0aGlzLmd1ZXNzRGlyZWN0aW9uID0gaWQgPCB0aGlzLmxhc3ROYXZJZCA/ICdiYWNrJyA6ICdmb3J3YXJkJztcbiAgICAgICAgICB0aGlzLmd1ZXNzQW5pbWF0aW9uID0gIWV2LnJlc3RvcmVkU3RhdGUgPyB0aGlzLmd1ZXNzRGlyZWN0aW9uIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMubGFzdE5hdklkID0gdGhpcy5ndWVzc0RpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gZXYuaWQgOiBpZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3Vic2NyaWJlIHRvIGJhY2tCdXR0b24gZXZlbnRzXG4gICAgcGxhdGZvcm0uYmFja0J1dHRvbi5zdWJzY3JpYmVXaXRoUHJpb3JpdHkoMCwgKHByb2Nlc3NOZXh0SGFuZGxlcikgPT4ge1xuICAgICAgdGhpcy5wb3AoKTtcbiAgICAgIHByb2Nlc3NOZXh0SGFuZGxlcigpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHVzZXMgQW5ndWxhcidzIFtSb3V0ZXJdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlcikgdW5kZXIgdGhlIGhvb2QsXG4gICAqIGl0J3MgZXF1aXZhbGVudCB0byBjYWxsaW5nIGB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKClgLCBidXQgaXQncyBleHBsaWNpdCBhYm91dCB0aGUgKipkaXJlY3Rpb24qKiBvZiB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogR29pbmcgKipmb3J3YXJkKiogbWVhbnMgdGhhdCBhIG5ldyBwYWdlIGlzIGdvaW5nIHRvIGJlIHB1c2hlZCB0byB0aGUgc3RhY2sgb2YgdGhlIG91dGxldCAoaW9uLXJvdXRlci1vdXRsZXQpLFxuICAgKiBhbmQgdGhhdCBpdCB3aWxsIHNob3cgYSBcImZvcndhcmRcIiBhbmltYXRpb24gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogTmF2aWdhdGluZyBmb3J3YXJkIGNhbiBhbHNvIGJlIHRyaWdnZXJlZCBpbiBhIGRlY2xhcmF0aXZlIG1hbm5lciBieSB1c2luZyB0aGUgYFtyb3V0ZXJEaXJlY3Rpb25dYCBkaXJlY3RpdmU6XG4gICAqXG4gICAqIGBgYGh0bWxcbiAgICogPGEgcm91dGVyTGluaz1cIi9wYXRoL3RvL3BhZ2VcIiByb3V0ZXJEaXJlY3Rpb249XCJmb3J3YXJkXCI+TGluazwvYT5cbiAgICogYGBgXG4gICAqL1xuICBuYXZpZ2F0ZUZvcndhcmQodXJsOiBzdHJpbmcgfCBVcmxUcmVlIHwgYW55W10sIG9wdGlvbnM6IE5hdmlnYXRpb25PcHRpb25zID0ge30pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aGlzLnNldERpcmVjdGlvbignZm9yd2FyZCcsIG9wdGlvbnMuYW5pbWF0ZWQsIG9wdGlvbnMuYW5pbWF0aW9uRGlyZWN0aW9uLCBvcHRpb25zLmFuaW1hdGlvbik7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdGUodXJsLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB1c2VzIEFuZ3VsYXIncyBbUm91dGVyXShodHRwczovL2FuZ3VsYXIuaW8vYXBpL3JvdXRlci9Sb3V0ZXIpIHVuZGVyIHRoZSBob29kLFxuICAgKiBpdCdzIGVxdWl2YWxlbnQgdG8gY2FsbGluZzpcbiAgICpcbiAgICogYGBgdHNcbiAgICogdGhpcy5uYXZDb250cm9sbGVyLnNldERpcmVjdGlvbignYmFjaycpO1xuICAgKiB0aGlzLnJvdXRlci5uYXZpZ2F0ZUJ5VXJsKHBhdGgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogR29pbmcgKipiYWNrKiogbWVhbnMgdGhhdCBhbGwgdGhlIHBhZ2VzIGluIHRoZSBzdGFjayB1bnRpbCB0aGUgbmF2aWdhdGVkIHBhZ2UgaXMgZm91bmQgd2lsbCBiZSBwb3BwZWQsXG4gICAqIGFuZCB0aGF0IGl0IHdpbGwgc2hvdyBhIFwiYmFja1wiIGFuaW1hdGlvbiBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBOYXZpZ2F0aW5nIGJhY2sgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIGluIGEgZGVjbGFyYXRpdmUgbWFubmVyIGJ5IHVzaW5nIHRoZSBgW3JvdXRlckRpcmVjdGlvbl1gIGRpcmVjdGl2ZTpcbiAgICpcbiAgICogYGBgaHRtbFxuICAgKiA8YSByb3V0ZXJMaW5rPVwiL3BhdGgvdG8vcGFnZVwiIHJvdXRlckRpcmVjdGlvbj1cImJhY2tcIj5MaW5rPC9hPlxuICAgKiBgYGBcbiAgICovXG4gIG5hdmlnYXRlQmFjayh1cmw6IHN0cmluZyB8IFVybFRyZWUgfCBhbnlbXSwgb3B0aW9uczogTmF2aWdhdGlvbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRoaXMuc2V0RGlyZWN0aW9uKCdiYWNrJywgb3B0aW9ucy5hbmltYXRlZCwgb3B0aW9ucy5hbmltYXRpb25EaXJlY3Rpb24sIG9wdGlvbnMuYW5pbWF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZSh1cmwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHVzZXMgQW5ndWxhcidzIFtSb3V0ZXJdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvcm91dGVyL1JvdXRlcikgdW5kZXIgdGhlIGhvb2QsXG4gICAqIGl0J3MgZXF1aXZhbGVudCB0byBjYWxsaW5nOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiB0aGlzLm5hdkNvbnRyb2xsZXIuc2V0RGlyZWN0aW9uKCdyb290Jyk7XG4gICAqIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwocGF0aCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBHb2luZyAqKnJvb3QqKiBtZWFucyB0aGF0IGFsbCBleGlzdGluZyBwYWdlcyBpbiB0aGUgc3RhY2sgd2lsbCBiZSByZW1vdmVkLFxuICAgKiBhbmQgdGhlIG5hdmlnYXRlZCBwYWdlIHdpbGwgYmVjb21lIHRoZSBzaW5nbGUgcGFnZSBpbiB0aGUgc3RhY2suXG4gICAqXG4gICAqIE5hdmlnYXRpbmcgcm9vdCBjYW4gYWxzbyBiZSB0cmlnZ2VyZWQgaW4gYSBkZWNsYXJhdGl2ZSBtYW5uZXIgYnkgdXNpbmcgdGhlIGBbcm91dGVyRGlyZWN0aW9uXWAgZGlyZWN0aXZlOlxuICAgKlxuICAgKiBgYGBodG1sXG4gICAqIDxhIHJvdXRlckxpbms9XCIvcGF0aC90by9wYWdlXCIgcm91dGVyRGlyZWN0aW9uPVwicm9vdFwiPkxpbms8L2E+XG4gICAqIGBgYFxuICAgKi9cbiAgbmF2aWdhdGVSb290KHVybDogc3RyaW5nIHwgVXJsVHJlZSB8IGFueVtdLCBvcHRpb25zOiBOYXZpZ2F0aW9uT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdGhpcy5zZXREaXJlY3Rpb24oJ3Jvb3QnLCBvcHRpb25zLmFuaW1hdGVkLCBvcHRpb25zLmFuaW1hdGlvbkRpcmVjdGlvbiwgb3B0aW9ucy5hbmltYXRpb24pO1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRlKHVybCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2FtZSBhcyBbTG9jYXRpb25dKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29tbW9uL0xvY2F0aW9uKSdzIGJhY2soKSBtZXRob2QuXG4gICAqIEl0IHdpbGwgdXNlIHRoZSBzdGFuZGFyZCBgd2luZG93Lmhpc3RvcnkuYmFjaygpYCB1bmRlciB0aGUgaG9vZCwgYnV0IGZlYXR1cmluZyBhIGBiYWNrYCBhbmltYXRpb25cbiAgICogYnkgZGVmYXVsdC5cbiAgICovXG4gIGJhY2sob3B0aW9uczogQW5pbWF0aW9uT3B0aW9ucyA9IHsgYW5pbWF0ZWQ6IHRydWUsIGFuaW1hdGlvbkRpcmVjdGlvbjogJ2JhY2snIH0pOiB2b2lkIHtcbiAgICB0aGlzLnNldERpcmVjdGlvbignYmFjaycsIG9wdGlvbnMuYW5pbWF0ZWQsIG9wdGlvbnMuYW5pbWF0aW9uRGlyZWN0aW9uLCBvcHRpb25zLmFuaW1hdGlvbik7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kcyBnb2VzIGJhY2sgaW4gdGhlIGNvbnRleHQgb2YgSW9uaWMncyBzdGFjayBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBJdCByZWN1cnNpdmVseSBmaW5kcyB0aGUgdG9wIGFjdGl2ZSBgaW9uLXJvdXRlci1vdXRsZXRgIGFuZCBjYWxscyBgcG9wKClgLlxuICAgKiBUaGlzIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gZ28gYmFjayB3aGVuIHlvdSBhcmUgdXNpbmcgYGlvbi1yb3V0ZXItb3V0bGV0YC5cbiAgICpcbiAgICogUmVzb2x2ZXMgdG8gYHRydWVgIGlmIGl0IHdhcyBhYmxlIHRvIHBvcC5cbiAgICovXG4gIGFzeW5jIHBvcCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsZXQgb3V0bGV0ID0gdGhpcy50b3BPdXRsZXQ7XG5cbiAgICB3aGlsZSAob3V0bGV0KSB7XG4gICAgICBpZiAoYXdhaXQgb3V0bGV0LnBvcCgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0bGV0ID0gb3V0bGV0LnBhcmVudE91dGxldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2RzIHNwZWNpZmllcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBuZXh0IG5hdmlnYXRpb24gcGVyZm9ybWVkIGJ5IHRoZSBBbmd1bGFyIHJvdXRlci5cbiAgICpcbiAgICogYHNldERpcmVjdGlvbigpYCBkb2VzIG5vdCB0cmlnZ2VyIGFueSB0cmFuc2l0aW9uLCBpdCBqdXN0IHNldHMgc29tZSBmbGFncyB0byBiZSBjb25zdW1lZCBieSBgaW9uLXJvdXRlci1vdXRsZXRgLlxuICAgKlxuICAgKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSBgbmF2aWdhdGVGb3J3YXJkKClgLCBgbmF2aWdhdGVCYWNrKClgIGFuZCBgbmF2aWdhdGVSb290KClgIGluc3RlYWQgb2YgYHNldERpcmVjdGlvbigpYC5cbiAgICovXG4gIHNldERpcmVjdGlvbihcbiAgICBkaXJlY3Rpb246IFJvdXRlckRpcmVjdGlvbixcbiAgICBhbmltYXRlZD86IGJvb2xlYW4sXG4gICAgYW5pbWF0aW9uRGlyZWN0aW9uPzogJ2ZvcndhcmQnIHwgJ2JhY2snLFxuICAgIGFuaW1hdGlvbkJ1aWxkZXI/OiBBbmltYXRpb25CdWlsZGVyXG4gICk6IHZvaWQge1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHRoaXMuYW5pbWF0ZWQgPSBnZXRBbmltYXRpb24oZGlyZWN0aW9uLCBhbmltYXRlZCwgYW5pbWF0aW9uRGlyZWN0aW9uKTtcbiAgICB0aGlzLmFuaW1hdGlvbkJ1aWxkZXIgPSBhbmltYXRpb25CdWlsZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0VG9wT3V0bGV0KG91dGxldDogSW9uUm91dGVyT3V0bGV0KTogdm9pZCB7XG4gICAgdGhpcy50b3BPdXRsZXQgPSBvdXRsZXQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdW1lVHJhbnNpdGlvbigpOiB7XG4gICAgZGlyZWN0aW9uOiBSb3V0ZXJEaXJlY3Rpb247XG4gICAgYW5pbWF0aW9uOiBOYXZEaXJlY3Rpb24gfCB1bmRlZmluZWQ7XG4gICAgYW5pbWF0aW9uQnVpbGRlcjogQW5pbWF0aW9uQnVpbGRlciB8IHVuZGVmaW5lZDtcbiAgfSB7XG4gICAgbGV0IGRpcmVjdGlvbjogUm91dGVyRGlyZWN0aW9uID0gJ3Jvb3QnO1xuICAgIGxldCBhbmltYXRpb246IE5hdkRpcmVjdGlvbiB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhbmltYXRpb25CdWlsZGVyID0gdGhpcy5hbmltYXRpb25CdWlsZGVyO1xuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYXV0bycpIHtcbiAgICAgIGRpcmVjdGlvbiA9IHRoaXMuZ3Vlc3NEaXJlY3Rpb247XG4gICAgICBhbmltYXRpb24gPSB0aGlzLmd1ZXNzQW5pbWF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGVkO1xuICAgICAgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICAgIHRoaXMuZGlyZWN0aW9uID0gREVGQVVMVF9ESVJFQ1RJT047XG4gICAgdGhpcy5hbmltYXRlZCA9IERFRkFVTFRfQU5JTUFURUQ7XG4gICAgdGhpcy5hbmltYXRpb25CdWlsZGVyID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIGFuaW1hdGlvbixcbiAgICAgIGFuaW1hdGlvbkJ1aWxkZXIsXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgbmF2aWdhdGUodXJsOiBzdHJpbmcgfCBVcmxUcmVlIHwgYW55W10sIG9wdGlvbnM6IE5hdmlnYXRpb25PcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodXJsKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIHJldHVybiB0aGlzLnJvdXRlciEubmF2aWdhdGUodXJsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqXG4gICAgICAgKiBuYXZpZ2F0ZUJ5VXJsIGlnbm9yZXMgYW55IHByb3BlcnRpZXMgdGhhdFxuICAgICAgICogd291bGQgY2hhbmdlIHRoZSB1cmwsIHNvIHRoaW5ncyBsaWtlIHF1ZXJ5UGFyYW1zXG4gICAgICAgKiB3b3VsZCBiZSBpZ25vcmVkIHVubGVzcyB3ZSBjcmVhdGUgYSB1cmwgdHJlZVxuICAgICAgICogTW9yZSBJbmZvOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xODc5OFxuICAgICAgICovXG4gICAgICBjb25zdCB1cmxUcmVlID0gdGhpcy5zZXJpYWxpemVyLnBhcnNlKHVybC50b1N0cmluZygpKTtcblxuICAgICAgaWYgKG9wdGlvbnMucXVlcnlQYXJhbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmxUcmVlLnF1ZXJ5UGFyYW1zID0geyAuLi5vcHRpb25zLnF1ZXJ5UGFyYW1zIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJsVHJlZS5mcmFnbWVudCA9IG9wdGlvbnMuZnJhZ21lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYG5hdmlnYXRlQnlVcmxgIHdpbGwgc3RpbGwgYXBwbHkgYE5hdmlnYXRpb25FeHRyYXNgIHByb3BlcnRpZXNcbiAgICAgICAqIHRoYXQgZG8gbm90IG1vZGlmeSB0aGUgdXJsLCBzdWNoIGFzIGByZXBsYWNlVXJsYCB3aGljaCBpcyB3aHlcbiAgICAgICAqIGBvcHRpb25zYCBpcyBwYXNzZWQgaW4gaGVyZS5cbiAgICAgICAqL1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgIHJldHVybiB0aGlzLnJvdXRlciEubmF2aWdhdGVCeVVybCh1cmxUcmVlLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZ2V0QW5pbWF0aW9uID0gKFxuICBkaXJlY3Rpb246IFJvdXRlckRpcmVjdGlvbixcbiAgYW5pbWF0ZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gIGFuaW1hdGlvbkRpcmVjdGlvbjogJ2ZvcndhcmQnIHwgJ2JhY2snIHwgdW5kZWZpbmVkXG4pOiBOYXZEaXJlY3Rpb24gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAoYW5pbWF0ZWQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYW5pbWF0aW9uRGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYW5pbWF0aW9uRGlyZWN0aW9uO1xuICB9XG4gIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyB8fCBkaXJlY3Rpb24gPT09ICdiYWNrJykge1xuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncm9vdCcgJiYgYW5pbWF0ZWQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ2ZvcndhcmQnO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBERUZBVUxUX0RJUkVDVElPTiA9ICdhdXRvJztcbmNvbnN0IERFRkFVTFRfQU5JTUFURUQgPSB1bmRlZmluZWQ7XG4iXX0=