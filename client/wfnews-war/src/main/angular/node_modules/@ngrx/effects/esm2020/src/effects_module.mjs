import { inject, NgModule } from '@angular/core';
import { EffectsFeatureModule } from './effects_feature_module';
import { EffectsRootModule } from './effects_root_module';
import { EffectsRunner } from './effects_runner';
import { _FEATURE_EFFECTS, _ROOT_EFFECTS, _ROOT_EFFECTS_GUARD, _FEATURE_EFFECTS_INSTANCE_GROUPS, _ROOT_EFFECTS_INSTANCES, USER_PROVIDED_EFFECTS, } from './tokens';
import { getClasses, isClass } from './utils';
import * as i0 from "@angular/core";
export class EffectsModule {
    static forFeature(...featureEffects) {
        const effects = featureEffects.flat();
        const effectsClasses = getClasses(effects);
        return {
            ngModule: EffectsFeatureModule,
            providers: [
                effectsClasses,
                {
                    provide: _FEATURE_EFFECTS,
                    multi: true,
                    useValue: effects,
                },
                {
                    provide: USER_PROVIDED_EFFECTS,
                    multi: true,
                    useValue: [],
                },
                {
                    provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,
                    multi: true,
                    useFactory: createEffectsInstances,
                    deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS],
                },
            ],
        };
    }
    static forRoot(...rootEffects) {
        const effects = rootEffects.flat();
        const effectsClasses = getClasses(effects);
        return {
            ngModule: EffectsRootModule,
            providers: [
                effectsClasses,
                {
                    provide: _ROOT_EFFECTS,
                    useValue: [effects],
                },
                {
                    provide: _ROOT_EFFECTS_GUARD,
                    useFactory: _provideForRootGuard,
                },
                {
                    provide: USER_PROVIDED_EFFECTS,
                    multi: true,
                    useValue: [],
                },
                {
                    provide: _ROOT_EFFECTS_INSTANCES,
                    useFactory: createEffectsInstances,
                    deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS],
                },
            ],
        };
    }
}
/** @nocollapse */ EffectsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: EffectsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ EffectsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.0", ngImport: i0, type: EffectsModule });
/** @nocollapse */ EffectsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: EffectsModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.0", ngImport: i0, type: EffectsModule, decorators: [{
            type: NgModule,
            args: [{}]
        }] });
function createEffectsInstances(effectsGroups, userProvidedEffectsGroups) {
    const effects = [];
    for (const effectsGroup of effectsGroups) {
        effects.push(...effectsGroup);
    }
    for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {
        effects.push(...userProvidedEffectsGroup);
    }
    return effects.map((effectsClassOrRecord) => isClass(effectsClassOrRecord)
        ? inject(effectsClassOrRecord)
        : effectsClassOrRecord);
}
function _provideForRootGuard() {
    const runner = inject(EffectsRunner, { optional: true, skipSelf: true });
    const rootEffects = inject(_ROOT_EFFECTS, { self: true });
    // check whether any effects are actually passed
    const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);
    if (hasEffects && runner) {
        throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);
    }
    return 'guarded';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWZmZWN0c19tb2R1bGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2VmZmVjdHMvc3JjL2VmZmVjdHNfbW9kdWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQXVCLFFBQVEsRUFBUSxNQUFNLGVBQWUsQ0FBQztBQUM1RSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDakQsT0FBTyxFQUNMLGdCQUFnQixFQUNoQixhQUFhLEVBQ2IsbUJBQW1CLEVBQ25CLGdDQUFnQyxFQUNoQyx1QkFBdUIsRUFDdkIscUJBQXFCLEdBQ3RCLE1BQU0sVUFBVSxDQUFDO0FBRWxCLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0sU0FBUyxDQUFDOztBQUc5QyxNQUFNLE9BQU8sYUFBYTtJQU94QixNQUFNLENBQUMsVUFBVSxDQUNmLEdBQUcsY0FFMEQ7UUFFN0QsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3RDLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQyxPQUFPO1lBQ0wsUUFBUSxFQUFFLG9CQUFvQjtZQUM5QixTQUFTLEVBQUU7Z0JBQ1QsY0FBYztnQkFDZDtvQkFDRSxPQUFPLEVBQUUsZ0JBQWdCO29CQUN6QixLQUFLLEVBQUUsSUFBSTtvQkFDWCxRQUFRLEVBQUUsT0FBTztpQkFDbEI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLHFCQUFxQjtvQkFDOUIsS0FBSyxFQUFFLElBQUk7b0JBQ1gsUUFBUSxFQUFFLEVBQUU7aUJBQ2I7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLGdDQUFnQztvQkFDekMsS0FBSyxFQUFFLElBQUk7b0JBQ1gsVUFBVSxFQUFFLHNCQUFzQjtvQkFDbEMsSUFBSSxFQUFFLENBQUMsZ0JBQWdCLEVBQUUscUJBQXFCLENBQUM7aUJBQ2hEO2FBQ0Y7U0FDRixDQUFDO0lBQ0osQ0FBQztJQVFELE1BQU0sQ0FBQyxPQUFPLENBQ1osR0FBRyxXQUUwRDtRQUU3RCxNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDbkMsTUFBTSxjQUFjLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzNDLE9BQU87WUFDTCxRQUFRLEVBQUUsaUJBQWlCO1lBQzNCLFNBQVMsRUFBRTtnQkFDVCxjQUFjO2dCQUNkO29CQUNFLE9BQU8sRUFBRSxhQUFhO29CQUN0QixRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUM7aUJBQ3BCO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxtQkFBbUI7b0JBQzVCLFVBQVUsRUFBRSxvQkFBb0I7aUJBQ2pDO2dCQUNEO29CQUNFLE9BQU8sRUFBRSxxQkFBcUI7b0JBQzlCLEtBQUssRUFBRSxJQUFJO29CQUNYLFFBQVEsRUFBRSxFQUFFO2lCQUNiO2dCQUNEO29CQUNFLE9BQU8sRUFBRSx1QkFBdUI7b0JBQ2hDLFVBQVUsRUFBRSxzQkFBc0I7b0JBQ2xDLElBQUksRUFBRSxDQUFDLGFBQWEsRUFBRSxxQkFBcUIsQ0FBQztpQkFDN0M7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDOzs2SEEzRVUsYUFBYTs4SEFBYixhQUFhOzhIQUFiLGFBQWE7MkZBQWIsYUFBYTtrQkFEekIsUUFBUTttQkFBQyxFQUFFOztBQStFWixTQUFTLHNCQUFzQixDQUM3QixhQUF3RSxFQUN4RSx5QkFBNEM7SUFFNUMsTUFBTSxPQUFPLEdBQTRELEVBQUUsQ0FBQztJQUU1RSxLQUFLLE1BQU0sWUFBWSxJQUFJLGFBQWEsRUFBRTtRQUN4QyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUM7S0FDL0I7SUFFRCxLQUFLLE1BQU0sd0JBQXdCLElBQUkseUJBQXlCLEVBQUU7UUFDaEUsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLHdCQUF3QixDQUFDLENBQUM7S0FDM0M7SUFFRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRSxFQUFFLENBQzFDLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztRQUMzQixDQUFDLENBQUMsTUFBTSxDQUFDLG9CQUFvQixDQUFDO1FBQzlCLENBQUMsQ0FBQyxvQkFBb0IsQ0FDekIsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLG9CQUFvQjtJQUMzQixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUN6RSxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsYUFBYSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFFMUQsZ0RBQWdEO0lBQ2hELE1BQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzlFLElBQUksVUFBVSxJQUFJLE1BQU0sRUFBRTtRQUN4QixNQUFNLElBQUksU0FBUyxDQUNqQixzR0FBc0csQ0FDdkcsQ0FBQztLQUNIO0lBQ0QsT0FBTyxTQUFTLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluamVjdCwgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEVmZmVjdHNGZWF0dXJlTW9kdWxlIH0gZnJvbSAnLi9lZmZlY3RzX2ZlYXR1cmVfbW9kdWxlJztcbmltcG9ydCB7IEVmZmVjdHNSb290TW9kdWxlIH0gZnJvbSAnLi9lZmZlY3RzX3Jvb3RfbW9kdWxlJztcbmltcG9ydCB7IEVmZmVjdHNSdW5uZXIgfSBmcm9tICcuL2VmZmVjdHNfcnVubmVyJztcbmltcG9ydCB7XG4gIF9GRUFUVVJFX0VGRkVDVFMsXG4gIF9ST09UX0VGRkVDVFMsXG4gIF9ST09UX0VGRkVDVFNfR1VBUkQsXG4gIF9GRUFUVVJFX0VGRkVDVFNfSU5TVEFOQ0VfR1JPVVBTLFxuICBfUk9PVF9FRkZFQ1RTX0lOU1RBTkNFUyxcbiAgVVNFUl9QUk9WSURFRF9FRkZFQ1RTLFxufSBmcm9tICcuL3Rva2Vucyc7XG5pbXBvcnQgeyBGdW5jdGlvbmFsRWZmZWN0IH0gZnJvbSAnLi9tb2RlbHMnO1xuaW1wb3J0IHsgZ2V0Q2xhc3NlcywgaXNDbGFzcyB9IGZyb20gJy4vdXRpbHMnO1xuXG5ATmdNb2R1bGUoe30pXG5leHBvcnQgY2xhc3MgRWZmZWN0c01vZHVsZSB7XG4gIHN0YXRpYyBmb3JGZWF0dXJlKFxuICAgIGZlYXR1cmVFZmZlY3RzOiBBcnJheTxUeXBlPHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgRnVuY3Rpb25hbEVmZmVjdD4+XG4gICk6IE1vZHVsZVdpdGhQcm92aWRlcnM8RWZmZWN0c0ZlYXR1cmVNb2R1bGU+O1xuICBzdGF0aWMgZm9yRmVhdHVyZShcbiAgICAuLi5mZWF0dXJlRWZmZWN0czogQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+PlxuICApOiBNb2R1bGVXaXRoUHJvdmlkZXJzPEVmZmVjdHNGZWF0dXJlTW9kdWxlPjtcbiAgc3RhdGljIGZvckZlYXR1cmUoXG4gICAgLi4uZmVhdHVyZUVmZmVjdHM6XG4gICAgICB8IEFycmF5PFR5cGU8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbmFsRWZmZWN0Pj5cbiAgICAgIHwgW0FycmF5PFR5cGU8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbmFsRWZmZWN0Pj5dXG4gICk6IE1vZHVsZVdpdGhQcm92aWRlcnM8RWZmZWN0c0ZlYXR1cmVNb2R1bGU+IHtcbiAgICBjb25zdCBlZmZlY3RzID0gZmVhdHVyZUVmZmVjdHMuZmxhdCgpO1xuICAgIGNvbnN0IGVmZmVjdHNDbGFzc2VzID0gZ2V0Q2xhc3NlcyhlZmZlY3RzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IEVmZmVjdHNGZWF0dXJlTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIGVmZmVjdHNDbGFzc2VzLFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogX0ZFQVRVUkVfRUZGRUNUUyxcbiAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICB1c2VWYWx1ZTogZWZmZWN0cyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IFVTRVJfUFJPVklERURfRUZGRUNUUyxcbiAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICB1c2VWYWx1ZTogW10sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBfRkVBVFVSRV9FRkZFQ1RTX0lOU1RBTkNFX0dST1VQUyxcbiAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICB1c2VGYWN0b3J5OiBjcmVhdGVFZmZlY3RzSW5zdGFuY2VzLFxuICAgICAgICAgIGRlcHM6IFtfRkVBVFVSRV9FRkZFQ1RTLCBVU0VSX1BST1ZJREVEX0VGRkVDVFNdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZvclJvb3QoXG4gICAgcm9vdEVmZmVjdHM6IEFycmF5PFR5cGU8dW5rbm93bj4gfCBSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbmFsRWZmZWN0Pj5cbiAgKTogTW9kdWxlV2l0aFByb3ZpZGVyczxFZmZlY3RzUm9vdE1vZHVsZT47XG4gIHN0YXRpYyBmb3JSb290KFxuICAgIC4uLnJvb3RFZmZlY3RzOiBBcnJheTxUeXBlPHVua25vd24+IHwgUmVjb3JkPHN0cmluZywgRnVuY3Rpb25hbEVmZmVjdD4+XG4gICk6IE1vZHVsZVdpdGhQcm92aWRlcnM8RWZmZWN0c1Jvb3RNb2R1bGU+O1xuICBzdGF0aWMgZm9yUm9vdChcbiAgICAuLi5yb290RWZmZWN0czpcbiAgICAgIHwgQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+PlxuICAgICAgfCBbQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+Pl1cbiAgKTogTW9kdWxlV2l0aFByb3ZpZGVyczxFZmZlY3RzUm9vdE1vZHVsZT4ge1xuICAgIGNvbnN0IGVmZmVjdHMgPSByb290RWZmZWN0cy5mbGF0KCk7XG4gICAgY29uc3QgZWZmZWN0c0NsYXNzZXMgPSBnZXRDbGFzc2VzKGVmZmVjdHMpO1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogRWZmZWN0c1Jvb3RNb2R1bGUsXG4gICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgZWZmZWN0c0NsYXNzZXMsXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBfUk9PVF9FRkZFQ1RTLFxuICAgICAgICAgIHVzZVZhbHVlOiBbZWZmZWN0c10sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBwcm92aWRlOiBfUk9PVF9FRkZFQ1RTX0dVQVJELFxuICAgICAgICAgIHVzZUZhY3Rvcnk6IF9wcm92aWRlRm9yUm9vdEd1YXJkLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcHJvdmlkZTogVVNFUl9QUk9WSURFRF9FRkZFQ1RTLFxuICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgIHVzZVZhbHVlOiBbXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHByb3ZpZGU6IF9ST09UX0VGRkVDVFNfSU5TVEFOQ0VTLFxuICAgICAgICAgIHVzZUZhY3Rvcnk6IGNyZWF0ZUVmZmVjdHNJbnN0YW5jZXMsXG4gICAgICAgICAgZGVwczogW19ST09UX0VGRkVDVFMsIFVTRVJfUFJPVklERURfRUZGRUNUU10sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWZmZWN0c0luc3RhbmNlcyhcbiAgZWZmZWN0c0dyb3VwczogQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+PltdLFxuICB1c2VyUHJvdmlkZWRFZmZlY3RzR3JvdXBzOiBUeXBlPHVua25vd24+W11bXVxuKTogdW5rbm93bltdIHtcbiAgY29uc3QgZWZmZWN0czogQXJyYXk8VHlwZTx1bmtub3duPiB8IFJlY29yZDxzdHJpbmcsIEZ1bmN0aW9uYWxFZmZlY3Q+PiA9IFtdO1xuXG4gIGZvciAoY29uc3QgZWZmZWN0c0dyb3VwIG9mIGVmZmVjdHNHcm91cHMpIHtcbiAgICBlZmZlY3RzLnB1c2goLi4uZWZmZWN0c0dyb3VwKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdXNlclByb3ZpZGVkRWZmZWN0c0dyb3VwIG9mIHVzZXJQcm92aWRlZEVmZmVjdHNHcm91cHMpIHtcbiAgICBlZmZlY3RzLnB1c2goLi4udXNlclByb3ZpZGVkRWZmZWN0c0dyb3VwKTtcbiAgfVxuXG4gIHJldHVybiBlZmZlY3RzLm1hcCgoZWZmZWN0c0NsYXNzT3JSZWNvcmQpID0+XG4gICAgaXNDbGFzcyhlZmZlY3RzQ2xhc3NPclJlY29yZClcbiAgICAgID8gaW5qZWN0KGVmZmVjdHNDbGFzc09yUmVjb3JkKVxuICAgICAgOiBlZmZlY3RzQ2xhc3NPclJlY29yZFxuICApO1xufVxuXG5mdW5jdGlvbiBfcHJvdmlkZUZvclJvb3RHdWFyZCgpOiB1bmtub3duIHtcbiAgY29uc3QgcnVubmVyID0gaW5qZWN0KEVmZmVjdHNSdW5uZXIsIHsgb3B0aW9uYWw6IHRydWUsIHNraXBTZWxmOiB0cnVlIH0pO1xuICBjb25zdCByb290RWZmZWN0cyA9IGluamVjdChfUk9PVF9FRkZFQ1RTLCB7IHNlbGY6IHRydWUgfSk7XG5cbiAgLy8gY2hlY2sgd2hldGhlciBhbnkgZWZmZWN0cyBhcmUgYWN0dWFsbHkgcGFzc2VkXG4gIGNvbnN0IGhhc0VmZmVjdHMgPSAhKHJvb3RFZmZlY3RzLmxlbmd0aCA9PT0gMSAmJiByb290RWZmZWN0c1swXS5sZW5ndGggPT09IDApO1xuICBpZiAoaGFzRWZmZWN0cyAmJiBydW5uZXIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYEVmZmVjdHNNb2R1bGUuZm9yUm9vdCgpIGNhbGxlZCB0d2ljZS4gRmVhdHVyZSBtb2R1bGVzIHNob3VsZCB1c2UgRWZmZWN0c01vZHVsZS5mb3JGZWF0dXJlKCkgaW5zdGVhZC5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gJ2d1YXJkZWQnO1xufVxuIl19