import { Component, ElementRef, EventEmitter, Input, Output, ViewChild } from "@angular/core";
import { FormBuilder } from "@angular/forms";
import { select, Store } from "@ngrx/store";
import * as momentInstance from "moment";
import { IncidentType } from "../../../application-icon/application-icon.model";
import { selectCurrentSearchParam } from "../../../utils";
import * as SearchActions from "../../store/actions";
const moment = momentInstance;
export class FiltersComponent {
    constructor(formBuilder, store) {
        this.formBuilder = formBuilder;
        this.store = store;
        this.filters = [];
        this.TOOLTIP_DELAY = 500;
        this.fromDateMin = [];
        this.toDateMax = [];
        this.DATE_FORMATS = {
            fullPickerInput: 'YYYY-MM-DD HH:mm',
            datePickerInput: 'YYYY-MM-DD',
            timePickerInput: 'HH:mm:ss',
            monthYearLabel: 'YYYY-MM',
            dateA11yLabel: 'YYYY-MMM-DD',
            monthYearA11yLabel: 'YYYY-MMM',
        };
        this.isShowingFilterOptions = new EventEmitter();
        this.activeFilters = {};
        this.showBody = false;
        this.lastTabPosition = -1;
        this.clearFilterIconType = IncidentType.NOT_SET;
        this.validateDate = (m) => {
            if (!m) { // empty value , so return valid format true
                return true;
            }
            else if (m.creationData) { //Moment
                let input = m.creationData().input;
                if (input.year) { //datepicker selection - input is a Date object - must be valid
                    return true;
                }
                else { //string input - check strict format using moment
                    return moment(input, this.DATE_FORMATS.datePickerInput, true).isValid() || moment(input, this.DATE_FORMATS.fullPickerInput, true).isValid();
                }
            }
            else {
                return true;
            }
        };
    }
    ngOnChanges(changes) {
        if (changes.filters) {
            this.createForm();
        }
    }
    ngOnInit() {
    }
    ngAfterViewInit() {
        this.getActiveFilters();
        setTimeout(() => {
            this.toggleActiveTabContent(true, true);
        }, 500);
    }
    createForm() {
        let fb = this.formBuilder;
        const config = this.filters.reduce(function (acc, f) {
            switch (f.type) {
                case 'dateRange':
                case 'dateTimeRange':
                    acc[f.param] = fb.array([fb.control(null), fb.control(null)]);
                    break;
                case 'single':
                    acc[f.param] = fb.control(null);
                    break;
                case 'multi':
                default:
                    acc[f.param] = fb.array(f.options.map(function () {
                        return fb.control(false);
                    }));
                    break;
            }
            return acc;
        }, {});
        this.filterForm = this.formBuilder.group(config);
    }
    checkboxUpdated(event) {
        const fv = this.filterForm.getRawValue();
        // console.log(fv)
        this.extractValuesFromForm(fv);
    }
    dateUpdated(event, param, fromTo) {
        let fromControl = this.getFormControlsFromArray(this.filterForm, param)[0];
        let toControl = this.getFormControlsFromArray(this.filterForm, param)[1];
        let hasError = false;
        let fromVal = fromTo == 'from' ? event.value : fromControl.value;
        let toVal = fromTo == 'to' ? event.value : toControl.value;
        if (fromTo == 'from' && !this.validateDate(fromVal)) {
            fromControl.setErrors({ 'incorrectFormat': true });
            hasError = true;
        }
        else if (fromTo == 'to' && !this.validateDate(toVal)) {
            toControl.setErrors({ 'incorrectFormat': true });
            hasError = true;
        }
        if (!hasError && fromVal && toVal) {
            fromControl.setErrors(null);
            toControl.setErrors(null);
            let toMoment = moment(toVal);
            let fromMoment = moment(fromVal);
            if (fromMoment.isAfter(toMoment)) {
                if (fromTo == 'from') {
                    fromControl.setErrors({ 'fromAfterTo': true });
                }
                else {
                    toControl.setErrors({ 'toBeforeFrom': true });
                }
                hasError = true;
            }
        }
        if (!hasError) {
            this.extractValuesFromForm(this.filterForm.getRawValue());
        }
    }
    getActiveFilters() {
        this.store.pipe(select(selectCurrentSearchParam(this.componentId, 'filters'))).subscribe(filters => {
            this.activeFilters = filters;
            setTimeout(() => {
                this.updateFormValues();
            }, 0);
        });
    }
    selectTab(tab) {
        // Toggle tab content if active tab is selected, or open tab content if tab clicked and currently tabs are hidden.
        this.toggleActiveTabContent(tab.isActive, this.showBody);
        if (tab.isActive || !this.showBody) {
            this.showBody = !this.showBody;
            this.isShowingFilterOptions.emit(this.showBody);
        }
        this.lastTabPosition = tab.position;
    }
    toggleActiveTabContent(isActiveTab, showBody) {
        let tabBodyWrapperEl = this.filterTabBodyEl.nativeElement.parentElement;
        if (isActiveTab) {
            if (showBody) {
                tabBodyWrapperEl.classList.remove('slidedown');
                tabBodyWrapperEl.classList.add('slideup');
            }
            else {
                tabBodyWrapperEl.classList.remove('slideup');
                tabBodyWrapperEl.classList.add('slidedown');
            }
        }
        else {
            tabBodyWrapperEl.classList.remove('slideup');
            tabBodyWrapperEl.classList.add('slidedown');
        }
    }
    clearFilter(param) {
        this.store.dispatch(new SearchActions.ClearFilterAction(param, this.componentId));
        let formArray = this.filterForm.get(param);
        for (let i = 0; i < formArray.length; i++) {
            let formControl = formArray.controls[i];
            formControl.reset();
        }
    }
    // Update from values from Redux
    updateFormValues() {
        let af = this.activeFilters;
        const formValue = this.filters.reduce(function (acc, f) {
            switch (f.type) {
                case 'dateRange':
                case 'dateTimeRange':
                    acc[f.param] = af && af[f.param] || [null, null];
                    break;
                case 'single':
                    acc[f.param] = ([].concat(af[f.param]))[0]; // ensure scalar, might be array
                    break;
                case 'multi':
                default:
                    acc[f.param] = f.options
                        .map(function (o) {
                        if (!af || !af[f.param])
                            return false;
                        return af[f.param].includes(o.value);
                    });
                    break;
            }
            return acc;
        }, {});
        this.filterForm.patchValue(formValue, { emitEvent: false });
    }
    // Convert form control boolean values to filter values
    extractValuesFromForm(filterValues) {
        const filter = this.filters.reduce(function (acc, f) {
            acc[f.param] = f;
            return acc;
        }, {});
        const validDate = (d) => {
            if (!d || !this.validateDate(d))
                return null;
            return d;
        };
        const activeFilters = Object.entries(filterValues).reduce(function (acc, [prop, val]) {
            let f = filter[prop];
            switch (f.type) {
                case 'dateRange':
                case 'dateTimeRange':
                    acc[prop] = [validDate(val[prop][0]), validDate(val[prop][1])];
                    break;
                case 'single':
                    acc[prop] = val;
                    break;
                case 'multi':
                default:
                    let vals = val
                        .map(function (v, i) { return v ? f.options[i].value : null; })
                        .filter(function (v) { return v; });
                    if (vals.length > 0)
                        acc[prop] = vals;
                    break;
            }
            return acc;
        }, {});
        if (this.filterForm.valid) {
            this.store.dispatch(new SearchActions.UpdateActiveFiltersAction(activeFilters, this.componentId));
        }
    }
    // Template functions
    getFormArrayNames(group) {
        return Object.keys(group.controls);
    }
    getFormControlsFromArray(group, prop) {
        const array = group.get(prop);
        return array.controls;
    }
    getSelectedFilterValues(param) {
        const filter = this.filters.find(function (f) { return f.param == param; });
        let af = this.activeFilters[param];
        switch (filter.type) {
            case 'dateRange':
            case 'dateTimeRange':
                let controls = this.getFormControlsFromArray(this.filterForm, param);
                if (controls) {
                    let format = filter.type == 'dateRange' ? this.DATE_FORMATS.datePickerInput : this.DATE_FORMATS.fullPickerInput;
                    let from = controls[0] && controls[0].value && this.validateDate(controls[0].value) ? moment(controls[0].value).format(format) : 'Any';
                    let to = controls[1] && controls[1].value && this.validateDate(controls[1].value) ? moment(controls[1].value).format(format) : 'Any';
                    return from == "Any" && to == "Any" ? "Any" : from + ' - ' + to;
                }
                else {
                    return "Any";
                }
            case 'single':
                let val = ([].concat(af))[0];
                if (!val)
                    return 'Any';
                return filter.options.find(function (o) { return o.value == val; }).label;
            case 'multi':
            default:
                if (!af || !af.length)
                    return 'Any';
                return filter.options.find(function (o) { return o.value == af[0]; }).label;
            // return (this.activeFilters
            //     && this.labelLookup
            //     && this.activeFilters[param]
            //     && this.activeFilters[param].length > 0
            //     //&& this.activeFilters[param][0]
            //     && this.labelLookup[param])
            //     ? this.labelLookup[param][this.activeFilters[param][0]]
            //     : "Any";
        }
    }
}
FiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'wf1-filters',
                template: "<form class=\"wf1-filters\" [formGroup]=\"filterForm\">\n\t<mat-tab-group>\n\t\t<mat-tab #tab=\"matTab\" class=\"filter-tab\" *ngFor=\"let param of getFormArrayNames(filterForm); let i = index\">\n\t\t\t<ng-template matTabLabel>\n\t\t\t\t<div class=\"filter-tab__header\" (click)=\"selectTab(tab)\" (keydown)=\"selectTab(tab)\">\n\t\t\t\t\t<span class=\"filter-tab__header__title\">{{filters[i].label}}</span>\n\t\t\t\t\t<span class=\"filter-tab__header__subtitle\">\n\t\t\t\t\t\t{{ getSelectedFilterValues( param ) }}\n\t\t\t\t\t</span>\n\t\t\t\t</div>\n\t\t\t</ng-template>\n\t\t\t<ng-template matTabContent>\n\t\t\t\t<div class=\"filter-tab__body\" #filtertabbody>\n\t\t\t\t\t<div class=\"filter-tab__body__icon\">\n\t\t\t\t\t\t<wf1-application-icon class=\"filter-tab__body__clear\" iconType=\"filter-cancel\" [colourCode]=\"clearFilterIconType\" (click)=\"clearFilter(param)\" matTooltip=\"Clear Filter\" [matTooltipShowDelay]=\"TOOLTIP_DELAY\"></wf1-application-icon>\n\t\t\t\t\t</div>\n          \t\t\t<div class=\"filter-tab__body__options\">\n\t\t\t\t\t\t<ng-container *ngIf=\"filters[i].type == 'dateRange' || filters[i].type == 'dateTimeRange'\">\n\t\t\t\t\t\t\t<mat-form-field class=\"date-picker-input\">\n\t\t\t\t\t\t\t\t<input matInput [owlDateTime]=\"fromDT\" (dateTimeChange)=\"dateUpdated($event, param, 'from')\"\n\t\t\t\t\t\t\t\t\t   placeholder=\"From\"\n\t\t\t\t\t\t\t\t\t   [formControl]=\"getFormControlsFromArray(filterForm, param)[0]\"\n\t\t\t\t\t\t\t\t\t   wf1CoreDateMask>\n\t\t\t\t\t\t\t\t<button mat-button [owlDateTimeTrigger]=\"fromDT\">\n\t\t\t\t\t\t\t\t\t<mat-icon>event</mat-icon>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<owl-date-time #fromDT pickerType=\"{{filters[i].type == 'dateRange'? 'calendar': 'both'}}\"\n\t\t\t\t\t\t\t\t\t\t\t   [showSecondsTimer]=\"false\"></owl-date-time>\n\t\t\t\t\t\t\t\t<mat-error *ngIf=\"getFormControlsFromArray(filterForm, param)[0].hasError('incorrectFormat') || getFormControlsFromArray(filterForm, param)[0].hasError('owlDateTimeParse')\">Format must be {{filters[i].type == 'dateRange'? DATE_FORMATS.datePickerInput: DATE_FORMATS.fullPickerInput}}</mat-error>\n\t\t\t\t\t\t\t\t<mat-error *ngIf=\"getFormControlsFromArray(filterForm, param)[0].hasError('fromAfterTo')\">\"From\" date cannot be after \"To\" date.</mat-error>\n\t\t\t\t\t\t\t</mat-form-field>\n\t\t\t\t\t\t\t<mat-form-field class=\"date-picker-input\">\n\t\t\t\t\t\t\t\t<input matInput [owlDateTime]=\"toDT\" (dateTimeChange)=\"dateUpdated($event, param,'to')\"\n\t\t\t\t\t\t\t\t\t   placeholder=\"To\"\n\t\t\t\t\t\t\t\t\t   [formControl]=\"getFormControlsFromArray(filterForm, param)[1]\"\n\t\t\t\t\t\t\t\t\t   wf1CoreDateMask>\n\t\t\t\t\t\t\t\t<button mat-button [owlDateTimeTrigger]=\"toDT\">\n\t\t\t\t\t\t\t\t\t<mat-icon>event</mat-icon>\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t\t<owl-date-time #toDT pickerType=\"{{filters[i].type == 'dateRange'? 'calendar': 'both'}}\"\n\t\t\t\t\t\t\t\t\t\t\t   [showSecondsTimer]=\"false\" ></owl-date-time>\n\t\t\t\t\t\t\t\t<mat-error *ngIf=\"getFormControlsFromArray(filterForm, param)[1].hasError('incorrectFormat') || getFormControlsFromArray(filterForm, param)[1].hasError('owlDateTimeParse')\">Format must be {{filters[i].type == 'dateRange'? DATE_FORMATS.datePickerInput: DATE_FORMATS.fullPickerInput}}</mat-error>\n\t\t\t\t\t\t\t\t<mat-error *ngIf=\"getFormControlsFromArray(filterForm, param)[1].hasError('toBeforeFrom')\">\"To\" date cannot be before \"From\" date.</mat-error>\n\t\t\t\t\t\t\t</mat-form-field>\n\t\t\t\t\t\t</ng-container>\n\n                        <ng-container *ngIf=\"filters[i].type == 'single'\">\n\t\t\t\t\t\t\t<mat-radio-group  \n                                class=\"filter-tab__body__radiogroup\" \n                                [formControl]=\"filterForm.get( param )\" \n                                (change)=\"checkboxUpdated($event);\"\n                            >\n\t\t\t\t\t\t\t\t<mat-radio-button\n                                    *ngFor=\"let filterControl of filters[ i ].options; let j = index\" \n                                    class=\"filter-tab__body__radiogroup__radiobutton\" \n                                    [value]=\"filters[i].options[j].value\"\n                                >\n                                    <span class=\"filter-tab__body__radiogroup__radiobutton__label\">\n                                        {{filters[i].options[j].label}}\n                                    </span>\n\t\t\t\t\t\t\t\t</mat-radio-button>\n\t\t\t\t\t\t\t</mat-radio-group>\n\t\t\t\t\t\t</ng-container>\n\n                        <ng-container *ngIf=\"filters[i].type == 'multi' || !filters[i].type\">\n\t\t\t\t\t\t\t<ng-container *ngFor=\"let filterControl of getFormControlsFromArray(filterForm, param); let j = index\" >\n\t\t\t\t\t\t\t\t<mat-checkbox \n                                    class=\"filter-tab__body__checkbox\" \n                                    [formControl]=\"filterControl\" \n                                    *ngIf=\"filters[i].options[j]\" \n                                    (change)=\"checkboxUpdated($event);\"\n                                >\n\t\t\t\t\t\t\t\t    <span class=\"filter-tab__body__checkbox__label\">\n\t\t\t\t\t\t\t\t\t    {{filters[i].options[j].label}}\n\t\t\t\t\t\t\t\t    </span>\n\t\t\t\t\t\t\t\t</mat-checkbox>\n\t\t\t\t\t\t\t</ng-container>\n\t\t\t\t\t\t</ng-container>\n                    </div>\n\t\t\t\t</div>\n\t\t\t</ng-template>\n\t\t</mat-tab>\n\t</mat-tab-group>\n</form>\n",
                styles: ["::ng-deep .slideup{max-height:0!important;overflow-y:hidden!important;transition:max-height .8s ease-in!important}::ng-deep .slidedown{max-height:500px!important;overflow-y:hidden!important;transition:max-height .8s ease-out!important}"]
            },] }
];
FiltersComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: Store }
];
FiltersComponent.propDecorators = {
    filters: [{ type: Input }],
    componentId: [{ type: Input }],
    isShowingFilterOptions: [{ type: Output }],
    filterTabBodyEl: [{ type: ViewChild, args: ['filtertabbody',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVycy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jb3JlLXVpL3NyYy9saWIvc2VhcmNoL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXJzLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWlCLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBcUIsTUFBTSxFQUFpQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0ksT0FBTyxFQUFhLFdBQVcsRUFBMEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUNoRixPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUM1QyxPQUFPLEtBQUssY0FBYyxNQUFNLFFBQVEsQ0FBQztBQUN6QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0RBQWtELENBQUM7QUFDaEYsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFMUQsT0FBTyxLQUFLLGFBQWEsTUFBTSxxQkFBcUIsQ0FBQztBQUdyRCxNQUFNLE1BQU0sR0FBRyxjQUFjLENBQUM7QUFROUIsTUFBTSxPQUFPLGdCQUFnQjtJQUl6QixZQUNZLFdBQXdCLEVBQ3hCLEtBQXlCO1FBRHpCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLFVBQUssR0FBTCxLQUFLLENBQW9CO1FBSjVCLFlBQU8sR0FBbUIsRUFBRSxDQUFBO1FBYTlCLGtCQUFhLEdBQUcsR0FBRyxDQUFDO1FBQzNCLGdCQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLGNBQVMsR0FBRyxFQUFFLENBQUM7UUFDZixpQkFBWSxHQUFHO1lBQ1gsZUFBZSxFQUFFLGtCQUFrQjtZQUNuQyxlQUFlLEVBQUUsWUFBWTtZQUM3QixlQUFlLEVBQUUsVUFBVTtZQUMzQixjQUFjLEVBQUUsU0FBUztZQUN6QixhQUFhLEVBQUUs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QUFDLENBQUMsQ0FBQSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQTtZQUM5RSw2QkFBNkI7WUFDN0IsMEJBQTBCO1lBQzFCLG1DQUFtQztZQUNuQyw4Q0FBOEM7WUFDOUMsd0NBQXdDO1lBQ3hDLGtDQUFrQztZQUNsQyw4REFBOEQ7WUFDOUQsZUFBZTtTQUNsQjtJQUNMLENBQUM7OztZQXpUSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGFBQWE7Z0JBQ3ZCLDI0S0FBdUM7O2FBRTFDOzs7WUFoQm1CLFdBQVc7WUFDZCxLQUFLOzs7c0JBa0JqQixLQUFLOzBCQTBCTCxLQUFLO3FDQUdMLE1BQU07OEJBVU4sU0FBUyxTQUFDLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT25Jbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMsIFZpZXdDaGlsZCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBGb3JtQXJyYXksIEZvcm1CdWlsZGVyLCBGb3JtQ29udHJvbCwgRm9ybUdyb3VwIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBzZWxlY3QsIFN0b3JlIH0gZnJvbSBcIkBuZ3J4L3N0b3JlXCI7XG5pbXBvcnQgKiBhcyBtb21lbnRJbnN0YW5jZSBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQgeyBJbmNpZGVudFR5cGUgfSBmcm9tIFwiLi4vLi4vLi4vYXBwbGljYXRpb24taWNvbi9hcHBsaWNhdGlvbi1pY29uLm1vZGVsXCI7XG5pbXBvcnQgeyBzZWxlY3RDdXJyZW50U2VhcmNoUGFyYW0gfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHNcIjtcbmltcG9ydCB7IEZpbHRlckNvbmZpZyB9IGZyb20gXCIuLi8uLi9tb2RlbHMvZmlsdGVyL2ZpbHRlci1jb25maWdcIjtcbmltcG9ydCAqIGFzIFNlYXJjaEFjdGlvbnMgZnJvbSBcIi4uLy4uL3N0b3JlL2FjdGlvbnNcIjtcbmltcG9ydCB7IFNlYXJjaFN0YXRlIH0gZnJvbSBcIi4uLy4uL3N0b3JlL3N0YXRlXCI7XG5cbmNvbnN0IG1vbWVudCA9IG1vbWVudEluc3RhbmNlO1xuZGVjbGFyZSB2YXIgJDogYW55O1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3dmMS1maWx0ZXJzJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmlsdGVycy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vZmlsdGVycy5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlcnNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcyB7XG5cbiAgICBASW5wdXQoKSBmaWx0ZXJzOiBGaWx0ZXJDb25maWdbXSA9IFtdXG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBmb3JtQnVpbGRlcjogRm9ybUJ1aWxkZXIsXG4gICAgICAgIHByaXZhdGUgc3RvcmU6IFN0b3JlPFNlYXJjaFN0YXRlPlxuICAgICkgeyB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRm9ybSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgVE9PTFRJUF9ERUxBWSA9IDUwMDtcbiAgICBmcm9tRGF0ZU1pbiA9IFtdO1xuICAgIHRvRGF0ZU1heCA9IFtdO1xuICAgIERBVEVfRk9STUFUUyA9IHtcbiAgICAgICAgZnVsbFBpY2tlcklucHV0OiAnWVlZWS1NTS1ERCBISDptbScsXG4gICAgICAgIGRhdGVQaWNrZXJJbnB1dDogJ1lZWVktTU0tREQnLFxuICAgICAgICB0aW1lUGlja2VySW5wdXQ6ICdISDptbTpzcycsXG4gICAgICAgIG1vbnRoWWVhckxhYmVsOiAnWVlZWS1NTScsXG4gICAgICAgIGRhdGVBMTF5TGFiZWw6ICdZWVlZLU1NTS1ERCcsXG4gICAgICAgIG1vbnRoWWVhckExMXlMYWJlbDogJ1lZWVktTU1NJyxcbiAgICB9O1xuICAgIHByaXZhdGUgX2ZpbHRlcnM6IEZpbHRlckNvbmZpZ1tdO1xuXG4gICAgQElucHV0KClcbiAgICBjb21wb25lbnRJZDogc3RyaW5nO1xuXG4gICAgQE91dHB1dCgpXG4gICAgaXNTaG93aW5nRmlsdGVyT3B0aW9ucyA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIGZpbHRlckZvcm06IEZvcm1Hcm91cDtcbiAgICBhY3RpdmVGaWx0ZXJzOiB7IFtwYXJhbTogc3RyaW5nXTogYW55W10gfSA9IHt9O1xuICAgIHNob3dCb2R5ID0gZmFsc2U7XG4gICAgbGFzdFRhYlBvc2l0aW9uID0gLTE7XG5cbiAgICBjbGVhckZpbHRlckljb25UeXBlID0gSW5jaWRlbnRUeXBlLk5PVF9TRVQ7XG5cbiAgICBAVmlld0NoaWxkKCdmaWx0ZXJ0YWJib2R5JylcbiAgICBmaWx0ZXJUYWJCb2R5RWw6IEVsZW1lbnRSZWY7XG5cbiAgICB2YWxpZGF0ZURhdGUgPSAobSk6IGJvb2xlYW4gPT4ge1xuICAgICAgICBpZiAoIW0pIHsgLy8gZW1wdHkgdmFsdWUgLCBzbyByZXR1cm4gdmFsaWQgZm9ybWF0IHRydWVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG0uY3JlYXRpb25EYXRhKSB7IC8vTW9tZW50XG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBtLmNyZWF0aW9uRGF0YSgpLmlucHV0O1xuICAgICAgICAgICAgaWYgKGlucHV0LnllYXIpIHsgLy9kYXRlcGlja2VyIHNlbGVjdGlvbiAtIGlucHV0IGlzIGEgRGF0ZSBvYmplY3QgLSBtdXN0IGJlIHZhbGlkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgeyAvL3N0cmluZyBpbnB1dCAtIGNoZWNrIHN0cmljdCBmb3JtYXQgdXNpbmcgbW9tZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbWVudChpbnB1dCwgdGhpcy5EQVRFX0ZPUk1BVFMuZGF0ZVBpY2tlcklucHV0LCB0cnVlKS5pc1ZhbGlkKCkgfHwgbW9tZW50KGlucHV0LCB0aGlzLkRBVEVfRk9STUFUUy5mdWxsUGlja2VySW5wdXQsIHRydWUpLmlzVmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmdldEFjdGl2ZUZpbHRlcnMoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUFjdGl2ZVRhYkNvbnRlbnQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgfVxuXG4gICAgY3JlYXRlRm9ybSgpIHtcbiAgICAgICAgbGV0IGZiID0gdGhpcy5mb3JtQnVpbGRlclxuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZmlsdGVycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZikge1xuICAgICAgICAgICAgc3dpdGNoIChmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlUmFuZ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGVUaW1lUmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICBhY2NbZi5wYXJhbV0gPSBmYi5hcnJheShbZmIuY29udHJvbChudWxsKSwgZmIuY29udHJvbChudWxsKV0pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICAgICAgICBhY2NbZi5wYXJhbV0gPSBmYi5jb250cm9sKG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBjYXNlICdtdWx0aSc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYWNjW2YucGFyYW1dID0gZmIuYXJyYXkoZi5vcHRpb25zLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmIuY29udHJvbChmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH0sIHt9KVxuXG4gICAgICAgIHRoaXMuZmlsdGVyRm9ybSA9IHRoaXMuZm9ybUJ1aWxkZXIuZ3JvdXAoY29uZmlnKVxuICAgIH1cblxuICAgIGNoZWNrYm94VXBkYXRlZChldmVudCkge1xuICAgICAgICBjb25zdCBmdiA9IHRoaXMuZmlsdGVyRm9ybS5nZXRSYXdWYWx1ZSgpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGZ2KVxuICAgICAgICB0aGlzLmV4dHJhY3RWYWx1ZXNGcm9tRm9ybShmdik7XG4gICAgfVxuXG4gICAgZGF0ZVVwZGF0ZWQoZXZlbnQsIHBhcmFtLCBmcm9tVG8pIHtcbiAgICAgICAgbGV0IGZyb21Db250cm9sID0gdGhpcy5nZXRGb3JtQ29udHJvbHNGcm9tQXJyYXkodGhpcy5maWx0ZXJGb3JtLCBwYXJhbSlbMF07XG4gICAgICAgIGxldCB0b0NvbnRyb2wgPSB0aGlzLmdldEZvcm1Db250cm9sc0Zyb21BcnJheSh0aGlzLmZpbHRlckZvcm0sIHBhcmFtKVsxXTtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG5cbiAgICAgICAgbGV0IGZyb21WYWwgPSBmcm9tVG8gPT0gJ2Zyb20nID8gZXZlbnQudmFsdWUgOiBmcm9tQ29udHJvbC52YWx1ZTtcbiAgICAgICAgbGV0IHRvVmFsID0gZnJvbVRvID09ICd0bycgPyBldmVudC52YWx1ZSA6IHRvQ29udHJvbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21UbyA9PSAnZnJvbScgJiYgIXRoaXMudmFsaWRhdGVEYXRlKGZyb21WYWwpKSB7XG4gICAgICAgICAgICBmcm9tQ29udHJvbC5zZXRFcnJvcnMoeyAnaW5jb3JyZWN0Rm9ybWF0JzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tVG8gPT0gJ3RvJyAmJiAhdGhpcy52YWxpZGF0ZURhdGUodG9WYWwpKSB7XG4gICAgICAgICAgICB0b0NvbnRyb2wuc2V0RXJyb3JzKHsgJ2luY29ycmVjdEZvcm1hdCc6IHRydWUgfSk7XG4gICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc0Vycm9yICYmIGZyb21WYWwgJiYgdG9WYWwpIHtcbiAgICAgICAgICAgIGZyb21Db250cm9sLnNldEVycm9ycyhudWxsKTtcbiAgICAgICAgICAgIHRvQ29udHJvbC5zZXRFcnJvcnMobnVsbCk7XG4gICAgICAgICAgICBsZXQgdG9Nb21lbnQgPSBtb21lbnQodG9WYWwpO1xuICAgICAgICAgICAgbGV0IGZyb21Nb21lbnQgPSBtb21lbnQoZnJvbVZhbCk7XG4gICAgICAgICAgICBpZiAoZnJvbU1vbWVudC5pc0FmdGVyKHRvTW9tZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tVG8gPT0gJ2Zyb20nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21Db250cm9sLnNldEVycm9ycyh7ICdmcm9tQWZ0ZXJUbyc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9Db250cm9sLnNldEVycm9ycyh7ICd0b0JlZm9yZUZyb20nOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5leHRyYWN0VmFsdWVzRnJvbUZvcm0odGhpcy5maWx0ZXJGb3JtLmdldFJhd1ZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QWN0aXZlRmlsdGVycygpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5waXBlKHNlbGVjdChzZWxlY3RDdXJyZW50U2VhcmNoUGFyYW0odGhpcy5jb21wb25lbnRJZCwgJ2ZpbHRlcnMnKSkpLnN1YnNjcmliZShmaWx0ZXJzID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlRmlsdGVycyA9IGZpbHRlcnM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1WYWx1ZXMoKTtcbiAgICAgICAgICAgIH0sIDApO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNlbGVjdFRhYih0YWIpIHtcbiAgICAgICAgLy8gVG9nZ2xlIHRhYiBjb250ZW50IGlmIGFjdGl2ZSB0YWIgaXMgc2VsZWN0ZWQsIG9yIG9wZW4gdGFiIGNvbnRlbnQgaWYgdGFiIGNsaWNrZWQgYW5kIGN1cnJlbnRseSB0YWJzIGFyZSBoaWRkZW4uXG4gICAgICAgIHRoaXMudG9nZ2xlQWN0aXZlVGFiQ29udGVudCh0YWIuaXNBY3RpdmUsIHRoaXMuc2hvd0JvZHkpO1xuXG4gICAgICAgIGlmICh0YWIuaXNBY3RpdmUgfHwgIXRoaXMuc2hvd0JvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0JvZHkgPSAhdGhpcy5zaG93Qm9keTtcbiAgICAgICAgICAgIHRoaXMuaXNTaG93aW5nRmlsdGVyT3B0aW9ucy5lbWl0KHRoaXMuc2hvd0JvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0VGFiUG9zaXRpb24gPSB0YWIucG9zaXRpb247XG4gICAgfVxuXG4gICAgdG9nZ2xlQWN0aXZlVGFiQ29udGVudChpc0FjdGl2ZVRhYiwgc2hvd0JvZHkpIHtcbiAgICAgICAgbGV0IHRhYkJvZHlXcmFwcGVyRWwgPSB0aGlzLmZpbHRlclRhYkJvZHlFbC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKGlzQWN0aXZlVGFiKSB7XG4gICAgICAgICAgICBpZiAoc2hvd0JvZHkpIHtcbiAgICAgICAgICAgICAgICB0YWJCb2R5V3JhcHBlckVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NsaWRlZG93bicpO1xuICAgICAgICAgICAgICAgIHRhYkJvZHlXcmFwcGVyRWwuY2xhc3NMaXN0LmFkZCgnc2xpZGV1cCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWJCb2R5V3JhcHBlckVsLmNsYXNzTGlzdC5yZW1vdmUoJ3NsaWRldXAnKTtcbiAgICAgICAgICAgICAgICB0YWJCb2R5V3JhcHBlckVsLmNsYXNzTGlzdC5hZGQoJ3NsaWRlZG93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFiQm9keVdyYXBwZXJFbC5jbGFzc0xpc3QucmVtb3ZlKCdzbGlkZXVwJyk7XG4gICAgICAgICAgICB0YWJCb2R5V3JhcHBlckVsLmNsYXNzTGlzdC5hZGQoJ3NsaWRlZG93bicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJGaWx0ZXIocGFyYW06IHN0cmluZykge1xuICAgICAgICB0aGlzLnN0b3JlLmRpc3BhdGNoKG5ldyBTZWFyY2hBY3Rpb25zLkNsZWFyRmlsdGVyQWN0aW9uKHBhcmFtLCB0aGlzLmNvbXBvbmVudElkKSk7XG4gICAgICAgIGxldCBmb3JtQXJyYXkgPSB0aGlzLmZpbHRlckZvcm0uZ2V0KHBhcmFtKSBhcyBGb3JtQXJyYXk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZm9ybUNvbnRyb2wgPSBmb3JtQXJyYXkuY29udHJvbHNbaV0gYXMgRm9ybUNvbnRyb2w7XG4gICAgICAgICAgICBmb3JtQ29udHJvbC5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGZyb20gdmFsdWVzIGZyb20gUmVkdXhcbiAgICB1cGRhdGVGb3JtVmFsdWVzKCkge1xuICAgICAgICBsZXQgYWYgPSB0aGlzLmFjdGl2ZUZpbHRlcnNcblxuICAgICAgICBjb25zdCBmb3JtVmFsdWUgPSB0aGlzLmZpbHRlcnMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0ZVJhbmdlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlVGltZVJhbmdlJzpcbiAgICAgICAgICAgICAgICAgICAgYWNjW2YucGFyYW1dID0gYWYgJiYgYWZbZi5wYXJhbV0gfHwgW251bGwsIG51bGxdXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICAgICAgICBhY2NbZi5wYXJhbV0gPSAoW10uY29uY2F0KGFmW2YucGFyYW1dKSlbMF0gLy8gZW5zdXJlIHNjYWxhciwgbWlnaHQgYmUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ211bHRpJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBhY2NbZi5wYXJhbV0gPSBmLm9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFmIHx8ICFhZltmLnBhcmFtXSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFmW2YucGFyYW1dLmluY2x1ZGVzKG8udmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH0sIHt9KVxuICAgICAgICB0aGlzLmZpbHRlckZvcm0ucGF0Y2hWYWx1ZShmb3JtVmFsdWUsIHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IGZvcm0gY29udHJvbCBib29sZWFuIHZhbHVlcyB0byBmaWx0ZXIgdmFsdWVzXG4gICAgZXh0cmFjdFZhbHVlc0Zyb21Gb3JtKGZpbHRlclZhbHVlczogeyBbcHJvcDogc3RyaW5nXTogYW55IH0pIHtcbiAgICAgICAgY29uc3QgZmlsdGVyOiB7IFtrZXk6IHN0cmluZ106IEZpbHRlckNvbmZpZyB9ID0gdGhpcy5maWx0ZXJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmKSB7XG4gICAgICAgICAgICBhY2NbZi5wYXJhbV0gPSBmXG4gICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH0sIHt9KVxuXG4gICAgICAgIGNvbnN0IHZhbGlkRGF0ZSA9IChkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWQgfHwgIXRoaXMudmFsaWRhdGVEYXRlKGQpKSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgcmV0dXJuIGRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFjdGl2ZUZpbHRlcnMgPSBPYmplY3QuZW50cmllcyhmaWx0ZXJWYWx1ZXMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBbcHJvcCwgdmFsXSkge1xuICAgICAgICAgICAgbGV0IGYgPSBmaWx0ZXJbcHJvcF1cblxuICAgICAgICAgICAgc3dpdGNoIChmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXRlUmFuZ2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGVUaW1lUmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICBhY2NbcHJvcF0gPSBbdmFsaWREYXRlKHZhbFtwcm9wXVswXSksIHZhbGlkRGF0ZSh2YWxbcHJvcF1bMV0pXVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgYWNjW3Byb3BdID0gdmFsXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgICAgICAgICBjYXNlICdtdWx0aSc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHMgPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYsIGkpIHsgcmV0dXJuIHYgPyBmLm9wdGlvbnNbaV0udmFsdWUgOiBudWxsIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2IH0pXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1twcm9wXSA9IHZhbHNcblxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWNjXG4gICAgICAgIH0sIHt9KVxuXG4gICAgICAgIGlmICh0aGlzLmZpbHRlckZvcm0udmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2gobmV3IFNlYXJjaEFjdGlvbnMuVXBkYXRlQWN0aXZlRmlsdGVyc0FjdGlvbihhY3RpdmVGaWx0ZXJzLCB0aGlzLmNvbXBvbmVudElkKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUZW1wbGF0ZSBmdW5jdGlvbnNcbiAgICBnZXRGb3JtQXJyYXlOYW1lcyhncm91cDogRm9ybUdyb3VwKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZ3JvdXAuY29udHJvbHMpO1xuICAgIH1cblxuICAgIGdldEZvcm1Db250cm9sc0Zyb21BcnJheShncm91cDogRm9ybUdyb3VwLCBwcm9wOiBzdHJpbmcpOiBGb3JtR3JvdXBbXSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gZ3JvdXAuZ2V0KHByb3ApIGFzIEZvcm1BcnJheTtcbiAgICAgICAgcmV0dXJuIGFycmF5LmNvbnRyb2xzIGFzIEZvcm1Hcm91cFtdO1xuICAgIH1cblxuICAgIGdldFNlbGVjdGVkRmlsdGVyVmFsdWVzKHBhcmFtOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gdGhpcy5maWx0ZXJzLmZpbmQoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYucGFyYW0gPT0gcGFyYW0gfSlcbiAgICAgICAgbGV0IGFmID0gdGhpcy5hY3RpdmVGaWx0ZXJzW3BhcmFtXVxuXG4gICAgICAgIHN3aXRjaCAoZmlsdGVyLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RhdGVSYW5nZSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlVGltZVJhbmdlJzpcbiAgICAgICAgICAgICAgICBsZXQgY29udHJvbHMgPSB0aGlzLmdldEZvcm1Db250cm9sc0Zyb21BcnJheSh0aGlzLmZpbHRlckZvcm0sIHBhcmFtKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvcm1hdCA9IGZpbHRlci50eXBlID09ICdkYXRlUmFuZ2UnID8gdGhpcy5EQVRFX0ZPUk1BVFMuZGF0ZVBpY2tlcklucHV0IDogdGhpcy5EQVRFX0ZPUk1BVFMuZnVsbFBpY2tlcklucHV0O1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY29udHJvbHNbMF0gJiYgY29udHJvbHNbMF0udmFsdWUgJiYgdGhpcy52YWxpZGF0ZURhdGUoY29udHJvbHNbMF0udmFsdWUpID8gbW9tZW50KGNvbnRyb2xzWzBdLnZhbHVlKS5mb3JtYXQoZm9ybWF0KSA6ICdBbnknO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG8gPSBjb250cm9sc1sxXSAmJiBjb250cm9sc1sxXS52YWx1ZSAmJiB0aGlzLnZhbGlkYXRlRGF0ZShjb250cm9sc1sxXS52YWx1ZSkgPyBtb21lbnQoY29udHJvbHNbMV0udmFsdWUpLmZvcm1hdChmb3JtYXQpIDogJ0FueSc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tID09IFwiQW55XCIgJiYgdG8gPT0gXCJBbnlcIiA/IFwiQW55XCIgOiBmcm9tICsgJyAtICcgKyB0bztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBbnlcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IChbXS5jb25jYXQoYWYpKVswXVxuICAgICAgICAgICAgICAgIGlmICghdmFsKSByZXR1cm4gJ0FueSdcblxuICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXIub3B0aW9ucy5maW5kKGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLnZhbHVlID09IHZhbCB9KS5sYWJlbFxuXG4gICAgICAgICAgICBjYXNlICdtdWx0aSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICghYWYgfHwgIWFmLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdBbnknXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyLm9wdGlvbnMuZmluZChmdW5jdGlvbiAobykgeyByZXR1cm4gby52YWx1ZSA9PSBhZlswXSB9KS5sYWJlbFxuICAgICAgICAgICAgLy8gcmV0dXJuICh0aGlzLmFjdGl2ZUZpbHRlcnNcbiAgICAgICAgICAgIC8vICAgICAmJiB0aGlzLmxhYmVsTG9va3VwXG4gICAgICAgICAgICAvLyAgICAgJiYgdGhpcy5hY3RpdmVGaWx0ZXJzW3BhcmFtXVxuICAgICAgICAgICAgLy8gICAgICYmIHRoaXMuYWN0aXZlRmlsdGVyc1twYXJhbV0ubGVuZ3RoID4gMFxuICAgICAgICAgICAgLy8gICAgIC8vJiYgdGhpcy5hY3RpdmVGaWx0ZXJzW3BhcmFtXVswXVxuICAgICAgICAgICAgLy8gICAgICYmIHRoaXMubGFiZWxMb29rdXBbcGFyYW1dKVxuICAgICAgICAgICAgLy8gICAgID8gdGhpcy5sYWJlbExvb2t1cFtwYXJhbV1bdGhpcy5hY3RpdmVGaWx0ZXJzW3BhcmFtXVswXV1cbiAgICAgICAgICAgIC8vICAgICA6IFwiQW55XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuIl19