import { Injectable } from "@angular/core";
import { Router } from "@angular/router";
import { TokenService } from "../token.service";
import { of } from "rxjs";
import * as i0 from "@angular/core";
import * as i1 from "../token.service";
import * as i2 from "@angular/router";
export class AuthGuard {
    constructor(tokenService, router) {
        this.tokenService = tokenService;
        this.router = router;
        this.baseScopes = []; //["WFRM.GET_CODE_TABLES","WFRM.GET_TOPLEVEL"];
        // console.log("using auth guard");
        this.tokenService.credentialsEmitter.subscribe(credentials => {
            this.credentials = credentials;
        });
    }
    canActivate(next, state) {
        let url = state.url;
        let result = this.checkLogin(url, this.baseScopes);
        return of(result);
    }
    checkLogin(url, scopes) {
        let isAuthorized = (this.credentials) ? this.tokenService.doesUserHaveApplicationPermissions(scopes) : false;
        if (!isAuthorized) {
            this.redirectToErrorPage();
        }
        return isAuthorized;
    }
    redirectToErrorPage() {
        // Navigate to the unauthorized page
        this.router.navigate([{ outlets: { root: ['unauthorized'] } }]);
    }
}
AuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(i1.TokenService), i0.ɵɵinject(i2.Router)); }, token: AuthGuard, providedIn: "root" });
AuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
AuthGuard.ctorParameters = () => [
    { type: TokenService },
    { type: Router }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC1ndWFyZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUtdWkvc3JjL2xpYi9zZXJ2aWNlcy91dGlsL2F1dGgtZ3VhcmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQXNDLE1BQU0sRUFBc0IsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDOUMsT0FBTyxFQUFhLEVBQUUsRUFBQyxNQUFNLE1BQU0sQ0FBQzs7OztBQUtwQyxNQUFNLE9BQU8sU0FBUztJQUdwQixZQUFzQixZQUEwQixFQUFZLE1BQWM7UUFBcEQsaUJBQVksR0FBWixZQUFZLENBQWM7UUFBWSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBRGhFLGVBQVUsR0FBRyxFQUFFLENBQUMsQ0FBQywrQ0FBK0M7UUFFekUsbUNBQW1DO1FBQ2xDLElBQUksQ0FBQyxZQUFZLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQzNELElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELFdBQVcsQ0FDVCxJQUE0QixFQUM1QixLQUEwQjtRQUMxQixJQUFJLEdBQUcsR0FBVyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzVCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNuRCxPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBRUQsVUFBVSxDQUFDLEdBQVcsRUFBRSxNQUFnQjtRQUN0QyxJQUFJLFlBQVksR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxrQ0FBa0MsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO1FBRTdHLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDakIsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7U0FDNUI7UUFDRCxPQUFPLFlBQVksQ0FBQztJQUN0QixDQUFDO0lBRUQsbUJBQW1CO1FBQ2pCLG9DQUFvQztRQUNwQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDOzs7O1lBakNGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O1lBTE8sWUFBWTtZQUR5QixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHtBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBDYW5BY3RpdmF0ZSwgUm91dGVyLCBSb3V0ZXJTdGF0ZVNuYXBzaG90fSBmcm9tIFwiQGFuZ3VsYXIvcm91dGVyXCI7XG5pbXBvcnQge1Rva2VuU2VydmljZX0gZnJvbSBcIi4uL3Rva2VuLnNlcnZpY2VcIjtcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2Z9IGZyb20gXCJyeGpzXCI7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBdXRoR3VhcmQgaW1wbGVtZW50cyBDYW5BY3RpdmF0ZSB7XG4gIHByb3RlY3RlZCBjcmVkZW50aWFscztcbiAgcHJvdGVjdGVkIGJhc2VTY29wZXMgPSBbXTsgLy9bXCJXRlJNLkdFVF9DT0RFX1RBQkxFU1wiLFwiV0ZSTS5HRVRfVE9QTEVWRUxcIl07XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB0b2tlblNlcnZpY2U6IFRva2VuU2VydmljZSwgcHJvdGVjdGVkIHJvdXRlcjogUm91dGVyKSB7XG4gICAvLyBjb25zb2xlLmxvZyhcInVzaW5nIGF1dGggZ3VhcmRcIik7XG4gICAgdGhpcy50b2tlblNlcnZpY2UuY3JlZGVudGlhbHNFbWl0dGVyLnN1YnNjcmliZShjcmVkZW50aWFscyA9PiB7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgfSk7XG4gIH1cblxuICBjYW5BY3RpdmF0ZShcbiAgICBuZXh0OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LFxuICAgIHN0YXRlOiBSb3V0ZXJTdGF0ZVNuYXBzaG90KTogT2JzZXJ2YWJsZTxib29sZWFuPiB8IGJvb2xlYW4ge1xuICAgIGxldCB1cmw6IHN0cmluZyA9IHN0YXRlLnVybDtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5jaGVja0xvZ2luKHVybCwgdGhpcy5iYXNlU2NvcGVzKTtcbiAgICByZXR1cm4gb2YocmVzdWx0KTtcbiAgfVxuXG4gIGNoZWNrTG9naW4odXJsOiBzdHJpbmcsIHNjb3Blczogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICBsZXQgaXNBdXRob3JpemVkID0gKHRoaXMuY3JlZGVudGlhbHMpID8gdGhpcy50b2tlblNlcnZpY2UuZG9lc1VzZXJIYXZlQXBwbGljYXRpb25QZXJtaXNzaW9ucyhzY29wZXMpIDogZmFsc2U7XG5cbiAgICBpZiAoIWlzQXV0aG9yaXplZCkge1xuICAgICAgdGhpcy5yZWRpcmVjdFRvRXJyb3JQYWdlKCk7XG4gICAgfVxuICAgIHJldHVybiBpc0F1dGhvcml6ZWQ7XG4gIH1cblxuICByZWRpcmVjdFRvRXJyb3JQYWdlKCkge1xuICAgIC8vIE5hdmlnYXRlIHRvIHRoZSB1bmF1dGhvcml6ZWQgcGFnZVxuICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFt7IG91dGxldHM6IHsgcm9vdDogWyd1bmF1dGhvcml6ZWQnXSB9IH1dKTtcbiAgfVxufVxuIl19