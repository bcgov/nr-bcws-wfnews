import { ChangeDetectorRef, Component } from "@angular/core";
import { MapService } from "../services/map.service";
import { NestedTreeControl } from "@angular/cdk/tree";
import { MatTreeNestedDataSource } from "@angular/material/tree";
import { SelectionModel } from "@angular/cdk/collections";
export class WFMLLayerTreeComponent {
    constructor(mapService, changeDetectorRef) {
        this.mapService = mapService;
        this.changeDetectorRef = changeDetectorRef;
        /** The selection for checklist */
        this.checklistSelection = new SelectionModel(true /* multiple */);
        this.hasChildren = (_, node) => !!node.child;
        this.treeControl = new NestedTreeControl((node) => node.child);
        this.dataSource = new MatTreeNestedDataSource();
    }
    ngOnInit() {
        if (this.mapService.isMapInitialized('map')) {
            this.initializeTreeLayer();
        }
        else {
            this.mapService.mapInstanceEmitter.asObservable().subscribe(data => {
                this.initializeTreeLayer();
            });
        }
    }
    initializeTreeLayer() {
        const layerTreeView = this.mapService.getLayerTreeView('map');
        if (layerTreeView) {
            this.dataSource.data = layerTreeView.child;
            this.checklistSelection.select(...this.findSelectedElements(layerTreeView));
        }
    }
    findSelectedElements(node) {
        const results = [];
        if (node.isVisible || (node.lyr && node.lyr.isVisible)) {
            results.push(node);
        }
        if (node.child) {
            for (const childNode of node.child) {
                results.push(...this.findSelectedElements(childNode));
            }
        }
        return results;
    }
    /** Whether all the descendants of the node are selected */
    descendantsAllSelected(node) {
        const descendants = this.treeControl.getDescendants(node);
        if (!descendants.length) {
            return this.checklistSelection.isSelected(node);
        }
        const selected = this.checklistSelection.isSelected(node);
        const allSelected = descendants.every(child => this.checklistSelection.isSelected(child));
        if (!selected && allSelected) {
            this.checklistSelection.select(node);
            this.changeDetectorRef.markForCheck();
        }
        return allSelected;
    }
    /** Whether part of the descendants are selected */
    descendantsPartiallySelected(node) {
        const descendants = this.treeControl.getDescendants(node);
        if (!descendants.length) {
            return false;
        }
        const result = descendants.some(child => this.checklistSelection.isSelected(child));
        return result && !this.descendantsAllSelected(node);
    }
    /** Toggle the game selection. Select/deselect all the descendants node */
    nodeSelectionToggle(node) {
        this.checklistSelection.toggle(node);
        if (node.lyr) {
            this.mapService.setLayerVisibility('map', node.lyr.id, this.checklistSelection.isSelected(node));
        }
        const descendants = this.treeControl.getDescendants(node);
        if (this.checklistSelection.isSelected(node)) {
            this.checklistSelection.select(...descendants, node);
        }
        else {
            this.checklistSelection.deselect(...descendants, node);
        }
        for (const childNode of descendants) {
            if (childNode.lyr) {
                this.mapService.setLayerVisibility('map', childNode.lyr.id, this.checklistSelection.isSelected(childNode));
            }
        }
        this.changeDetectorRef.markForCheck();
    }
}
WFMLLayerTreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'wf1-wfml-layer-tree',
                template: "<mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"wf1-layer-tree\">\n    <mat-nested-tree-node *matTreeNodeDef=\"let node\">\n      <li>\n        <div class=\"mat-tree-node\">\n<!--          <button mat-icon-button disabled></button>-->\n          <mat-checkbox [checked]=\"descendantsAllSelected(node)\"\n                        [indeterminate]=\"descendantsPartiallySelected(node)\"\n                        (change)=\"nodeSelectionToggle(node)\"\n                        labelPosition=\"before\">\n            {{node.title}}\n          </mat-checkbox>\n        </div>\n      </li>\n    </mat-nested-tree-node>\n\n    <mat-nested-tree-node *matTreeNodeDef=\"let node; when: hasChildren\">\n      <li>\n        <div class=\"mat-tree-node\">\n          <button mat-icon-button matTreeNodeToggle\n                  [attr.aria-label]=\"'toggle ' + node.title\">\n            <mat-icon>\n              {{treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right'}}\n            </mat-icon>\n          </button>\n          <mat-checkbox [checked]=\"descendantsAllSelected(node)\"\n                        [indeterminate]=\"descendantsPartiallySelected(node)\"\n                        (change)=\"nodeSelectionToggle(node)\"\n                        labelPosition=\"before\">\n            {{node.title}}\n          </mat-checkbox>\n        </div>\n        <ul>\n          <div *ngIf=\"treeControl.isExpanded(node)\">\n            <ng-container matTreeNodeOutlet></ng-container>\n          </div>\n        </ul>\n      </li>\n    </mat-nested-tree-node>\n  </mat-tree>\n"
            },] }
];
WFMLLayerTreeComponent.ctorParameters = () => [
    { type: MapService },
    { type: ChangeDetectorRef }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2ZtbC1sYXllci10cmVlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2NvcmUtdWkvc3JjL2xpYi93Zm1sLWxheWVyLXRyZWUvd2ZtbC1sYXllci10cmVlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsaUJBQWlCLEVBQUUsU0FBUyxFQUFTLE1BQU0sZUFBZSxDQUFDO0FBQ25FLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUVuRCxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUMsdUJBQXVCLEVBQUMsTUFBTSx3QkFBd0IsQ0FBQztBQUMvRCxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFPeEQsTUFBTSxPQUFPLHNCQUFzQjtJQU9qQyxZQUFvQixVQUFzQixFQUFVLGlCQUFvQztRQUFwRSxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVUsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUh4RixrQ0FBa0M7UUFDbEMsdUJBQWtCLEdBQUcsSUFBSSxjQUFjLENBQVcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBc0N2RSxnQkFBVyxHQUFHLENBQUMsQ0FBUyxFQUFFLElBQWMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFuQ3hELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxpQkFBaUIsQ0FBVyxDQUFDLElBQWMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25GLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSx1QkFBdUIsRUFBWSxDQUFDO0lBQzVELENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFF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QUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNaLElBQUksQ0FBQyxVQUFVLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNsRztRQUNELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFELElBQUksSUFBSSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM1QyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEdBQUcsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3REO2FBQU07WUFDTCxJQUFJLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLEdBQUcsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3hEO1FBQ0QsS0FBSyxNQUFNLFNBQVMsSUFBSSxXQUFXLEVBQUU7WUFDbkMsSUFBSSxTQUFTLENBQUMsR0FBRyxFQUFFO2dCQUNqQixJQUFJLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7YUFDNUc7U0FDRjtRQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QyxDQUFDOzs7WUE3RkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLHNrREFBK0M7YUFFaEQ7OztZQVZPLFVBQVU7WUFEVixpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIE9uSW5pdH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7TWFwU2VydmljZX0gZnJvbSBcIi4uL3NlcnZpY2VzL21hcC5zZXJ2aWNlXCI7XG5pbXBvcnQge1RyZWVOb2RlfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9sYXllci10cmVlbWFwXCI7XG5pbXBvcnQge05lc3RlZFRyZWVDb250cm9sfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL3RyZWVcIjtcbmltcG9ydCB7TWF0VHJlZU5lc3RlZERhdGFTb3VyY2V9IGZyb20gXCJAYW5ndWxhci9tYXRlcmlhbC90cmVlXCI7XG5pbXBvcnQge1NlbGVjdGlvbk1vZGVsfSBmcm9tIFwiQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zXCI7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3dmMS13Zm1sLWxheWVyLXRyZWUnLFxuICB0ZW1wbGF0ZVVybDogJy4vd2ZtbC1sYXllci10cmVlLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBXRk1MTGF5ZXJUcmVlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgdHJlZUNvbnRyb2w6IE5lc3RlZFRyZWVDb250cm9sPFRyZWVOb2RlPjtcbiAgZGF0YVNvdXJjZTogTWF0VHJlZU5lc3RlZERhdGFTb3VyY2U8VHJlZU5vZGU+O1xuXG4gIC8qKiBUaGUgc2VsZWN0aW9uIGZvciBjaGVja2xpc3QgKi9cbiAgY2hlY2tsaXN0U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbk1vZGVsPFRyZWVOb2RlPih0cnVlIC8qIG11bHRpcGxlICovKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1hcFNlcnZpY2U6IE1hcFNlcnZpY2UsIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgdGhpcy50cmVlQ29udHJvbCA9IG5ldyBOZXN0ZWRUcmVlQ29udHJvbDxUcmVlTm9kZT4oKG5vZGU6IFRyZWVOb2RlKSA9PiBub2RlLmNoaWxkKTtcbiAgICB0aGlzLmRhdGFTb3VyY2UgPSBuZXcgTWF0VHJlZU5lc3RlZERhdGFTb3VyY2U8VHJlZU5vZGU+KCk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5tYXBTZXJ2aWNlLmlzTWFwSW5pdGlhbGl6ZWQoJ21hcCcpKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemVUcmVlTGF5ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXBTZXJ2aWNlLm1hcEluc3RhbmNlRW1pdHRlci5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUoZGF0YSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRyZWVMYXllcigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaW5pdGlhbGl6ZVRyZWVMYXllcigpIHtcbiAgICBjb25zdCBsYXllclRyZWVWaWV3ID0gdGhpcy5tYXBTZXJ2aWNlLmdldExheWVyVHJlZVZpZXcoJ21hcCcpO1xuICAgIGlmIChsYXllclRyZWVWaWV3KSB7XG4gICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IGxheWVyVHJlZVZpZXcuY2hpbGQ7XG4gICAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5zZWxlY3QoLi4udGhpcy5maW5kU2VsZWN0ZWRFbGVtZW50cyhsYXllclRyZWVWaWV3KSk7XG4gICAgfVxuICB9XG5cbiAgZmluZFNlbGVjdGVkRWxlbWVudHMobm9kZTogVHJlZU5vZGUpOiBUcmVlTm9kZVtdIHtcbiAgICBjb25zdCByZXN1bHRzOiBUcmVlTm9kZVtdID0gW107XG4gICAgaWYgKG5vZGUuaXNWaXNpYmxlIHx8IChub2RlLmx5ciAmJiBub2RlLmx5ci5pc1Zpc2libGUpKSB7XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBub2RlLmNoaWxkKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCguLi50aGlzLmZpbmRTZWxlY3RlZEVsZW1lbnRzKGNoaWxkTm9kZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGhhc0NoaWxkcmVuID0gKF86IG51bWJlciwgbm9kZTogVHJlZU5vZGUpID0+ICEhbm9kZS5jaGlsZDtcblxuICAvKiogV2hldGhlciBhbGwgdGhlIGRlc2NlbmRhbnRzIG9mIHRoZSBub2RlIGFyZSBzZWxlY3RlZCAqL1xuICBkZXNjZW5kYW50c0FsbFNlbGVjdGVkKG5vZGU6IFRyZWVOb2RlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGVzY2VuZGFudHMgPSB0aGlzLnRyZWVDb250cm9sLmdldERlc2NlbmRhbnRzKG5vZGUpO1xuICAgIGlmICghZGVzY2VuZGFudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChub2RlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5pc1NlbGVjdGVkKG5vZGUpO1xuICAgIGNvbnN0IGFsbFNlbGVjdGVkID0gZGVzY2VuZGFudHMuZXZlcnkoY2hpbGQgPT4gdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChjaGlsZCkpO1xuICAgIGlmICghc2VsZWN0ZWQgJiYgYWxsU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLnNlbGVjdChub2RlKTtcbiAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIHJldHVybiBhbGxTZWxlY3RlZDtcbiAgfVxuXG4gIC8qKiBXaGV0aGVyIHBhcnQgb2YgdGhlIGRlc2NlbmRhbnRzIGFyZSBzZWxlY3RlZCAqL1xuICBkZXNjZW5kYW50c1BhcnRpYWxseVNlbGVjdGVkKG5vZGU6IFRyZWVOb2RlKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGVzY2VuZGFudHMgPSB0aGlzLnRyZWVDb250cm9sLmdldERlc2NlbmRhbnRzKG5vZGUpO1xuICAgIGlmICghZGVzY2VuZGFudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRlc2NlbmRhbnRzLnNvbWUoY2hpbGQgPT4gdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChjaGlsZCkpO1xuICAgIHJldHVybiByZXN1bHQgJiYgIXRoaXMuZGVzY2VuZGFudHNBbGxTZWxlY3RlZChub2RlKTtcbiAgfVxuXG4gIC8qKiBUb2dnbGUgdGhlIGdhbWUgc2VsZWN0aW9uLiBTZWxlY3QvZGVzZWxlY3QgYWxsIHRoZSBkZXNjZW5kYW50cyBub2RlICovXG4gIG5vZGVTZWxlY3Rpb25Ub2dnbGUobm9kZTogVHJlZU5vZGUpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi50b2dnbGUobm9kZSk7XG4gICAgaWYgKG5vZGUubHlyKSB7XG4gICAgICB0aGlzLm1hcFNlcnZpY2Uuc2V0TGF5ZXJWaXNpYmlsaXR5KCdtYXAnLCBub2RlLmx5ci5pZCwgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChub2RlKSk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gdGhpcy50cmVlQ29udHJvbC5nZXREZXNjZW5kYW50cyhub2RlKTtcbiAgICBpZiAodGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChub2RlKSkge1xuICAgICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uc2VsZWN0KC4uLmRlc2NlbmRhbnRzLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uZGVzZWxlY3QoLi4uZGVzY2VuZGFudHMsIG5vZGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBkZXNjZW5kYW50cykge1xuICAgICAgaWYgKGNoaWxkTm9kZS5seXIpIHtcbiAgICAgICAgdGhpcy5tYXBTZXJ2aWNlLnNldExheWVyVmlzaWJpbGl0eSgnbWFwJywgY2hpbGROb2RlLmx5ci5pZCwgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChjaGlsZE5vZGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxufVxuIl19