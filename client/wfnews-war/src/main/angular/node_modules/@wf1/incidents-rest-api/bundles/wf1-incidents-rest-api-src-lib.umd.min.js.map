{"version":3,"sources":["ng://@wf1/incidents-rest-api/src/lib/encoder.ts","ng://@wf1/incidents-rest-api/src/lib/variables.ts","ng://@wf1/incidents-rest-api/src/lib/configuration.ts","ng://@wf1/incidents-rest-api/src/lib/api/default.service.ts","ng://@wf1/incidents-rest-api/src/lib/api/api.ts","ng://@wf1/incidents-rest-api/src/lib/model/healthCheckResponseRsrc.ts","ng://@wf1/incidents-rest-api/src/lib/api.module.ts"],"names":["CustomHttpParameterCodec","prototype","encodeKey","k","encodeURIComponent","encodeValue","v","decodeKey","decodeURIComponent","decodeValue","BASE_PATH","InjectionToken","Configuration","configurationParameters","this","apiKeys","username","password","accessToken","basePath","withCredentials","encoder","selectHeaderContentType","contentTypes","length","undefined","type","find","x","_this","isJsonMime","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","DefaultService","httpClient","configuration","HttpHeaders","addToHttpParams","httpParams","value","key","Date","addToHttpParamsRecursive","Array","isArray","forEach","elem","Error","append","toISOString","substr","Object","keys","acknowledgePublicReportOfFire","ifMatch","wildfireYear","reportOfFireNumber","restVersion","onBehalfOfResource","observe","reportProgress","options","headers","defaultHeaders","set","String","httpHeaderAcceptSelected","httpHeaderAccept","httpContentTypeSelected","responseType","startsWith","post","addPublicReportOfFireRelayMessage","publicReportOfFireRelayMessage","queryParameters","HttpParams","params","assignPublicReportOfFire","incidentWildfireYear","incidentNumberSequence","cancelPublicReportOfFire","createExternalUri","externalUriResource","createIncidentAttachment","attachmentResource","createIncidentComment","incidentCommentResource","createInitialFireReport","initialFireReportResource","createProvisionalZone","provisionalZoneResource","createPublicReportOfFire","publicReportOfFireResource","createPublicReportOfFireComment","publicReportOfFireCommentResource","createPublishedIncident","publishedIncidentResource","createReportOfFireAttachment","createWildfireIncident","wildfireIncidentResource","createWildfireParty","wildfirePartyResource","deleteExternalUri","externalUriGuid","delete","deleteIncidentAttachment","attachmentGuid","deleteIncidentComment","incidentCommentGuid","deleteInitialFireReport","initialFireReportId","deleteProvisionalZone","provisionalZoneGuid","deletePublicReportOfFire","deletePublicReportOfFireComment","commentGuid","deletePublicReportOfFireRelayMessage","deletePublishedIncident","publishedIncidentDetailGuid","deleteReportOfFireAttachment","deleteWildfireIncident","deleteWildfireParty","wildfirePartyGuid","getCodeHierarchyListResource","requestId","cacheControl","pragma","authorization","effectiveAsOfDate","codeHierarchyName","get","getCodeHierarchyResourceByCodeTableName","getCodeTableListResource","codeTableName","getCodeTableResourceByCodeTableName","getComplianceAndEnforcementInvestigation","getExternalUri","getExternalUriList","sourceObjectUniqueId","pageNumber","pageRowCount","getIncidentApproval","getIncidentAttachment","getIncidentAttachmentList","archived","privateIndicator","sourceObjectNameCode","attachmentTypeCode","uploadedByUserId","uploadedByByUserType","uploadedByUserGuid","orderBy","element","getIncidentCause","getIncidentComment","externalId","getIncidentComment1","getIncidentCommentList","expand","getIncidentVerification","getInitialFireReport","getInitialFireReportList","searchText","getManagingLandAuthority","getOriginAndCauseInvestigation","getProvisionalZone","getProvisionalZoneList","provisionalZoneIdentifier","provisionalZoneTypeCode","fireCentreOrgUnitIdent","provisionalZonePolygonSpecifiedInd","dismissedInd","effectiveTimeStamp","expiryTimestamp","effectiveAsOfTimestamp","textSearch","provisionedByUserName","provisionedByUserId","lastStateChangeAsOfTimestamp","getPublicReportOfFire","getPublicReportOfFire1","getPublicReportOfFireComment","getPublicReportOfFireComment1","getPublicReportOfFireCommentList","systemGeneratedCommentInd","getPublicReportOfFireList","messageStatusCode","interfaceFireInd","minimumReportedDate","reportedByName","receivedByUserId","receivedByUserGuid","acknowledgedByUserId","acknowledgedByUserGuid","fireCentreOrgUnitIdentifier","zoneOrgUnitIdentifier","reportedByPartyName","callerName","lostCallInd","availableForCallbackInd","publicReportTypeCode","fireSizeComparisionCode","rateOfSpreadCode","smokeColourCode","messageReceivedSource","submittedAsOfTimestamp","receievedAsOfTimestamp","submittedOrReceivedAsOfTimestamp","relayedInd","getPublicReportOfFireStatusChangeList","getPublishedIncident","getPublishedIncidentByIncidentGuid","incidentGuid","getPublishedIncidentList","getReportOfFireAttachment","getReportOfFireAttachmentList","getResourceAllocationAssessment","getSimpleReportOfFireList","getSimpleWildfireIncidentList","incidentStatusCode","incidentTypeCode","stageOfControlCode","responseTypeCode","suspectedCauseCategoryCode","lastUpdatedAsOfTimestamp","getTopLevel","getWildfireIncident","getWildfireIncident1","getWildfireIncidentByIncidentGuid","getWildfireIncidentList","incidentId","incidentName","claimExpectedInd","rehabilitationPlanRequiredInd","paperTrailedInd","fieldPhotoInd","finalReportCompleteInd","incidentCommanderName","signoffSignatureInd","agencyAssistanceTaskIdentifier","approvalSignatureName","approvalSignatureInd","detectionSourceCode","fireClassificationCode","agencyAssistTypeCode","assistingPartyName","discoveredByPartyName","firstActionedByPartyName","leadByPartyName","incidentNumberLabel","probabilityOfInitialAttackSuccessCode","incidentCategoryCode","fireOfNotePublishedInd","wasFireOfNotePublishedInd","getWildfireIncidentStatusChangeList","getWildfireParty","getWildfirePartyList","partyName","partyTypeCode","partyUsageTypeCode","getWildfirePerimeter","queryTheHealthOfTheService","callstack","redactIncidentAttachment","redactReportOfFireAttachment","reviewPublicReportOfFire","signoffIncidentApproval","signoffIncidentVerification","submitPublicReportOfFire","unacknowledgePublicReportOfFire","unassignPublicReportOfFire","uncancelPublicReportOfFire","unsignIncidentApproval","unsignIncidentVerification","updateCodeHierarchyResourceByCodeTableName","codeHierarchyRsrc","put","updateCodeTableResourceByCodeTableName","codeTableRsrc","updateComplianceAndEnforcementInvestigation","complianceAndEnforcementInvestigationResource","updateExternalUri","updateIncidentAttachment","updateInitialFireReport","updateManagingLandAuthority","incidentLandAuthorityResource","updateOriginAndCauseInvestigation","originAndCauseInvestigationResource","updateProvisionalZone","updatePublicReportOfFire","updatePublishedIncident","updateReportOfFireAttachment","updateResourceAllocationAssessment","resourceAllocationAssessmentResource","updateWildfireIncident","updateWildfireParty","updateWildfirePerimeter","wildfirePerimeterResource","Injectable","args","providedIn","HttpClient","Optional","Inject","decorators","APIS","HealthCheckResponseRsrc","ValidationStatusEnum","RED","YELLOW","GREEN","ApiModule","parentModule","http","forRoot","configurationFactory","ngModule","providers","provide","useFactory","NgModule","imports","declarations","exports","SkipSelf","csv","tsv","ssv","pipes"],"mappings":"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","sourcesContent":["import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\nexport interface ConfigurationParameters {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n}\n\nexport class Configuration {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n","/**\n * WFIM Incident Manager API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.8.0-SNAPSHOT\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { AttachmentListResource } from '../model/models';\nimport { AttachmentResource } from '../model/models';\nimport { CodeHierarchyListRsrc } from '../model/models';\nimport { CodeHierarchyRsrc } from '../model/models';\nimport { CodeTableListRsrc } from '../model/models';\nimport { CodeTableRsrc } from '../model/models';\nimport { ComplianceAndEnforcementInvestigationResource } from '../model/models';\nimport { EndpointsResource } from '../model/models';\nimport { ExternalUriResource } from '../model/models';\nimport { HealthCheckResponseRsrc } from '../model/models';\nimport { IncidentApprovalResource } from '../model/models';\nimport { IncidentCauseResource } from '../model/models';\nimport { IncidentCommentListResource } from '../model/models';\nimport { IncidentCommentResource } from '../model/models';\nimport { IncidentLandAuthorityResource } from '../model/models';\nimport { IncidentVerificationResource } from '../model/models';\nimport { InitialFireReportListResource } from '../model/models';\nimport { InitialFireReportResource } from '../model/models';\nimport { MessageListRsrc } from '../model/models';\nimport { OnBehalfOfResource } from '../model/models';\nimport { OriginAndCauseInvestigationResource } from '../model/models';\nimport { ProvisionalZoneListResource } from '../model/models';\nimport { ProvisionalZoneResource } from '../model/models';\nimport { PublicReportOfFireCommentListResource } from '../model/models';\nimport { PublicReportOfFireCommentResource } from '../model/models';\nimport { PublicReportOfFireListResource } from '../model/models';\nimport { PublicReportOfFireResource } from '../model/models';\nimport { PublishedIncidentResource } from '../model/models';\nimport { ResourceAllocationAssessmentResource } from '../model/models';\nimport { SimpleReportOfFireListResource } from '../model/models';\nimport { SimpleWildfireIncidentListResource } from '../model/models';\nimport { StatusChangeListResource } from '../model/models';\nimport { WildfireIncidentListResource } from '../model/models';\nimport { WildfireIncidentResource } from '../model/models';\nimport { WildfirePartyListResource } from '../model/models';\nimport { WildfirePartyResource } from '../model/models';\nimport { WildfirePerimeterResource } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DefaultService {\n\n    protected basePath = 'http://localhost';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Acknowledge a Public Report Of Fire\n     * Acknowledge a Public Report Of Fire\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public acknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public acknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public acknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public acknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling acknowledgePublicReportOfFire.');\n        }\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling acknowledgePublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling acknowledgePublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/acknowledge`,\n            onBehalfOfResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an ReportOfFireRelayMessage to PublicReportOfFire.\n     * Add an ReportOfFireRelayMessage to PublicReportOfFire.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param publicReportOfFireRelayMessage The Public Report Of Fire Relay Message.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addPublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireRelayMessage?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public addPublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireRelayMessage?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public addPublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireRelayMessage?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public addPublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireRelayMessage?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling addPublicReportOfFireRelayMessage.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling addPublicReportOfFireRelayMessage.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (publicReportOfFireRelayMessage !== undefined && publicReportOfFireRelayMessage !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>publicReportOfFireRelayMessage, 'publicReportOfFireRelayMessage');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/relaymessage`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Assign a Public Report Of Fire\n     * Assign a Public Report Of Fire\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param incidentWildfireYear The wildfireYear of the Wildfire Incident resource to be linked to the Report of Fire\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource to be linked to the Report of Fire\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public assignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, incidentWildfireYear?: string, incidentNumberSequence?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public assignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, incidentWildfireYear?: string, incidentNumberSequence?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public assignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, incidentWildfireYear?: string, incidentNumberSequence?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public assignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, incidentWildfireYear?: string, incidentNumberSequence?: string, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling assignPublicReportOfFire.');\n        }\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling assignPublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling assignPublicReportOfFire.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (incidentWildfireYear !== undefined && incidentWildfireYear !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>incidentWildfireYear, 'incidentWildfireYear');\n        }\n        if (incidentNumberSequence !== undefined && incidentNumberSequence !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>incidentNumberSequence, 'incidentNumberSequence');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/assign`,\n            onBehalfOfResource,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Cancel a Public Report Of Fire\n     * Cancel a Public Report Of Fire\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public cancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public cancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public cancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public cancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling cancelPublicReportOfFire.');\n        }\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling cancelPublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling cancelPublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/cancel`,\n            onBehalfOfResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param externalUriResource \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createExternalUri(externalUriResource?: ExternalUriResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public createExternalUri(externalUriResource?: ExternalUriResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public createExternalUri(externalUriResource?: ExternalUriResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public createExternalUri(externalUriResource?: ExternalUriResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/externalUri`,\n            externalUriResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add Incident Attachment\n     * Add a Incident attachment resource to the List of Incident attachment resources\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param attachmentResource The Attachment resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public createIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public createIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public createIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, attachmentResource?: AttachmentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling createIncidentAttachment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling createIncidentAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AttachmentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/attachments`,\n            attachmentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an Incident Comment Resource to the List of Incident Comments resources\n     * Add an Incident Comment Resource to the List of Incident Comments resources\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param incidentCommentResource The IncidentComment resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createIncidentComment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, incidentCommentResource?: IncidentCommentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentCommentResource>;\n    public createIncidentComment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, incidentCommentResource?: IncidentCommentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentCommentResource>>;\n    public createIncidentComment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, incidentCommentResource?: IncidentCommentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentCommentResource>>;\n    public createIncidentComment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, incidentCommentResource?: IncidentCommentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling createIncidentComment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling createIncidentComment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<IncidentCommentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/incidentComments`,\n            incidentCommentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an Initial Fire Report Resource to the List of Initial Fire Reports resources\n     * Add an Initial Fire Report Resource to the List of Initial Fire Reports resources\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param initialFireReportResource The InitialFireReport resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createInitialFireReport(restVersion?: number, initialFireReportResource?: InitialFireReportResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<InitialFireReportResource>;\n    public createInitialFireReport(restVersion?: number, initialFireReportResource?: InitialFireReportResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<InitialFireReportResource>>;\n    public createInitialFireReport(restVersion?: number, initialFireReportResource?: InitialFireReportResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<InitialFireReportResource>>;\n    public createInitialFireReport(restVersion?: number, initialFireReportResource?: InitialFireReportResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<InitialFireReportResource>(`${this.configuration.basePath}/initialFireReports`,\n            initialFireReportResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an Provisional Zone  Resource to the List of Provisional Zones resources\n     * Add an Provisional Zone  Resource to the List of Provisional Zones resources\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param provisionalZoneResource The provisionalZone resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createProvisionalZone(restVersion?: number, provisionalZoneResource?: ProvisionalZoneResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ProvisionalZoneResource>;\n    public createProvisionalZone(restVersion?: number, provisionalZoneResource?: ProvisionalZoneResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ProvisionalZoneResource>>;\n    public createProvisionalZone(restVersion?: number, provisionalZoneResource?: ProvisionalZoneResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ProvisionalZoneResource>>;\n    public createProvisionalZone(restVersion?: number, provisionalZoneResource?: ProvisionalZoneResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<ProvisionalZoneResource>(`${this.configuration.basePath}/provisionalZones`,\n            provisionalZoneResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an Public Report of Fire Resource to the List of Public Report of Fires resources\n     * Add an Public Report of Fire Resource to the List of Public Report of Fires resources\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param publicReportOfFireResource The PublicReportOfFire resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createPublicReportOfFire(restVersion?: number, publicReportOfFireResource?: PublicReportOfFireResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public createPublicReportOfFire(restVersion?: number, publicReportOfFireResource?: PublicReportOfFireResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public createPublicReportOfFire(restVersion?: number, publicReportOfFireResource?: PublicReportOfFireResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public createPublicReportOfFire(restVersion?: number, publicReportOfFireResource?: PublicReportOfFireResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires`,\n            publicReportOfFireResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an ReportOfFireComment Resource to the List of PublicReportOfFire Comments\n     * Add an ReportOfFireComment Resource to the List of PublicReportOfFire Comments\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param publicReportOfFireCommentResource The ReportOfFireComment resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createPublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireCommentResource?: PublicReportOfFireCommentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireCommentResource>;\n    public createPublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireCommentResource?: PublicReportOfFireCommentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireCommentResource>>;\n    public createPublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireCommentResource?: PublicReportOfFireCommentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireCommentResource>>;\n    public createPublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, publicReportOfFireCommentResource?: PublicReportOfFireCommentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling createPublicReportOfFireComment.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling createPublicReportOfFireComment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireCommentResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/comments`,\n            publicReportOfFireCommentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param publishedIncidentResource \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createPublishedIncident(publishedIncidentResource?: PublishedIncidentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public createPublishedIncident(publishedIncidentResource?: PublishedIncidentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public createPublishedIncident(publishedIncidentResource?: PublishedIncidentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public createPublishedIncident(publishedIncidentResource?: PublishedIncidentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/publishedIncidents`,\n            publishedIncidentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add Report of Fire Attachment\n     * Add a Report of Fire attachment resource to the List of Report of Fire attachment resources\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param attachmentResource The Attachment resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public createReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public createReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public createReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, attachmentResource?: AttachmentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling createReportOfFireAttachment.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling createReportOfFireAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AttachmentResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/attachments`,\n            attachmentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an Wildfire Incident Resource to the List of Wildfire Incidents resources\n     * Add an Wildfire Incident Resource to the List of Wildfire Incidents resources\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param wildfireIncidentResource The WildfireIncident resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createWildfireIncident(restVersion?: number, wildfireIncidentResource?: WildfireIncidentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public createWildfireIncident(restVersion?: number, wildfireIncidentResource?: WildfireIncidentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public createWildfireIncident(restVersion?: number, wildfireIncidentResource?: WildfireIncidentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public createWildfireIncident(restVersion?: number, wildfireIncidentResource?: WildfireIncidentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<WildfireIncidentResource>(`${this.configuration.basePath}/incidents`,\n            wildfireIncidentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add an Wildfire Party Resource to the List of Wildfire Partys resources\n     * Add an Wildfire Party Resource to the List of Wildfire Partys resources\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param wildfirePartyResource The WildfireParty resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createWildfireParty(restVersion?: number, wildfirePartyResource?: WildfirePartyResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfirePartyResource>;\n    public createWildfireParty(restVersion?: number, wildfirePartyResource?: WildfirePartyResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfirePartyResource>>;\n    public createWildfireParty(restVersion?: number, wildfirePartyResource?: WildfirePartyResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfirePartyResource>>;\n    public createWildfireParty(restVersion?: number, wildfirePartyResource?: WildfirePartyResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<WildfirePartyResource>(`${this.configuration.basePath}/wildfirePartys`,\n            wildfirePartyResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param externalUriGuid \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteExternalUri(externalUriGuid: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteExternalUri(externalUriGuid: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteExternalUri(externalUriGuid: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteExternalUri(externalUriGuid: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (externalUriGuid === null || externalUriGuid === undefined) {\n            throw new Error('Required parameter externalUriGuid was null or undefined when calling deleteExternalUri.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/externalUri/${encodeURIComponent(String(externalUriGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete Incident Attachment by ID\n     * Delete Incident Attachment by ID\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling deleteIncidentAttachment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling deleteIncidentAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling deleteIncidentAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/attachments/${encodeURIComponent(String(attachmentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete IncidentComment resource by ID\n     * Delete IncidentComment by ID\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param incidentCommentGuid The identifier of the IncidentComment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteIncidentComment(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteIncidentComment(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteIncidentComment(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteIncidentComment(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling deleteIncidentComment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling deleteIncidentComment.');\n        }\n        if (incidentCommentGuid === null || incidentCommentGuid === undefined) {\n            throw new Error('Required parameter incidentCommentGuid was null or undefined when calling deleteIncidentComment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/incidentComments/${encodeURIComponent(String(incidentCommentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete InitialFireReport resource by ID\n     * Delete InitialFireReport by ID\n     * @param initialFireReportId The initialFireReportId of the Initial Fire Report resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (initialFireReportId === null || initialFireReportId === undefined) {\n            throw new Error('Required parameter initialFireReportId was null or undefined when calling deleteInitialFireReport.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/initialFireReports/${encodeURIComponent(String(initialFireReportId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete ProvisionalZone resource by ID\n     * Delete ProvisionalZone by ID\n     * @param provisionalZoneGuid The identifier of the ProvisionalZone resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (provisionalZoneGuid === null || provisionalZoneGuid === undefined) {\n            throw new Error('Required parameter provisionalZoneGuid was null or undefined when calling deleteProvisionalZone.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/provisionalZones/${encodeURIComponent(String(provisionalZoneGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete PublicReportOfFire resource by ID\n     * Delete PublicReportOfFire by ID\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deletePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deletePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deletePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deletePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling deletePublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling deletePublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete ReportOfFireComment resource by ID\n     * Delete ReportOfFireComment by ID\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param commentGuid The identifier of the PublicReportOfFire Comment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deletePublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deletePublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deletePublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deletePublicReportOfFireComment(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling deletePublicReportOfFireComment.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling deletePublicReportOfFireComment.');\n        }\n        if (commentGuid === null || commentGuid === undefined) {\n            throw new Error('Required parameter commentGuid was null or undefined when calling deletePublicReportOfFireComment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/comments/${encodeURIComponent(String(commentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete ReportOfFireRelayMessage from PublicReportOfFire.\n     * Delete ReportOfFireRelayMessage from PublicReportOfFire.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deletePublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deletePublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deletePublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deletePublicReportOfFireRelayMessage(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling deletePublicReportOfFireRelayMessage.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling deletePublicReportOfFireRelayMessage.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/relaymessage`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param publishedIncidentDetailGuid \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deletePublishedIncident(publishedIncidentDetailGuid: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public deletePublishedIncident(publishedIncidentDetailGuid: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public deletePublishedIncident(publishedIncidentDetailGuid: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public deletePublishedIncident(publishedIncidentDetailGuid: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (publishedIncidentDetailGuid === null || publishedIncidentDetailGuid === undefined) {\n            throw new Error('Required parameter publishedIncidentDetailGuid was null or undefined when calling deletePublishedIncident.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/publishedIncidents/${encodeURIComponent(String(publishedIncidentDetailGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete Report of Fire Attachment by ID\n     * Delete Report of Fire Attachment by ID\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling deleteReportOfFireAttachment.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling deleteReportOfFireAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling deleteReportOfFireAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/attachments/${encodeURIComponent(String(attachmentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete WildfireIncident resource by ID\n     * Delete WildfireIncident by ID\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling deleteWildfireIncident.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling deleteWildfireIncident.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete WildfireParty resource by ID\n     * Delete WildfireParty by ID\n     * @param wildfirePartyGuid The identifier of the WildfireParty resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (wildfirePartyGuid === null || wildfirePartyGuid === undefined) {\n            throw new Error('Required parameter wildfirePartyGuid was null or undefined when calling deleteWildfireParty.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/wildfirePartys/${encodeURIComponent(String(wildfirePartyGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Code Hierarchy List Resource\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param codeHierarchyName Filter the results by the codeHierarchyName.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeHierarchyListRsrc>;\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeHierarchyListRsrc>>;\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeHierarchyListRsrc>>;\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n        if (codeHierarchyName !== undefined && codeHierarchyName !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>codeHierarchyName, 'codeHierarchyName');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeHierarchyListRsrc>(`${this.configuration.basePath}/codeHierarchies`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get CodeHierarchy resource by code table name.\n     * @param codeHierarchyName The identifier of the CodeHierarchy resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeHierarchyRsrc>;\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeHierarchyRsrc>>;\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeHierarchyRsrc>>;\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (codeHierarchyName === null || codeHierarchyName === undefined) {\n            throw new Error('Required parameter codeHierarchyName was null or undefined when calling getCodeHierarchyResourceByCodeTableName.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeHierarchyRsrc>(`${this.configuration.basePath}/codeHierarchies/${encodeURIComponent(String(codeHierarchyName))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Code Table List Resource\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param codeTableName Filter the results by the codeTableName.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeTableListRsrc>;\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeTableListRsrc>>;\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeTableListRsrc>>;\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n        if (codeTableName !== undefined && codeTableName !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>codeTableName, 'codeTableName');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeTableListRsrc>(`${this.configuration.basePath}/codeTables`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get CodeTable resource by code table name.\n     * @param codeTableName The identifier of the CodeTable resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeTableRsrc>;\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeTableRsrc>>;\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeTableRsrc>>;\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (codeTableName === null || codeTableName === undefined) {\n            throw new Error('Required parameter codeTableName was null or undefined when calling getCodeTableResourceByCodeTableName.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeTableRsrc>(`${this.configuration.basePath}/codeTables/${encodeURIComponent(String(codeTableName))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an Incidents Compliance And Enforcement Investigation.\n     * Get an Incidents Compliance And Enforcement Investigation.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ComplianceAndEnforcementInvestigationResource>;\n    public getComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ComplianceAndEnforcementInvestigationResource>>;\n    public getComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ComplianceAndEnforcementInvestigationResource>>;\n    public getComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getComplianceAndEnforcementInvestigation.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getComplianceAndEnforcementInvestigation.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<ComplianceAndEnforcementInvestigationResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/complianceAndEnforcementInvestigation`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param externalUriGuid \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getExternalUri(externalUriGuid: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public getExternalUri(externalUriGuid: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public getExternalUri(externalUriGuid: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public getExternalUri(externalUriGuid: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (externalUriGuid === null || externalUriGuid === undefined) {\n            throw new Error('Required parameter externalUriGuid was null or undefined when calling getExternalUri.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/externalUri/${encodeURIComponent(String(externalUriGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param sourceObjectUniqueId \n     * @param pageNumber \n     * @param pageRowCount \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getExternalUriList(sourceObjectUniqueId?: string, pageNumber?: string, pageRowCount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public getExternalUriList(sourceObjectUniqueId?: string, pageNumber?: string, pageRowCount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public getExternalUriList(sourceObjectUniqueId?: string, pageNumber?: string, pageRowCount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public getExternalUriList(sourceObjectUniqueId?: string, pageNumber?: string, pageRowCount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (sourceObjectUniqueId !== undefined && sourceObjectUniqueId !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>sourceObjectUniqueId, 'sourceObjectUniqueId');\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/externalUri`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Approval Results for an Incident by ID.\n     * Get the Approval Results for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentApprovalResource>;\n    public getIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentApprovalResource>>;\n    public getIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentApprovalResource>>;\n    public getIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getIncidentApproval.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getIncidentApproval.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<IncidentApprovalResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/approval`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Incident Attachment by ID.\n     * Get the Incident Attachment by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public getIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public getIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public getIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getIncidentAttachment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getIncidentAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling getIncidentAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<AttachmentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/attachments/${encodeURIComponent(String(attachmentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Incident Attachments.\n     * Get list of Incident Attachments.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param archived List archived attachments\n     * @param privateIndicator List private attachments\n     * @param sourceObjectNameCode The sourceObjectNameCode the results to be returned.\n     * @param attachmentTypeCode The attachmentTypeCode the results to be returned.\n     * @param uploadedByUserId The uploadedByUserId the results to be returned.\n     * @param uploadedByByUserType The uploadedByByUserType the results to be returned.\n     * @param uploadedByUserGuid The uploadedByUserGuid the results to be returned.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentAttachmentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentListResource>;\n    public getIncidentAttachmentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentListResource>>;\n    public getIncidentAttachmentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentListResource>>;\n    public getIncidentAttachmentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getIncidentAttachmentList.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getIncidentAttachmentList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (archived !== undefined && archived !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>archived, 'archived');\n        }\n        if (privateIndicator !== undefined && privateIndicator !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>privateIndicator, 'privateIndicator');\n        }\n        if (sourceObjectNameCode) {\n            sourceObjectNameCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'sourceObjectNameCode');\n            })\n        }\n        if (attachmentTypeCode) {\n            attachmentTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'attachmentTypeCode');\n            })\n        }\n        if (uploadedByUserId) {\n            uploadedByUserId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'uploadedByUserId');\n            })\n        }\n        if (uploadedByByUserType) {\n            uploadedByByUserType.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'uploadedByByUserType');\n            })\n        }\n        if (uploadedByUserGuid) {\n            uploadedByUserGuid.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'uploadedByUserGuid');\n            })\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<AttachmentListResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/attachments`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an Incidents Cause.\n     * Get an Incidents Cause.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentCause(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentCauseResource>;\n    public getIncidentCause(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentCauseResource>>;\n    public getIncidentCause(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentCauseResource>>;\n    public getIncidentCause(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getIncidentCause.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getIncidentCause.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<IncidentCauseResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/incidentCause`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Incident Comment by External ID.\n     * Get the Incident Comment by External ID.\n     * @param externalId The externalId of the Public Report of Fire Comment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentComment(externalId: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentCommentResource>;\n    public getIncidentComment(externalId: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentCommentResource>>;\n    public getIncidentComment(externalId: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentCommentResource>>;\n    public getIncidentComment(externalId: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (externalId === null || externalId === undefined) {\n            throw new Error('Required parameter externalId was null or undefined when calling getIncidentComment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<IncidentCommentResource>(`${this.configuration.basePath}/incidentComments/externalId/${encodeURIComponent(String(externalId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Incident Comment by ID.\n     * Get the Incident Comment by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param incidentCommentGuid The identifier of the Incident Comment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentComment1(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentCommentResource>;\n    public getIncidentComment1(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentCommentResource>>;\n    public getIncidentComment1(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentCommentResource>>;\n    public getIncidentComment1(wildfireYear: string, incidentNumberSequence: string, incidentCommentGuid: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getIncidentComment1.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getIncidentComment1.');\n        }\n        if (incidentCommentGuid === null || incidentCommentGuid === undefined) {\n            throw new Error('Required parameter incidentCommentGuid was null or undefined when calling getIncidentComment1.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<IncidentCommentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/incidentComments/${encodeURIComponent(String(incidentCommentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Incident Comments.\n     * Get list of Incident Comments.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentCommentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentCommentListResource>;\n    public getIncidentCommentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentCommentListResource>>;\n    public getIncidentCommentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentCommentListResource>>;\n    public getIncidentCommentList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getIncidentCommentList.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getIncidentCommentList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<IncidentCommentListResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/incidentComments`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Verification Results for an Incident by ID.\n     * Get the Verification Results for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentVerificationResource>;\n    public getIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentVerificationResource>>;\n    public getIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentVerificationResource>>;\n    public getIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getIncidentVerification.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getIncidentVerification.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<IncidentVerificationResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/verification`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Initial Fire Report by ID.\n     * Get the Initial Fire Report by ID.\n     * @param initialFireReportId The initialFireReportId of the Initial Fire Report resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getInitialFireReport(initialFireReportId: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<InitialFireReportResource>;\n    public getInitialFireReport(initialFireReportId: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<InitialFireReportResource>>;\n    public getInitialFireReport(initialFireReportId: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<InitialFireReportResource>>;\n    public getInitialFireReport(initialFireReportId: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (initialFireReportId === null || initialFireReportId === undefined) {\n            throw new Error('Required parameter initialFireReportId was null or undefined when calling getInitialFireReport.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<InitialFireReportResource>(`${this.configuration.basePath}/initialFireReports/${encodeURIComponent(String(initialFireReportId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Initial Fire Reports.\n     * Get list of Initial Fire Reports.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param searchText Filter the results by the searchText.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getInitialFireReportList(restVersion?: number, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<InitialFireReportListResource>;\n    public getInitialFireReportList(restVersion?: number, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<InitialFireReportListResource>>;\n    public getInitialFireReportList(restVersion?: number, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<InitialFireReportListResource>>;\n    public getInitialFireReportList(restVersion?: number, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (searchText) {\n            searchText.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'searchText');\n            })\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<InitialFireReportListResource>(`${this.configuration.basePath}/initialFireReports`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an Incidents Managing Land Authority.\n     * Get an Incidents Managing Land Authority.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentLandAuthorityResource>;\n    public getManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentLandAuthorityResource>>;\n    public getManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentLandAuthorityResource>>;\n    public getManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getManagingLandAuthority.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getManagingLandAuthority.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<IncidentLandAuthorityResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/managingLandAuthority`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get an Incidents Compliance And Enforcement Investigation.\n     * Get an Incidents Compliance And Enforcement Investigation.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<OriginAndCauseInvestigationResource>;\n    public getOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<OriginAndCauseInvestigationResource>>;\n    public getOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<OriginAndCauseInvestigationResource>>;\n    public getOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getOriginAndCauseInvestigation.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getOriginAndCauseInvestigation.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<OriginAndCauseInvestigationResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/originAndCauseInvestigation`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Provisional Zone by ID.\n     * Get the Provisional Zone by ID.\n     * @param provisionalZoneGuid The identifier of the Provisional Zone resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getProvisionalZone(provisionalZoneGuid: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ProvisionalZoneResource>;\n    public getProvisionalZone(provisionalZoneGuid: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ProvisionalZoneResource>>;\n    public getProvisionalZone(provisionalZoneGuid: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ProvisionalZoneResource>>;\n    public getProvisionalZone(provisionalZoneGuid: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (provisionalZoneGuid === null || provisionalZoneGuid === undefined) {\n            throw new Error('Required parameter provisionalZoneGuid was null or undefined when calling getProvisionalZone.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<ProvisionalZoneResource>(`${this.configuration.basePath}/provisionalZones/${encodeURIComponent(String(provisionalZoneGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Provisional Zones.\n     * Get list of Provisional Zones.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param provisionalZoneGuid Filter the results by the provisionalZoneGuid.\n     * @param provisionalZoneIdentifier Filter the results by the provisionalZoneIdentifier.\n     * @param provisionalZoneTypeCode Filter the results by the provisionalZoneTypeCode.\n     * @param fireCentreOrgUnitIdent Filter the results by the fireCentreOrgUnitIdent.\n     * @param provisionalZonePolygonSpecifiedInd Filter the results by the provisionalZonePolygonSpecifiedInd.\n     * @param dismissedInd Filter the results by the dismissedInd.\n     * @param effectiveTimeStamp Filter the results by the effectiveTimeStamp.\n     * @param expiryTimestamp Filter the results by the expiryTimestamp.\n     * @param effectiveAsOfTimestamp Filter the results by the effectiveAsOfTimesatmp.\n     * @param textSearch Filter the results by the text.\n     * @param provisionedByUserName Filter the results by the provisionedByUserName.\n     * @param provisionedByUserId Filter the results by the provisionedByUserId.\n     * @param lastStateChangeAsOfTimestamp Filter the results by the lastStateChangeAsOfTimestamp.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getProvisionalZoneList(restVersion?: number, provisionalZoneGuid?: Array<string>, provisionalZoneIdentifier?: Array<string>, provisionalZoneTypeCode?: Array<string>, fireCentreOrgUnitIdent?: Array<string>, provisionalZonePolygonSpecifiedInd?: string, dismissedInd?: string, effectiveTimeStamp?: string, expiryTimestamp?: string, effectiveAsOfTimestamp?: string, textSearch?: Array<string>, provisionedByUserName?: Array<string>, provisionedByUserId?: Array<string>, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ProvisionalZoneListResource>;\n    public getProvisionalZoneList(restVersion?: number, provisionalZoneGuid?: Array<string>, provisionalZoneIdentifier?: Array<string>, provisionalZoneTypeCode?: Array<string>, fireCentreOrgUnitIdent?: Array<string>, provisionalZonePolygonSpecifiedInd?: string, dismissedInd?: string, effectiveTimeStamp?: string, expiryTimestamp?: string, effectiveAsOfTimestamp?: string, textSearch?: Array<string>, provisionedByUserName?: Array<string>, provisionedByUserId?: Array<string>, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ProvisionalZoneListResource>>;\n    public getProvisionalZoneList(restVersion?: number, provisionalZoneGuid?: Array<string>, provisionalZoneIdentifier?: Array<string>, provisionalZoneTypeCode?: Array<string>, fireCentreOrgUnitIdent?: Array<string>, provisionalZonePolygonSpecifiedInd?: string, dismissedInd?: string, effectiveTimeStamp?: string, expiryTimestamp?: string, effectiveAsOfTimestamp?: string, textSearch?: Array<string>, provisionedByUserName?: Array<string>, provisionedByUserId?: Array<string>, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ProvisionalZoneListResource>>;\n    public getProvisionalZoneList(restVersion?: number, provisionalZoneGuid?: Array<string>, provisionalZoneIdentifier?: Array<string>, provisionalZoneTypeCode?: Array<string>, fireCentreOrgUnitIdent?: Array<string>, provisionalZonePolygonSpecifiedInd?: string, dismissedInd?: string, effectiveTimeStamp?: string, expiryTimestamp?: string, effectiveAsOfTimestamp?: string, textSearch?: Array<string>, provisionedByUserName?: Array<string>, provisionedByUserId?: Array<string>, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (provisionalZoneGuid) {\n            provisionalZoneGuid.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'provisionalZoneGuid');\n            })\n        }\n        if (provisionalZoneIdentifier) {\n            provisionalZoneIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'provisionalZoneIdentifier');\n            })\n        }\n        if (provisionalZoneTypeCode) {\n            provisionalZoneTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'provisionalZoneTypeCode');\n            })\n        }\n        if (fireCentreOrgUnitIdent) {\n            fireCentreOrgUnitIdent.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireCentreOrgUnitIdent');\n            })\n        }\n        if (provisionalZonePolygonSpecifiedInd !== undefined && provisionalZonePolygonSpecifiedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>provisionalZonePolygonSpecifiedInd, 'provisionalZonePolygonSpecifiedInd');\n        }\n        if (dismissedInd !== undefined && dismissedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>dismissedInd, 'dismissedInd');\n        }\n        if (effectiveTimeStamp !== undefined && effectiveTimeStamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveTimeStamp, 'effectiveTimeStamp');\n        }\n        if (expiryTimestamp !== undefined && expiryTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expiryTimestamp, 'expiryTimestamp');\n        }\n        if (effectiveAsOfTimestamp !== undefined && effectiveAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfTimestamp, 'effectiveAsOfTimestamp');\n        }\n        if (textSearch) {\n            textSearch.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'textSearch');\n            })\n        }\n        if (provisionedByUserName) {\n            provisionedByUserName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'provisionedByUserName');\n            })\n        }\n        if (provisionedByUserId) {\n            provisionedByUserId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'provisionedByUserId');\n            })\n        }\n        if (lastStateChangeAsOfTimestamp !== undefined && lastStateChangeAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>lastStateChangeAsOfTimestamp, 'lastStateChangeAsOfTimestamp');\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<ProvisionalZoneListResource>(`${this.configuration.basePath}/provisionalZones`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Public Report of Fire by External ID.\n     * Get the Public Report of Fire by External ID.\n     * @param externalId The externalId of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublicReportOfFire(externalId: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public getPublicReportOfFire(externalId: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public getPublicReportOfFire(externalId: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public getPublicReportOfFire(externalId: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (externalId === null || externalId === undefined) {\n            throw new Error('Required parameter externalId was null or undefined when calling getPublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/externalId/${encodeURIComponent(String(externalId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Public Report of Fire by ID.\n     * Get the Public Report of Fire by ID.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublicReportOfFire1(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public getPublicReportOfFire1(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public getPublicReportOfFire1(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public getPublicReportOfFire1(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getPublicReportOfFire1.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling getPublicReportOfFire1.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Public Report of Fire Comment by External ID.\n     * Get the Public Report of Fire Comment by External ID.\n     * @param externalId The externalId of the Public Report of Fire Comment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublicReportOfFireComment(externalId: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireCommentResource>;\n    public getPublicReportOfFireComment(externalId: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireCommentResource>>;\n    public getPublicReportOfFireComment(externalId: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireCommentResource>>;\n    public getPublicReportOfFireComment(externalId: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (externalId === null || externalId === undefined) {\n            throw new Error('Required parameter externalId was null or undefined when calling getPublicReportOfFireComment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PublicReportOfFireCommentResource>(`${this.configuration.basePath}/publicReportOfFireComments/externalId/${encodeURIComponent(String(externalId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the PublicReportOfFire Comment by ID.\n     * Get the PublicReportOfFire Comment by ID.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param commentGuid The identifier of the PublicReportOfFire Comment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublicReportOfFireComment1(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireCommentResource>;\n    public getPublicReportOfFireComment1(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireCommentResource>>;\n    public getPublicReportOfFireComment1(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireCommentResource>>;\n    public getPublicReportOfFireComment1(wildfireYear: string, reportOfFireNumber: string, commentGuid: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getPublicReportOfFireComment1.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling getPublicReportOfFireComment1.');\n        }\n        if (commentGuid === null || commentGuid === undefined) {\n            throw new Error('Required parameter commentGuid was null or undefined when calling getPublicReportOfFireComment1.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PublicReportOfFireCommentResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/comments/${encodeURIComponent(String(commentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of PublicReportOfFire Comments.\n     * Get list of PublicReportOfFire Comments.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param searchText Filter the results by the searchText.\n     * @param systemGeneratedCommentInd Filter the results by the systemGeneratedCommentInd.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublicReportOfFireCommentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, searchText?: string, systemGeneratedCommentInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireCommentListResource>;\n    public getPublicReportOfFireCommentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, searchText?: string, systemGeneratedCommentInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireCommentListResource>>;\n    public getPublicReportOfFireCommentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, searchText?: string, systemGeneratedCommentInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireCommentListResource>>;\n    public getPublicReportOfFireCommentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, searchText?: string, systemGeneratedCommentInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getPublicReportOfFireCommentList.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling getPublicReportOfFireCommentList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (searchText !== undefined && searchText !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>searchText, 'searchText');\n        }\n        if (systemGeneratedCommentInd !== undefined && systemGeneratedCommentInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>systemGeneratedCommentInd, 'systemGeneratedCommentInd');\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PublicReportOfFireCommentListResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/comments`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Public Report of Fires.\n     * Get list of Public Report of Fires.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param searchText Filter the results by the searchText.\n     * @param messageStatusCode Filter the results by the messageStatusCode.\n     * @param reportOfFireNumber Filter the results by the reportOfFireNumber.\n     * @param wildfireYear Filter the results by the wildfireYear.\n     * @param interfaceFireInd Filter the results by the interfaceFireInd.\n     * @param minimumReportedDate Filter the results by the minimumReportedDate.\n     * @param reportedByName Filter the results by the reportedByName.\n     * @param receivedByUserId Filter the results by the receivedByUserId.\n     * @param receivedByUserGuid Filter the results by the receivedByUserGuid.\n     * @param acknowledgedByUserId Filter the results by the acknowledgedByUserId.\n     * @param acknowledgedByUserGuid Filter the results by the acknowledgedByUserGuid.\n     * @param fireCentreOrgUnitIdentifier Filter the results by the fireCentreOrgUnitIdentifier.\n     * @param zoneOrgUnitIdentifier Filter the results by the zoneOrgUnitIdentifier.\n     * @param reportedByPartyName Filter the results by the reportedByPartyName.\n     * @param callerName Filter the results by the callerName.\n     * @param lostCallInd Filter the results by the lostCallInd.\n     * @param availableForCallbackInd Filter the results by the availableForCallbackInd.\n     * @param publicReportTypeCode Filter the results by the publicReportTypeCode.\n     * @param fireSizeComparisionCode Filter the results by the fireSizeComparisionCode.\n     * @param rateOfSpreadCode Filter the results by the rateOfSpreadCode.\n     * @param smokeColourCode Filter the results by the smokeColourCode.\n     * @param messageReceivedSource Filter the results by the messageReceivedSource.\n     * @param submittedAsOfTimestamp Filter the results by the submittedTimestamp.\n     * @param receievedAsOfTimestamp Filter the results by the receievedTimestamp.\n     * @param submittedOrReceivedAsOfTimestamp Filter the results by the submittedTimestamp or for RoFs that have not been submitted, by receievedTimestamp.\n     * @param incidentWildfireYear Filter the results by the incidentWildfireYear.\n     * @param incidentNumberSequence Filter the results by the incidentNumberSequence.\n     * @param relayedInd Filter the results by the relayedInd.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublicReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, messageReceivedSource?: Array<string>, submittedAsOfTimestamp?: string, receievedAsOfTimestamp?: string, submittedOrReceivedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireListResource>;\n    public getPublicReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, messageReceivedSource?: Array<string>, submittedAsOfTimestamp?: string, receievedAsOfTimestamp?: string, submittedOrReceivedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireListResource>>;\n    public getPublicReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, messageReceivedSource?: Array<string>, submittedAsOfTimestamp?: string, receievedAsOfTimestamp?: string, submittedOrReceivedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireListResource>>;\n    public getPublicReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, messageReceivedSource?: Array<string>, submittedAsOfTimestamp?: string, receievedAsOfTimestamp?: string, submittedOrReceivedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (searchText) {\n            searchText.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'searchText');\n            })\n        }\n        if (messageStatusCode) {\n            messageStatusCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'messageStatusCode');\n            })\n        }\n        if (reportOfFireNumber) {\n            reportOfFireNumber.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'reportOfFireNumber');\n            })\n        }\n        if (wildfireYear) {\n            wildfireYear.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'wildfireYear');\n            })\n        }\n        if (interfaceFireInd !== undefined && interfaceFireInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>interfaceFireInd, 'interfaceFireInd');\n        }\n        if (minimumReportedDate !== undefined && minimumReportedDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>minimumReportedDate, 'minimumReportedDate');\n        }\n        if (reportedByName) {\n            reportedByName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'reportedByName');\n            })\n        }\n        if (receivedByUserId) {\n            receivedByUserId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'receivedByUserId');\n            })\n        }\n        if (receivedByUserGuid) {\n            receivedByUserGuid.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'receivedByUserGuid');\n            })\n        }\n        if (acknowledgedByUserId) {\n            acknowledgedByUserId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'acknowledgedByUserId');\n            })\n        }\n        if (acknowledgedByUserGuid) {\n            acknowledgedByUserGuid.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'acknowledgedByUserGuid');\n            })\n        }\n        if (fireCentreOrgUnitIdentifier) {\n            fireCentreOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireCentreOrgUnitIdentifier');\n            })\n        }\n        if (zoneOrgUnitIdentifier) {\n            zoneOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'zoneOrgUnitIdentifier');\n            })\n        }\n        if (reportedByPartyName) {\n            reportedByPartyName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'reportedByPartyName');\n            })\n        }\n        if (callerName) {\n            callerName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'callerName');\n            })\n        }\n        if (lostCallInd !== undefined && lostCallInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>lostCallInd, 'lostCallInd');\n        }\n        if (availableForCallbackInd !== undefined && availableForCallbackInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>availableForCallbackInd, 'availableForCallbackInd');\n        }\n        if (publicReportTypeCode) {\n            publicReportTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'publicReportTypeCode');\n            })\n        }\n        if (fireSizeComparisionCode) {\n            fireSizeComparisionCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireSizeComparisionCode');\n            })\n        }\n        if (rateOfSpreadCode) {\n            rateOfSpreadCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'rateOfSpreadCode');\n            })\n        }\n        if (smokeColourCode) {\n            smokeColourCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'smokeColourCode');\n            })\n        }\n        if (messageReceivedSource) {\n            messageReceivedSource.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'messageReceivedSource');\n            })\n        }\n        if (submittedAsOfTimestamp !== undefined && submittedAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>submittedAsOfTimestamp, 'submittedAsOfTimestamp');\n        }\n        if (receievedAsOfTimestamp !== undefined && receievedAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>receievedAsOfTimestamp, 'receievedAsOfTimestamp');\n        }\n        if (submittedOrReceivedAsOfTimestamp !== undefined && submittedOrReceivedAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>submittedOrReceivedAsOfTimestamp, 'submittedOrReceivedAsOfTimestamp');\n        }\n        if (incidentWildfireYear) {\n            incidentWildfireYear.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentWildfireYear');\n            })\n        }\n        if (incidentNumberSequence) {\n            incidentNumberSequence.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentNumberSequence');\n            })\n        }\n        if (relayedInd !== undefined && relayedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>relayedInd, 'relayedInd');\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<PublicReportOfFireListResource>(`${this.configuration.basePath}/publicReportOfFires`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Public Report of Fire Status Changes.\n     * Get list of Public Report of Fire Status Changes.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublicReportOfFireStatusChangeList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<StatusChangeListResource>;\n    public getPublicReportOfFireStatusChangeList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<StatusChangeListResource>>;\n    public getPublicReportOfFireStatusChangeList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<StatusChangeListResource>>;\n    public getPublicReportOfFireStatusChangeList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getPublicReportOfFireStatusChangeList.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling getPublicReportOfFireStatusChangeList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<StatusChangeListResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/statusChanges`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param publishedIncidentDetailGuid \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublishedIncident(publishedIncidentDetailGuid: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public getPublishedIncident(publishedIncidentDetailGuid: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public getPublishedIncident(publishedIncidentDetailGuid: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public getPublishedIncident(publishedIncidentDetailGuid: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (publishedIncidentDetailGuid === null || publishedIncidentDetailGuid === undefined) {\n            throw new Error('Required parameter publishedIncidentDetailGuid was null or undefined when calling getPublishedIncident.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/publishedIncidents/${encodeURIComponent(String(publishedIncidentDetailGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param incidentGuid \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublishedIncidentByIncidentGuid(incidentGuid: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public getPublishedIncidentByIncidentGuid(incidentGuid: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public getPublishedIncidentByIncidentGuid(incidentGuid: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public getPublishedIncidentByIncidentGuid(incidentGuid: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (incidentGuid === null || incidentGuid === undefined) {\n            throw new Error('Required parameter incidentGuid was null or undefined when calling getPublishedIncidentByIncidentGuid.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/publishedIncidents/byIncident/${encodeURIComponent(String(incidentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param pageNumber \n     * @param pageRowCount \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPublishedIncidentList(pageNumber?: string, pageRowCount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public getPublishedIncidentList(pageNumber?: string, pageRowCount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public getPublishedIncidentList(pageNumber?: string, pageRowCount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public getPublishedIncidentList(pageNumber?: string, pageRowCount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/publishedIncidents`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Report of Fire Attachment by ID.\n     * Get the Report of Fire Attachment by ID.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public getReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public getReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public getReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getReportOfFireAttachment.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling getReportOfFireAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling getReportOfFireAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<AttachmentResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/attachments/${encodeURIComponent(String(attachmentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Report of Fire Attachments.\n     * Get list of Report of Fire Attachments.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param archived List archived attachments\n     * @param privateIndicator List private attachments\n     * @param sourceObjectNameCode The sourceObjectNameCode the results to be returned.\n     * @param attachmentTypeCode The attachmentTypeCode the results to be returned.\n     * @param uploadedByUserId The uploadedByUserId the results to be returned.\n     * @param uploadedByByUserType The uploadedByByUserType the results to be returned.\n     * @param uploadedByUserGuid The uploadedByUserGuid the results to be returned.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getReportOfFireAttachmentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentListResource>;\n    public getReportOfFireAttachmentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentListResource>>;\n    public getReportOfFireAttachmentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentListResource>>;\n    public getReportOfFireAttachmentList(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, archived?: string, privateIndicator?: string, sourceObjectNameCode?: Array<string>, attachmentTypeCode?: Array<string>, uploadedByUserId?: Array<string>, uploadedByByUserType?: Array<string>, uploadedByUserGuid?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getReportOfFireAttachmentList.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling getReportOfFireAttachmentList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (archived !== undefined && archived !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>archived, 'archived');\n        }\n        if (privateIndicator !== undefined && privateIndicator !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>privateIndicator, 'privateIndicator');\n        }\n        if (sourceObjectNameCode) {\n            sourceObjectNameCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'sourceObjectNameCode');\n            })\n        }\n        if (attachmentTypeCode) {\n            attachmentTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'attachmentTypeCode');\n            })\n        }\n        if (uploadedByUserId) {\n            uploadedByUserId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'uploadedByUserId');\n            })\n        }\n        if (uploadedByByUserType) {\n            uploadedByByUserType.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'uploadedByByUserType');\n            })\n        }\n        if (uploadedByUserGuid) {\n            uploadedByUserGuid.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'uploadedByUserGuid');\n            })\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<AttachmentListResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/attachments`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Resource Allocation Assessment for an Incident by ID.\n     * Get the Resource Allocation Assessment for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ResourceAllocationAssessmentResource>;\n    public getResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ResourceAllocationAssessmentResource>>;\n    public getResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ResourceAllocationAssessmentResource>>;\n    public getResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getResourceAllocationAssessment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getResourceAllocationAssessment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<ResourceAllocationAssessmentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/resourceAllocationAssessment`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Simple Report of Fires.\n     * Get list of Simple Report of Fires.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param searchText Filter the results by the searchText.\n     * @param messageStatusCode Filter the results by the messageStatusCode.\n     * @param reportOfFireNumber Filter the results by the reportOfFireNumber.\n     * @param wildfireYear Filter the results by the wildfireYear.\n     * @param interfaceFireInd Filter the results by the interfaceFireInd.\n     * @param minimumReportedDate Filter the results by the minimumReportedDate.\n     * @param reportedByName Filter the results by the reportedByName.\n     * @param receivedByUserId Filter the results by the receivedByUserId.\n     * @param receivedByUserGuid Filter the results by the receivedByUserGuid.\n     * @param acknowledgedByUserId Filter the results by the acknowledgedByUserId.\n     * @param acknowledgedByUserGuid Filter the results by the acknowledgedByUserGuid.\n     * @param fireCentreOrgUnitIdentifier Filter the results by the fireCentreOrgUnitIdentifier.\n     * @param zoneOrgUnitIdentifier Filter the results by the zoneOrgUnitIdentifier.\n     * @param reportedByPartyName Filter the results by the reportedByPartyName.\n     * @param callerName Filter the results by the callerName.\n     * @param lostCallInd Filter the results by the lostCallInd.\n     * @param availableForCallbackInd Filter the results by the availableForCallbackInd.\n     * @param publicReportTypeCode Filter the results by the publicReportTypeCode.\n     * @param fireSizeComparisionCode Filter the results by the fireSizeComparisionCode.\n     * @param rateOfSpreadCode Filter the results by the rateOfSpreadCode.\n     * @param smokeColourCode Filter the results by the smokeColourCode.\n     * @param submittedAsOfTimestamp Filter the results by the submittedAsOfTimestamp.\n     * @param incidentWildfireYear Filter the results by the incidentWildfireYear.\n     * @param incidentNumberSequence Filter the results by the incidentNumberSequence.\n     * @param relayedInd Filter the results by the relayedInd.\n     * @param lastStateChangeAsOfTimestamp Filter the results by the lastStateChangeAsOfTimestamp.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSimpleReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, submittedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<SimpleReportOfFireListResource>;\n    public getSimpleReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, submittedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<SimpleReportOfFireListResource>>;\n    public getSimpleReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, submittedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<SimpleReportOfFireListResource>>;\n    public getSimpleReportOfFireList(restVersion?: number, searchText?: Array<string>, messageStatusCode?: Array<string>, reportOfFireNumber?: Array<string>, wildfireYear?: Array<string>, interfaceFireInd?: string, minimumReportedDate?: string, reportedByName?: Array<string>, receivedByUserId?: Array<string>, receivedByUserGuid?: Array<string>, acknowledgedByUserId?: Array<string>, acknowledgedByUserGuid?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, reportedByPartyName?: Array<string>, callerName?: Array<string>, lostCallInd?: string, availableForCallbackInd?: string, publicReportTypeCode?: Array<string>, fireSizeComparisionCode?: Array<string>, rateOfSpreadCode?: Array<string>, smokeColourCode?: Array<string>, submittedAsOfTimestamp?: string, incidentWildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, relayedInd?: string, lastStateChangeAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (searchText) {\n            searchText.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'searchText');\n            })\n        }\n        if (messageStatusCode) {\n            messageStatusCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'messageStatusCode');\n            })\n        }\n        if (reportOfFireNumber) {\n            reportOfFireNumber.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'reportOfFireNumber');\n            })\n        }\n        if (wildfireYear) {\n            wildfireYear.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'wildfireYear');\n            })\n        }\n        if (interfaceFireInd !== undefined && interfaceFireInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>interfaceFireInd, 'interfaceFireInd');\n        }\n        if (minimumReportedDate !== undefined && minimumReportedDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>minimumReportedDate, 'minimumReportedDate');\n        }\n        if (reportedByName) {\n            reportedByName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'reportedByName');\n            })\n        }\n        if (receivedByUserId) {\n            receivedByUserId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'receivedByUserId');\n            })\n        }\n        if (receivedByUserGuid) {\n            receivedByUserGuid.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'receivedByUserGuid');\n            })\n        }\n        if (acknowledgedByUserId) {\n            acknowledgedByUserId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'acknowledgedByUserId');\n            })\n        }\n        if (acknowledgedByUserGuid) {\n            acknowledgedByUserGuid.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'acknowledgedByUserGuid');\n            })\n        }\n        if (fireCentreOrgUnitIdentifier) {\n            fireCentreOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireCentreOrgUnitIdentifier');\n            })\n        }\n        if (zoneOrgUnitIdentifier) {\n            zoneOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'zoneOrgUnitIdentifier');\n            })\n        }\n        if (reportedByPartyName) {\n            reportedByPartyName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'reportedByPartyName');\n            })\n        }\n        if (callerName) {\n            callerName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'callerName');\n            })\n        }\n        if (lostCallInd !== undefined && lostCallInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>lostCallInd, 'lostCallInd');\n        }\n        if (availableForCallbackInd !== undefined && availableForCallbackInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>availableForCallbackInd, 'availableForCallbackInd');\n        }\n        if (publicReportTypeCode) {\n            publicReportTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'publicReportTypeCode');\n            })\n        }\n        if (fireSizeComparisionCode) {\n            fireSizeComparisionCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireSizeComparisionCode');\n            })\n        }\n        if (rateOfSpreadCode) {\n            rateOfSpreadCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'rateOfSpreadCode');\n            })\n        }\n        if (smokeColourCode) {\n            smokeColourCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'smokeColourCode');\n            })\n        }\n        if (submittedAsOfTimestamp !== undefined && submittedAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>submittedAsOfTimestamp, 'submittedAsOfTimestamp');\n        }\n        if (incidentWildfireYear) {\n            incidentWildfireYear.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentWildfireYear');\n            })\n        }\n        if (incidentNumberSequence) {\n            incidentNumberSequence.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentNumberSequence');\n            })\n        }\n        if (relayedInd !== undefined && relayedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>relayedInd, 'relayedInd');\n        }\n        if (lastStateChangeAsOfTimestamp !== undefined && lastStateChangeAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>lastStateChangeAsOfTimestamp, 'lastStateChangeAsOfTimestamp');\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<SimpleReportOfFireListResource>(`${this.configuration.basePath}/simpleReportOfFires`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Simple Wildfire Incidents.\n     * Get list of Simple Wildfire Incidents.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param searchText Filter the results by the searchText.\n     * @param wildfireYear Filter the results by the wildfireYear.\n     * @param incidentNumberSequence Filter the results by the incidentNumberSequence.\n     * @param fireCentreOrgUnitIdentifier Filter the results by the fireCentreOrgUnitIdentifier.\n     * @param zoneOrgUnitIdentifier Filter the results by the zoneOrgUnitIdentifier.\n     * @param incidentStatusCode Filter the results by the incidentStatusCode.\n     * @param incidentTypeCode Filter the results by the incidentTypeCode.\n     * @param stageOfControlCode Filter the results by the stageOfControlCode.\n     * @param responseTypeCode Filter the results by the responseTypeCode.\n     * @param suspectedCauseCategoryCode Filter the results by the suspectedCauseCategoryCode.\n     * @param lastUpdatedAsOfTimestamp Filter the results by the lastUpdatedAsOfTimestamp.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSimpleWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, incidentStatusCode?: Array<string>, incidentTypeCode?: Array<string>, stageOfControlCode?: Array<string>, responseTypeCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, lastUpdatedAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<SimpleWildfireIncidentListResource>;\n    public getSimpleWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, incidentStatusCode?: Array<string>, incidentTypeCode?: Array<string>, stageOfControlCode?: Array<string>, responseTypeCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, lastUpdatedAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<SimpleWildfireIncidentListResource>>;\n    public getSimpleWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, incidentStatusCode?: Array<string>, incidentTypeCode?: Array<string>, stageOfControlCode?: Array<string>, responseTypeCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, lastUpdatedAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<SimpleWildfireIncidentListResource>>;\n    public getSimpleWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, incidentStatusCode?: Array<string>, incidentTypeCode?: Array<string>, stageOfControlCode?: Array<string>, responseTypeCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, lastUpdatedAsOfTimestamp?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (searchText) {\n            searchText.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'searchText');\n            })\n        }\n        if (wildfireYear) {\n            wildfireYear.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'wildfireYear');\n            })\n        }\n        if (incidentNumberSequence) {\n            incidentNumberSequence.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentNumberSequence');\n            })\n        }\n        if (fireCentreOrgUnitIdentifier) {\n            fireCentreOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireCentreOrgUnitIdentifier');\n            })\n        }\n        if (zoneOrgUnitIdentifier) {\n            zoneOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'zoneOrgUnitIdentifier');\n            })\n        }\n        if (incidentStatusCode) {\n            incidentStatusCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentStatusCode');\n            })\n        }\n        if (incidentTypeCode) {\n            incidentTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentTypeCode');\n            })\n        }\n        if (stageOfControlCode) {\n            stageOfControlCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'stageOfControlCode');\n            })\n        }\n        if (responseTypeCode) {\n            responseTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'responseTypeCode');\n            })\n        }\n        if (suspectedCauseCategoryCode) {\n            suspectedCauseCategoryCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'suspectedCauseCategoryCode');\n            })\n        }\n        if (lastUpdatedAsOfTimestamp !== undefined && lastUpdatedAsOfTimestamp !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>lastUpdatedAsOfTimestamp, 'lastUpdatedAsOfTimestamp');\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<SimpleWildfireIncidentListResource>(`${this.configuration.basePath}/simpleWildfireIncidents`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Top Level Resources.\n     * Get Top Level Resources\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTopLevel(restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<EndpointsResource>;\n    public getTopLevel(restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<EndpointsResource>>;\n    public getTopLevel(restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<EndpointsResource>>;\n    public getTopLevel(restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<EndpointsResource>(`${this.configuration.basePath}/`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Wildfire Incident by External ID.\n     * Get the Wildfire Incident by External ID.\n     * @param externalId The externalId of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfireIncident(externalId: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public getWildfireIncident(externalId: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public getWildfireIncident(externalId: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public getWildfireIncident(externalId: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (externalId === null || externalId === undefined) {\n            throw new Error('Required parameter externalId was null or undefined when calling getWildfireIncident.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/externalId/${encodeURIComponent(String(externalId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Wildfire Incident by ID.\n     * Get the Wildfire Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfireIncident1(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public getWildfireIncident1(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public getWildfireIncident1(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public getWildfireIncident1(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getWildfireIncident1.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getWildfireIncident1.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Wildfire Incident by Incident GUID.\n     * Get the Wildfire Incident by Incident GUID.\n     * @param incidentGuid The incidentGuid of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfireIncidentByIncidentGuid(incidentGuid: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public getWildfireIncidentByIncidentGuid(incidentGuid: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public getWildfireIncidentByIncidentGuid(incidentGuid: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public getWildfireIncidentByIncidentGuid(incidentGuid: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (incidentGuid === null || incidentGuid === undefined) {\n            throw new Error('Required parameter incidentGuid was null or undefined when calling getWildfireIncidentByIncidentGuid.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(incidentGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Wildfire Incidents.\n     * Get list of Wildfire Incidents.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param searchText Filter the results by the searchText.\n     * @param wildfireYear Filter the results by the wildfireYear.\n     * @param incidentNumberSequence Filter the results by the incidentNumberSequence.\n     * @param incidentId Filter the results by the incidentId.\n     * @param incidentName Filter the results by the incidentName.\n     * @param claimExpectedInd Filter the results by the claimExpectedInd.\n     * @param rehabilitationPlanRequiredInd Filter the results by the rehabilitationPlanRequiredInd.\n     * @param paperTrailedInd Filter the results by the paperTrailedInd.\n     * @param fieldPhotoInd Filter the results by the fieldPhotoInd.\n     * @param finalReportCompleteInd Filter the results by the finalReportCompleteInd.\n     * @param incidentCommanderName Filter the results by the incidentCommanderName.\n     * @param signoffSignatureInd Filter the results by the signoffSignatureInd.\n     * @param agencyAssistanceTaskIdentifier Filter the results by the agencyAssistanceTaskIdentifier.\n     * @param approvalSignatureName Filter the results by the approvalSignatureName.\n     * @param approvalSignatureInd Filter the results by the approvalSignatureInd.\n     * @param fireCentreOrgUnitIdentifier Filter the results by the fireCentreOrgUnitIdentifier.\n     * @param zoneOrgUnitIdentifier Filter the results by the zoneOrgUnitIdentifier.\n     * @param detectionSourceCode Filter the results by the detectionSourceCode.\n     * @param fireClassificationCode Filter the results by the fireClassificationCode.\n     * @param agencyAssistTypeCode Filter the results by the agencyAssistTypeCode.\n     * @param responseTypeCode Filter the results by the responseTypeCode.\n     * @param assistingPartyName Filter the results by the assistingPartyName.\n     * @param discoveredByPartyName Filter the results by the discoveredByPartyName.\n     * @param firstActionedByPartyName Filter the results by the firstActionedByPartyName.\n     * @param leadByPartyName Filter the results by the leadByPartyName.\n     * @param incidentStatusCode Filter the results by the incidentStatusCode.\n     * @param incidentNumberLabel Filter the results by the incidentNumberLabel.\n     * @param probabilityOfInitialAttackSuccessCode Filter the results by the probabilityOfInitialAttackSuccessCode.\n     * @param suspectedCauseCategoryCode Filter the results by the suspectedCauseCategoryCode.\n     * @param incidentCategoryCode Filter the results by the incidentCategoryCode.\n     * @param incidentTypeCode Filter the results by the incidentTypeCode.\n     * @param fireOfNotePublishedInd Filter the results by the fireOfNotePublishedInd.\n     * @param wasFireOfNotePublishedInd Filter the results by the wasFireOfNotePublishedInd.\n     * @param stageOfControlCode Filter the results by the stageOfControlCode.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, incidentId?: Array<string>, incidentName?: Array<string>, claimExpectedInd?: string, rehabilitationPlanRequiredInd?: string, paperTrailedInd?: string, fieldPhotoInd?: string, finalReportCompleteInd?: string, incidentCommanderName?: Array<string>, signoffSignatureInd?: string, agencyAssistanceTaskIdentifier?: Array<string>, approvalSignatureName?: Array<string>, approvalSignatureInd?: string, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, detectionSourceCode?: Array<string>, fireClassificationCode?: Array<string>, agencyAssistTypeCode?: Array<string>, responseTypeCode?: Array<string>, assistingPartyName?: Array<string>, discoveredByPartyName?: Array<string>, firstActionedByPartyName?: Array<string>, leadByPartyName?: Array<string>, incidentStatusCode?: Array<string>, incidentNumberLabel?: Array<string>, probabilityOfInitialAttackSuccessCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, incidentCategoryCode?: Array<string>, incidentTypeCode?: Array<string>, fireOfNotePublishedInd?: string, wasFireOfNotePublishedInd?: string, stageOfControlCode?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentListResource>;\n    public getWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, incidentId?: Array<string>, incidentName?: Array<string>, claimExpectedInd?: string, rehabilitationPlanRequiredInd?: string, paperTrailedInd?: string, fieldPhotoInd?: string, finalReportCompleteInd?: string, incidentCommanderName?: Array<string>, signoffSignatureInd?: string, agencyAssistanceTaskIdentifier?: Array<string>, approvalSignatureName?: Array<string>, approvalSignatureInd?: string, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, detectionSourceCode?: Array<string>, fireClassificationCode?: Array<string>, agencyAssistTypeCode?: Array<string>, responseTypeCode?: Array<string>, assistingPartyName?: Array<string>, discoveredByPartyName?: Array<string>, firstActionedByPartyName?: Array<string>, leadByPartyName?: Array<string>, incidentStatusCode?: Array<string>, incidentNumberLabel?: Array<string>, probabilityOfInitialAttackSuccessCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, incidentCategoryCode?: Array<string>, incidentTypeCode?: Array<string>, fireOfNotePublishedInd?: string, wasFireOfNotePublishedInd?: string, stageOfControlCode?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentListResource>>;\n    public getWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, incidentId?: Array<string>, incidentName?: Array<string>, claimExpectedInd?: string, rehabilitationPlanRequiredInd?: string, paperTrailedInd?: string, fieldPhotoInd?: string, finalReportCompleteInd?: string, incidentCommanderName?: Array<string>, signoffSignatureInd?: string, agencyAssistanceTaskIdentifier?: Array<string>, approvalSignatureName?: Array<string>, approvalSignatureInd?: string, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, detectionSourceCode?: Array<string>, fireClassificationCode?: Array<string>, agencyAssistTypeCode?: Array<string>, responseTypeCode?: Array<string>, assistingPartyName?: Array<string>, discoveredByPartyName?: Array<string>, firstActionedByPartyName?: Array<string>, leadByPartyName?: Array<string>, incidentStatusCode?: Array<string>, incidentNumberLabel?: Array<string>, probabilityOfInitialAttackSuccessCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, incidentCategoryCode?: Array<string>, incidentTypeCode?: Array<string>, fireOfNotePublishedInd?: string, wasFireOfNotePublishedInd?: string, stageOfControlCode?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentListResource>>;\n    public getWildfireIncidentList(restVersion?: number, searchText?: Array<string>, wildfireYear?: Array<string>, incidentNumberSequence?: Array<string>, incidentId?: Array<string>, incidentName?: Array<string>, claimExpectedInd?: string, rehabilitationPlanRequiredInd?: string, paperTrailedInd?: string, fieldPhotoInd?: string, finalReportCompleteInd?: string, incidentCommanderName?: Array<string>, signoffSignatureInd?: string, agencyAssistanceTaskIdentifier?: Array<string>, approvalSignatureName?: Array<string>, approvalSignatureInd?: string, fireCentreOrgUnitIdentifier?: Array<string>, zoneOrgUnitIdentifier?: Array<string>, detectionSourceCode?: Array<string>, fireClassificationCode?: Array<string>, agencyAssistTypeCode?: Array<string>, responseTypeCode?: Array<string>, assistingPartyName?: Array<string>, discoveredByPartyName?: Array<string>, firstActionedByPartyName?: Array<string>, leadByPartyName?: Array<string>, incidentStatusCode?: Array<string>, incidentNumberLabel?: Array<string>, probabilityOfInitialAttackSuccessCode?: Array<string>, suspectedCauseCategoryCode?: Array<string>, incidentCategoryCode?: Array<string>, incidentTypeCode?: Array<string>, fireOfNotePublishedInd?: string, wasFireOfNotePublishedInd?: string, stageOfControlCode?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (searchText) {\n            searchText.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'searchText');\n            })\n        }\n        if (wildfireYear) {\n            wildfireYear.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'wildfireYear');\n            })\n        }\n        if (incidentNumberSequence) {\n            incidentNumberSequence.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentNumberSequence');\n            })\n        }\n        if (incidentId) {\n            incidentId.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentId');\n            })\n        }\n        if (incidentName) {\n            incidentName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentName');\n            })\n        }\n        if (claimExpectedInd !== undefined && claimExpectedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>claimExpectedInd, 'claimExpectedInd');\n        }\n        if (rehabilitationPlanRequiredInd !== undefined && rehabilitationPlanRequiredInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>rehabilitationPlanRequiredInd, 'rehabilitationPlanRequiredInd');\n        }\n        if (paperTrailedInd !== undefined && paperTrailedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>paperTrailedInd, 'paperTrailedInd');\n        }\n        if (fieldPhotoInd !== undefined && fieldPhotoInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>fieldPhotoInd, 'fieldPhotoInd');\n        }\n        if (finalReportCompleteInd !== undefined && finalReportCompleteInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>finalReportCompleteInd, 'finalReportCompleteInd');\n        }\n        if (incidentCommanderName) {\n            incidentCommanderName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentCommanderName');\n            })\n        }\n        if (signoffSignatureInd !== undefined && signoffSignatureInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>signoffSignatureInd, 'signoffSignatureInd');\n        }\n        if (agencyAssistanceTaskIdentifier) {\n            agencyAssistanceTaskIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'agencyAssistanceTaskIdentifier');\n            })\n        }\n        if (approvalSignatureName) {\n            approvalSignatureName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'approvalSignatureName');\n            })\n        }\n        if (approvalSignatureInd !== undefined && approvalSignatureInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>approvalSignatureInd, 'approvalSignatureInd');\n        }\n        if (fireCentreOrgUnitIdentifier) {\n            fireCentreOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireCentreOrgUnitIdentifier');\n            })\n        }\n        if (zoneOrgUnitIdentifier) {\n            zoneOrgUnitIdentifier.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'zoneOrgUnitIdentifier');\n            })\n        }\n        if (detectionSourceCode) {\n            detectionSourceCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'detectionSourceCode');\n            })\n        }\n        if (fireClassificationCode) {\n            fireClassificationCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'fireClassificationCode');\n            })\n        }\n        if (agencyAssistTypeCode) {\n            agencyAssistTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'agencyAssistTypeCode');\n            })\n        }\n        if (responseTypeCode) {\n            responseTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'responseTypeCode');\n            })\n        }\n        if (assistingPartyName) {\n            assistingPartyName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'assistingPartyName');\n            })\n        }\n        if (discoveredByPartyName) {\n            discoveredByPartyName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'discoveredByPartyName');\n            })\n        }\n        if (firstActionedByPartyName) {\n            firstActionedByPartyName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'firstActionedByPartyName');\n            })\n        }\n        if (leadByPartyName) {\n            leadByPartyName.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'leadByPartyName');\n            })\n        }\n        if (incidentStatusCode) {\n            incidentStatusCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentStatusCode');\n            })\n        }\n        if (incidentNumberLabel) {\n            incidentNumberLabel.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentNumberLabel');\n            })\n        }\n        if (probabilityOfInitialAttackSuccessCode) {\n            probabilityOfInitialAttackSuccessCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'probabilityOfInitialAttackSuccessCode');\n            })\n        }\n        if (suspectedCauseCategoryCode) {\n            suspectedCauseCategoryCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'suspectedCauseCategoryCode');\n            })\n        }\n        if (incidentCategoryCode) {\n            incidentCategoryCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentCategoryCode');\n            })\n        }\n        if (incidentTypeCode) {\n            incidentTypeCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'incidentTypeCode');\n            })\n        }\n        if (fireOfNotePublishedInd !== undefined && fireOfNotePublishedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>fireOfNotePublishedInd, 'fireOfNotePublishedInd');\n        }\n        if (wasFireOfNotePublishedInd !== undefined && wasFireOfNotePublishedInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>wasFireOfNotePublishedInd, 'wasFireOfNotePublishedInd');\n        }\n        if (stageOfControlCode) {\n            stageOfControlCode.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'stageOfControlCode');\n            })\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<WildfireIncidentListResource>(`${this.configuration.basePath}/incidents`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Wildfire Incident Status Changes.\n     * Get list of Wildfire Incident Status Changes.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfireIncidentStatusChangeList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<StatusChangeListResource>;\n    public getWildfireIncidentStatusChangeList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<StatusChangeListResource>>;\n    public getWildfireIncidentStatusChangeList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<StatusChangeListResource>>;\n    public getWildfireIncidentStatusChangeList(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getWildfireIncidentStatusChangeList.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getWildfireIncidentStatusChangeList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<StatusChangeListResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/statusChanges`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Wildfire Party by ID.\n     * Get the Wildfire Party by ID.\n     * @param wildfirePartyGuid The identifier of the Wildfire Party resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfireParty(wildfirePartyGuid: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfirePartyResource>;\n    public getWildfireParty(wildfirePartyGuid: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfirePartyResource>>;\n    public getWildfireParty(wildfirePartyGuid: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfirePartyResource>>;\n    public getWildfireParty(wildfirePartyGuid: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfirePartyGuid === null || wildfirePartyGuid === undefined) {\n            throw new Error('Required parameter wildfirePartyGuid was null or undefined when calling getWildfireParty.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<WildfirePartyResource>(`${this.configuration.basePath}/wildfirePartys/${encodeURIComponent(String(wildfirePartyGuid))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get list of Wildfire Partys.\n     * Get list of Wildfire Partys.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param partyName Filter the results by the partyName.\n     * @param partyTypeCode Filter the results by the partyTypeCode.\n     * @param partyUsageTypeCode Filter the results by the partyUsageTypeCode.\n     * @param effectiveAsOfDate Filter the results by the effectiveAsOfDate.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param expand The level of child resources to load. Zero for no child resources.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfirePartyList(restVersion?: number, partyName?: string, partyTypeCode?: string, partyUsageTypeCode?: string, effectiveAsOfDate?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfirePartyListResource>;\n    public getWildfirePartyList(restVersion?: number, partyName?: string, partyTypeCode?: string, partyUsageTypeCode?: string, effectiveAsOfDate?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfirePartyListResource>>;\n    public getWildfirePartyList(restVersion?: number, partyName?: string, partyTypeCode?: string, partyUsageTypeCode?: string, effectiveAsOfDate?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfirePartyListResource>>;\n    public getWildfirePartyList(restVersion?: number, partyName?: string, partyTypeCode?: string, partyUsageTypeCode?: string, effectiveAsOfDate?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, expand?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (partyName !== undefined && partyName !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>partyName, 'partyName');\n        }\n        if (partyTypeCode !== undefined && partyTypeCode !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>partyTypeCode, 'partyTypeCode');\n        }\n        if (partyUsageTypeCode !== undefined && partyUsageTypeCode !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>partyUsageTypeCode, 'partyUsageTypeCode');\n        }\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n        if (expand !== undefined && expand !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>expand, 'expand');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<WildfirePartyListResource>(`${this.configuration.basePath}/wildfirePartys`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get the Wildfire Perimeter.\n     * Get the Wildfire Perimeter.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfirePerimeterResource>;\n    public getWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfirePerimeterResource>>;\n    public getWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfirePerimeterResource>>;\n    public getWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling getWildfirePerimeter.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling getWildfirePerimeter.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<WildfirePerimeterResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/wildfirePerimeter`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Query the health of the service.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param callstack A comm separated list of the identifier of the calling components.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HealthCheckResponseRsrc>;\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<HealthCheckResponseRsrc>>;\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<HealthCheckResponseRsrc>>;\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (callstack !== undefined && callstack !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>callstack, 'callstack');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<HealthCheckResponseRsrc>(`${this.configuration.basePath}/checkHealth`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Redact Incident Attachment by ID\n     * Redact Incident Attachment by ID\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param attachmentResource The Incident Attachment resource containing the new file id and path.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public redactIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public redactIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public redactIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public redactIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling redactIncidentAttachment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling redactIncidentAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling redactIncidentAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AttachmentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/attachments/${encodeURIComponent(String(attachmentGuid))}/redact`,\n            attachmentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Redact Report of Fire Attachment by ID\n     * Redact Report of Fire Attachment by ID\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param attachmentResource The ReportOfFire Attachment resource containing the new file id and path.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public redactReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public redactReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public redactReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public redactReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling redactReportOfFireAttachment.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling redactReportOfFireAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling redactReportOfFireAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<AttachmentResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/attachments/${encodeURIComponent(String(attachmentGuid))}/redact`,\n            attachmentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Review a Received Public Report Of Fire\n     * Review a Received Public Report Of Fire\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public reviewPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public reviewPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public reviewPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public reviewPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling reviewPublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling reviewPublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/review`,\n            onBehalfOfResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Signoff the Approval Results for an Incident by ID.\n     * Signoff the Approval Results for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public signoffIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public signoffIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public signoffIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public signoffIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling signoffIncidentApproval.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling signoffIncidentApproval.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/approval`,\n            null,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Signoff the Verification Results for an Incident by ID.\n     * Signoff the Verification Results for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public signoffIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public signoffIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public signoffIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public signoffIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling signoffIncidentVerification.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling signoffIncidentVerification.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/verification`,\n            null,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Submit a Public Report Of Fire\n     * Submit a Public Report Of Fire\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public submitPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public submitPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public submitPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public submitPublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling submitPublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling submitPublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/submit`,\n            onBehalfOfResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Unacknowledge a Public Report Of Fire\n     * Unacknowledge a Public Report Of Fire\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public unacknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public unacknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public unacknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public unacknowledgePublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling unacknowledgePublicReportOfFire.');\n        }\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling unacknowledgePublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling unacknowledgePublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/unacknowledge`,\n            onBehalfOfResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Unassign a Public Report Of Fire\n     * Unassign a Public Report Of Fire\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public unassignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public unassignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public unassignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public unassignPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling unassignPublicReportOfFire.');\n        }\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling unassignPublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling unassignPublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/unassign`,\n            onBehalfOfResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Uncancel a Public Report Of Fire\n     * Uncancel a Public Report Of Fire\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param onBehalfOfResource The OnBehalfOf resource containing the audit values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public uncancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public uncancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public uncancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public uncancelPublicReportOfFire(ifMatch: string, wildfireYear: string, reportOfFireNumber: string, restVersion?: number, onBehalfOfResource?: OnBehalfOfResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling uncancelPublicReportOfFire.');\n        }\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling uncancelPublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling uncancelPublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/uncancel`,\n            onBehalfOfResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Unsign the Approval Results for an Incident by ID.\n     * Unsign the Approval Results for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public unsignIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public unsignIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public unsignIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public unsignIncidentApproval(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling unsignIncidentApproval.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling unsignIncidentApproval.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/approval`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Unsign the Verification Results for an Incident by ID.\n     * Unsign the Verification Results for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public unsignIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public unsignIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public unsignIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public unsignIncidentVerification(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling unsignIncidentVerification.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling unsignIncidentVerification.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/verification`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update CodeHierarchy by code table name.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param codeHierarchyName The identifier of the CodeHierarchy resource.\n     * @param codeHierarchyRsrc The CodeHierarchy resource containing the new values.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeHierarchyRsrc>;\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeHierarchyRsrc>>;\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeHierarchyRsrc>>;\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');\n        }\n        if (codeHierarchyName === null || codeHierarchyName === undefined) {\n            throw new Error('Required parameter codeHierarchyName was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');\n        }\n        if (codeHierarchyRsrc === null || codeHierarchyRsrc === undefined) {\n            throw new Error('Required parameter codeHierarchyRsrc was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<CodeHierarchyRsrc>(`${this.configuration.basePath}/codeHierarchies/${encodeURIComponent(String(codeHierarchyName))}`,\n            codeHierarchyRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update CodeTable by code table name.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param codeTableName The identifier of the CodeTable resource.\n     * @param codeTableRsrc The CodeTable resource containing the new values.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeTableRsrc>;\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeTableRsrc>>;\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeTableRsrc>>;\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeTableResourceByCodeTableName.');\n        }\n        if (codeTableName === null || codeTableName === undefined) {\n            throw new Error('Required parameter codeTableName was null or undefined when calling updateCodeTableResourceByCodeTableName.');\n        }\n        if (codeTableRsrc === null || codeTableRsrc === undefined) {\n            throw new Error('Required parameter codeTableRsrc was null or undefined when calling updateCodeTableResourceByCodeTableName.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<CodeTableRsrc>(`${this.configuration.basePath}/codeTables/${encodeURIComponent(String(codeTableName))}`,\n            codeTableRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an Incidents Compliance And Enforcement Investigation\n     * Update an Incidents Compliance And Enforcement Investigation\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param complianceAndEnforcementInvestigationResource The IncidentInvestigation resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, complianceAndEnforcementInvestigationResource?: ComplianceAndEnforcementInvestigationResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ComplianceAndEnforcementInvestigationResource>;\n    public updateComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, complianceAndEnforcementInvestigationResource?: ComplianceAndEnforcementInvestigationResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ComplianceAndEnforcementInvestigationResource>>;\n    public updateComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, complianceAndEnforcementInvestigationResource?: ComplianceAndEnforcementInvestigationResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ComplianceAndEnforcementInvestigationResource>>;\n    public updateComplianceAndEnforcementInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, complianceAndEnforcementInvestigationResource?: ComplianceAndEnforcementInvestigationResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateComplianceAndEnforcementInvestigation.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling updateComplianceAndEnforcementInvestigation.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ComplianceAndEnforcementInvestigationResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/complianceAndEnforcementInvestigation`,\n            complianceAndEnforcementInvestigationResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param externalUriGuid \n     * @param externalUriResource \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateExternalUri(externalUriGuid: string, externalUriResource?: ExternalUriResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public updateExternalUri(externalUriGuid: string, externalUriResource?: ExternalUriResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public updateExternalUri(externalUriGuid: string, externalUriResource?: ExternalUriResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public updateExternalUri(externalUriGuid: string, externalUriResource?: ExternalUriResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (externalUriGuid === null || externalUriGuid === undefined) {\n            throw new Error('Required parameter externalUriGuid was null or undefined when calling updateExternalUri.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<any>(`${this.configuration.basePath}/externalUri/${encodeURIComponent(String(externalUriGuid))}`,\n            externalUriResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update Incident Attachment by ID\n     * Update Incident Attachment by ID\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param attachmentResource The Incident Attachment resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public updateIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public updateIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public updateIncidentAttachment(wildfireYear: string, incidentNumberSequence: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateIncidentAttachment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling updateIncidentAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling updateIncidentAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<AttachmentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/attachments/${encodeURIComponent(String(attachmentGuid))}`,\n            attachmentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update InitialFireReport resource by ID\n     * Update InitialFireReport by ID\n     * @param initialFireReportId The initialFireReportId of the Initial Fire Report resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param initialFireReportResource The InitialFireReport resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, initialFireReportResource?: InitialFireReportResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<InitialFireReportResource>;\n    public updateInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, initialFireReportResource?: InitialFireReportResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<InitialFireReportResource>>;\n    public updateInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, initialFireReportResource?: InitialFireReportResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<InitialFireReportResource>>;\n    public updateInitialFireReport(initialFireReportId: string, restVersion?: number, ifMatch?: string, initialFireReportResource?: InitialFireReportResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (initialFireReportId === null || initialFireReportId === undefined) {\n            throw new Error('Required parameter initialFireReportId was null or undefined when calling updateInitialFireReport.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<InitialFireReportResource>(`${this.configuration.basePath}/initialFireReports/${encodeURIComponent(String(initialFireReportId))}`,\n            initialFireReportResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an Incidents Managing Land Authority\n     * Update an Incidents Managing Land Authority\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param incidentLandAuthorityResource The IncidentLandAuthority resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, incidentLandAuthorityResource?: IncidentLandAuthorityResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<IncidentLandAuthorityResource>;\n    public updateManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, incidentLandAuthorityResource?: IncidentLandAuthorityResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<IncidentLandAuthorityResource>>;\n    public updateManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, incidentLandAuthorityResource?: IncidentLandAuthorityResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<IncidentLandAuthorityResource>>;\n    public updateManagingLandAuthority(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, incidentLandAuthorityResource?: IncidentLandAuthorityResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateManagingLandAuthority.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling updateManagingLandAuthority.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<IncidentLandAuthorityResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/managingLandAuthority`,\n            incidentLandAuthorityResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an Incidents Compliance And Enforcement Investigation\n     * Update an Incidents Compliance And Enforcement Investigation\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param originAndCauseInvestigationResource The IncidentInvestigation resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, originAndCauseInvestigationResource?: OriginAndCauseInvestigationResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<OriginAndCauseInvestigationResource>;\n    public updateOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, originAndCauseInvestigationResource?: OriginAndCauseInvestigationResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<OriginAndCauseInvestigationResource>>;\n    public updateOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, originAndCauseInvestigationResource?: OriginAndCauseInvestigationResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<OriginAndCauseInvestigationResource>>;\n    public updateOriginAndCauseInvestigation(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, originAndCauseInvestigationResource?: OriginAndCauseInvestigationResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateOriginAndCauseInvestigation.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling updateOriginAndCauseInvestigation.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<OriginAndCauseInvestigationResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/originAndCauseInvestigation`,\n            originAndCauseInvestigationResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update Provisional Zone resource by ID\n     * Update ProvisionalZone by ID\n     * @param provisionalZoneGuid The identifier of the ProvisionalZone resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param provisionalZoneResource The ProvisionalZone resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, provisionalZoneResource?: ProvisionalZoneResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ProvisionalZoneResource>;\n    public updateProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, provisionalZoneResource?: ProvisionalZoneResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ProvisionalZoneResource>>;\n    public updateProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, provisionalZoneResource?: ProvisionalZoneResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ProvisionalZoneResource>>;\n    public updateProvisionalZone(provisionalZoneGuid: string, restVersion?: number, ifMatch?: string, provisionalZoneResource?: ProvisionalZoneResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (provisionalZoneGuid === null || provisionalZoneGuid === undefined) {\n            throw new Error('Required parameter provisionalZoneGuid was null or undefined when calling updateProvisionalZone.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ProvisionalZoneResource>(`${this.configuration.basePath}/provisionalZones/${encodeURIComponent(String(provisionalZoneGuid))}`,\n            provisionalZoneResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update PublicReportOfFire resource by ID\n     * Update PublicReportOfFire by ID\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param publicReportOfFireResource The PublicReportOfFire resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, publicReportOfFireResource?: PublicReportOfFireResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<PublicReportOfFireResource>;\n    public updatePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, publicReportOfFireResource?: PublicReportOfFireResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<PublicReportOfFireResource>>;\n    public updatePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, publicReportOfFireResource?: PublicReportOfFireResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<PublicReportOfFireResource>>;\n    public updatePublicReportOfFire(wildfireYear: string, reportOfFireNumber: string, restVersion?: number, ifMatch?: string, publicReportOfFireResource?: PublicReportOfFireResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updatePublicReportOfFire.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling updatePublicReportOfFire.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<PublicReportOfFireResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}`,\n            publicReportOfFireResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param publishedIncidentDetailGuid \n     * @param publishedIncidentResource \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePublishedIncident(publishedIncidentDetailGuid: string, publishedIncidentResource?: PublishedIncidentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any>;\n    public updatePublishedIncident(publishedIncidentDetailGuid: string, publishedIncidentResource?: PublishedIncidentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<any>>;\n    public updatePublishedIncident(publishedIncidentDetailGuid: string, publishedIncidentResource?: PublishedIncidentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<any>>;\n    public updatePublishedIncident(publishedIncidentDetailGuid: string, publishedIncidentResource?: PublishedIncidentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (publishedIncidentDetailGuid === null || publishedIncidentDetailGuid === undefined) {\n            throw new Error('Required parameter publishedIncidentDetailGuid was null or undefined when calling updatePublishedIncident.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<any>(`${this.configuration.basePath}/publishedIncidents/${encodeURIComponent(String(publishedIncidentDetailGuid))}`,\n            publishedIncidentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update Report of Fire Attachment by ID\n     * Update Report of Fire Attachment by ID\n     * @param wildfireYear The wildfireYear of the Public Report of Fire resource.\n     * @param reportOfFireNumber The reportOfFireNumber of the Public Report of Fire resource.\n     * @param attachmentGuid The attachmentGuid of the Attachment resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param attachmentResource The ReportOfFire Attachment resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<AttachmentResource>;\n    public updateReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<AttachmentResource>>;\n    public updateReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<AttachmentResource>>;\n    public updateReportOfFireAttachment(wildfireYear: string, reportOfFireNumber: string, attachmentGuid: string, restVersion?: number, attachmentResource?: AttachmentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateReportOfFireAttachment.');\n        }\n        if (reportOfFireNumber === null || reportOfFireNumber === undefined) {\n            throw new Error('Required parameter reportOfFireNumber was null or undefined when calling updateReportOfFireAttachment.');\n        }\n        if (attachmentGuid === null || attachmentGuid === undefined) {\n            throw new Error('Required parameter attachmentGuid was null or undefined when calling updateReportOfFireAttachment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<AttachmentResource>(`${this.configuration.basePath}/publicReportOfFires/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(reportOfFireNumber))}/attachments/${encodeURIComponent(String(attachmentGuid))}`,\n            attachmentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update the Resource Allocation Assessment for an Incident by ID.\n     * Update the Resource Allocation Assessment for an Incident by ID.\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param resourceAllocationAssessmentResource The ResourceAllocationAssessment resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, resourceAllocationAssessmentResource?: ResourceAllocationAssessmentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<ResourceAllocationAssessmentResource>;\n    public updateResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, resourceAllocationAssessmentResource?: ResourceAllocationAssessmentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<ResourceAllocationAssessmentResource>>;\n    public updateResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, resourceAllocationAssessmentResource?: ResourceAllocationAssessmentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<ResourceAllocationAssessmentResource>>;\n    public updateResourceAllocationAssessment(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, resourceAllocationAssessmentResource?: ResourceAllocationAssessmentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateResourceAllocationAssessment.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling updateResourceAllocationAssessment.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<ResourceAllocationAssessmentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/resourceAllocationAssessment`,\n            resourceAllocationAssessmentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update WildfireIncident resource by ID\n     * Update WildfireIncident by ID\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfireIncidentResource The WildfireIncident resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfireIncidentResource?: WildfireIncidentResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfireIncidentResource>;\n    public updateWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfireIncidentResource?: WildfireIncidentResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfireIncidentResource>>;\n    public updateWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfireIncidentResource?: WildfireIncidentResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfireIncidentResource>>;\n    public updateWildfireIncident(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfireIncidentResource?: WildfireIncidentResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateWildfireIncident.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling updateWildfireIncident.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<WildfireIncidentResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}`,\n            wildfireIncidentResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update WildfireParty resource by ID\n     * Update WildfireParty by ID\n     * @param wildfirePartyGuid The identifier of the WildfireParty resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfirePartyResource The WildfireParty resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, wildfirePartyResource?: WildfirePartyResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfirePartyResource>;\n    public updateWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, wildfirePartyResource?: WildfirePartyResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfirePartyResource>>;\n    public updateWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, wildfirePartyResource?: WildfirePartyResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfirePartyResource>>;\n    public updateWildfireParty(wildfirePartyGuid: string, restVersion?: number, ifMatch?: string, wildfirePartyResource?: WildfirePartyResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfirePartyGuid === null || wildfirePartyGuid === undefined) {\n            throw new Error('Required parameter wildfirePartyGuid was null or undefined when calling updateWildfireParty.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<WildfirePartyResource>(`${this.configuration.basePath}/wildfirePartys/${encodeURIComponent(String(wildfirePartyGuid))}`,\n            wildfirePartyResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update WildfirePerimeter resource\n     * Update WildfirePerimeter\n     * @param wildfireYear The wildfireYear of the Wildfire Incident resource.\n     * @param incidentNumberSequence The incidentNumberSequence of the Wildfire Incident resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param wildfirePerimeterResource The WildfirePerimeter resource containing the new values.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfirePerimeterResource?: WildfirePerimeterResource, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<WildfirePerimeterResource>;\n    public updateWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfirePerimeterResource?: WildfirePerimeterResource, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<WildfirePerimeterResource>>;\n    public updateWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfirePerimeterResource?: WildfirePerimeterResource, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<WildfirePerimeterResource>>;\n    public updateWildfirePerimeter(wildfireYear: string, incidentNumberSequence: string, restVersion?: number, ifMatch?: string, wildfirePerimeterResource?: WildfirePerimeterResource, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (wildfireYear === null || wildfireYear === undefined) {\n            throw new Error('Required parameter wildfireYear was null or undefined when calling updateWildfirePerimeter.');\n        }\n        if (incidentNumberSequence === null || incidentNumberSequence === undefined) {\n            throw new Error('Required parameter incidentNumberSequence was null or undefined when calling updateWildfirePerimeter.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<WildfirePerimeterResource>(`${this.configuration.basePath}/incidents/${encodeURIComponent(String(wildfireYear))}/${encodeURIComponent(String(incidentNumberSequence))}/wildfirePerimeter`,\n            wildfirePerimeterResource,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","export * from './default.service';\nimport { DefaultService } from './default.service';\nexport const APIS = [DefaultService];\n","/**\n * WFIM Incident Manager API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.8.0-SNAPSHOT\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface HealthCheckResponseRsrc { \n    componentIdentifier?: string;\n    componentName?: string;\n    validationStatus?: HealthCheckResponseRsrc.ValidationStatusEnum;\n    statusDetails?: string;\n    dependencyComponentResponses?: Array<HealthCheckResponseRsrc>;\n    type: string;\n}\nexport namespace HealthCheckResponseRsrc {\n    export type ValidationStatusEnum = 'RED' | 'YELLOW' | 'GREEN';\n    export const ValidationStatusEnum = {\n        RED: 'RED' as ValidationStatusEnum,\n        YELLOW: 'YELLOW' as ValidationStatusEnum,\n        GREEN: 'GREEN' as ValidationStatusEnum\n    };\n}\n\n\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\n\nimport { DefaultService } from './api/default.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: []\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n"]}