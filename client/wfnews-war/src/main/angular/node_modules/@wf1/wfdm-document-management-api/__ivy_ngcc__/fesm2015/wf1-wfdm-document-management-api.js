import { InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, NgModule, SkipSelf } from '@angular/core';
import { HttpHeaders, HttpParams, HttpClient } from '@angular/common/http';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Custom HttpParameterCodec
 * Workaround for https://github.com/angular/angular/issues/18261
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common/http';
class CustomHttpParameterCodec {
    /**
     * @param {?} k
     * @return {?}
     */
    encodeKey(k) {
        return encodeURIComponent(k);
    }
    /**
     * @param {?} v
     * @return {?}
     */
    encodeValue(v) {
        return encodeURIComponent(v);
    }
    /**
     * @param {?} k
     * @return {?}
     */
    decodeKey(k) {
        return decodeURIComponent(k);
    }
    /**
     * @param {?} v
     * @return {?}
     */
    decodeValue(v) {
        return decodeURIComponent(v);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const BASE_PATH = new InjectionToken('basePath');
/** @type {?} */
const COLLECTION_FORMATS = {
    'csv': ',',
    'tsv': '   ',
    'ssv': ' ',
    'pipes': '|'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ConfigurationParameters() { }
if (false) {
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.apiKeys;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.username;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.password;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.accessToken;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.basePath;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.withCredentials;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.encoder;
}
class Configuration {
    /**
     * @param {?=} configurationParameters
     */
    constructor(configurationParameters = {}) {
        this.apiKeys = configurationParameters.apiKeys;
        this.username = configurationParameters.username;
        this.password = configurationParameters.password;
        this.accessToken = configurationParameters.accessToken;
        this.basePath = configurationParameters.basePath;
        this.withCredentials = configurationParameters.withCredentials;
        this.encoder = configurationParameters.encoder;
    }
    /**
     * Select the correct content-type to use for a request.
     * Uses {\@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param {?} contentTypes - the array of content types that are available for selection
     * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderContentType(contentTypes) {
        if (contentTypes.length === 0) {
            return undefined;
        }
        /** @type {?} */
        const type = contentTypes.find((x) => this.isJsonMime(x));
        if (type === undefined) {
            return contentTypes[0];
        }
        return type;
    }
    /**
     * Select the correct accept content-type to use for a request.
     * Uses {\@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param {?} accepts - the array of content types that are available for selection.
     * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderAccept(accepts) {
        if (accepts.length === 0) {
            return undefined;
        }
        /** @type {?} */
        const type = accepts.find((x) => this.isJsonMime(x));
        if (type === undefined) {
            return accepts[0];
        }
        return type;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param {?} mime - MIME (Multipurpose Internet Mail Extensions)
     * @return {?} True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        /** @type {?} */
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
if (false) {
    /** @type {?} */
    Configuration.prototype.apiKeys;
    /** @type {?} */
    Configuration.prototype.username;
    /** @type {?} */
    Configuration.prototype.password;
    /** @type {?} */
    Configuration.prototype.accessToken;
    /** @type {?} */
    Configuration.prototype.basePath;
    /** @type {?} */
    Configuration.prototype.withCredentials;
    /** @type {?} */
    Configuration.prototype.encoder;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class DefaultService {
    /**
     * @param {?} httpClient
     * @param {?} basePath
     * @param {?} configuration
     */
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    /**
     * @param {?} consumes string[] mime-types
     * @return {?} true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        /** @type {?} */
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    /**
     * @param {?} httpParams
     * @param {?} value
     * @param {?=} key
     * @return {?}
     */
    addToHttpParams(httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }
    /**
     * @param {?} httpParams
     * @param {?=} value
     * @param {?=} key
     * @return {?}
     */
    addToHttpParamsRecursive(httpParams, value, key) {
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                ((/** @type {?} */ (value))).forEach(elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, ((/** @type {?} */ (value))).toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(k => httpParams = this.addToHttpParamsRecursive(httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }
    /**
     * @param {?} documentId
     * @param {?} fileCheckoutRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    addDocumentCheckout(documentId, fileCheckoutRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling addDocumentCheckout.');
        }
        if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {
            throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling addDocumentCheckout.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout`, fileCheckoutRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} requestBody
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    addFilesToLock(ifMatch, lockId, requestBody, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling addFilesToLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling addFilesToLock.');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new Error('Required parameter requestBody was null or undefined when calling addFilesToLock.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}/addFile`, requestBody, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} lockRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    addLock(lockRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (lockRsrc === null || lockRsrc === undefined) {
            throw new Error('Required parameter lockRsrc was null or undefined when calling addLock.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/lock`, lockRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} targetFilePath
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    copyDocument(ifMatch, documentId, restVersion, targetFilePath, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling copyDocument.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling copyDocument.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (targetFilePath !== undefined && targetFilePath !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (targetFilePath)), 'targetFilePath');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/copy`, null, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} recursiveInd
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    deleteDocumentByDocumentID(ifMatch, documentId, restVersion, recursiveInd, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentByDocumentID.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentByDocumentID.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (recursiveInd !== undefined && recursiveInd !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursiveInd)), 'recursiveInd');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.delete(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    deleteDocumentCheckout(ifMatch, documentId, documentCheckoutId, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentCheckout.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentCheckout.');
        }
        if (documentCheckoutId === null || documentCheckoutId === undefined) {
            throw new Error('Required parameter documentCheckoutId was null or undefined when calling deleteDocumentCheckout.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.delete(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout/${encodeURIComponent(String(documentCheckoutId))}`, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    deleteLock(ifMatch, lockId, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling deleteLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling deleteLock.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.delete(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}`, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} codeHierarchyName
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getCodeHierarchyListResource(requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, codeHierarchyName, observe = 'body', reportProgress = false, options) {
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        if (codeHierarchyName !== undefined && codeHierarchyName !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (codeHierarchyName)), 'codeHierarchyName');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/codeHierarchies`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} codeHierarchyName
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getCodeHierarchyResourceByCodeTableName(codeHierarchyName, requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, observe = 'body', reportProgress = false, options) {
        if (codeHierarchyName === null || codeHierarchyName === undefined) {
            throw new Error('Required parameter codeHierarchyName was null or undefined when calling getCodeHierarchyResourceByCodeTableName.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/codeHierarchies/${encodeURIComponent(String(codeHierarchyName))}`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} codeTableName
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getCodeTableListResource(requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, codeTableName, observe = 'body', reportProgress = false, options) {
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        if (codeTableName !== undefined && codeTableName !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (codeTableName)), 'codeTableName');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/codeTables`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} codeTableName
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getCodeTableResourceByCodeTableName(codeTableName, requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, observe = 'body', reportProgress = false, options) {
        if (codeTableName === null || codeTableName === undefined) {
            throw new Error('Required parameter codeTableName was null or undefined when calling getCodeTableResourceByCodeTableName.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/codeTables/${encodeURIComponent(String(codeTableName))}`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getDocumentById(documentId, restVersion, cacheControl, observe = 'body', reportProgress = false, options) {
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentById.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}`, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getDocumentCheckout(documentId, documentCheckoutId, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckout.');
        }
        if (documentCheckoutId === null || documentCheckoutId === undefined) {
            throw new Error('Required parameter documentCheckoutId was null or undefined when calling getDocumentCheckout.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout/${encodeURIComponent(String(documentCheckoutId))}`, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} documentId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getDocumentCheckoutList(documentId, requestId, restVersion, cacheControl, pragma, authorization, pageNumber, pageRowCount, orderBy, observe = 'body', reportProgress = false, options) {
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckoutList.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} versionNumber
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getDocumentFileBytesById(documentId, restVersion, versionNumber, observe = 'body', reportProgress = false, options) {
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentFileBytesById.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (versionNumber !== undefined && versionNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (versionNumber)), 'versionNumber');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/bytes`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} parentId
     * @param {?=} recursive
     * @param {?=} lockId
     * @param {?=} metadata
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getDocumentList(requestId, restVersion, cacheControl, pragma, authorization, parentId, recursive, lockId, metadata, pageNumber, pageRowCount, orderBy, observe = 'body', reportProgress = false, options) {
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (parentId !== undefined && parentId !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (parentId)), 'parentId');
        }
        if (recursive !== undefined && recursive !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursive)), 'recursive');
        }
        if (lockId !== undefined && lockId !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (lockId)), 'lockId');
        }
        if (metadata) {
            metadata.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (element)), 'metadata');
            });
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/documents`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} documentId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getDocumentLock(documentId, requestId, restVersion, cacheControl, pragma, authorization, pageNumber, pageRowCount, orderBy, observe = 'body', reportProgress = false, options) {
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentLock.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/fileLock`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} searchText
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getListOfLocks(requestId, restVersion, cacheControl, pragma, authorization, searchText, pageNumber, pageRowCount, orderBy, observe = 'body', reportProgress = false, options) {
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (searchText) {
            searchText.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (element)), 'searchText');
            });
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/lock`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} lockId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getLock(lockId, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling getLock.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}`, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getSwaggerDocument(requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/openapi.json`, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    getTopLevelResources(requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/`, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} newFilePath
     * @param {?=} recursiveInd
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    moveDocument(ifMatch, documentId, restVersion, newFilePath, recursiveInd, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling moveDocument.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling moveDocument.');
        }
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (newFilePath !== undefined && newFilePath !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (newFilePath)), 'newFilePath');
        }
        if (recursiveInd !== undefined && recursiveInd !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursiveInd)), 'recursiveInd');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/move`, null, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} callstack
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    queryTheHealthOfTheService(requestId, restVersion, cacheControl, pragma, authorization, callstack, observe = 'body', reportProgress = false, options) {
        /** @type {?} */
        let queryParameters = new HttpParams({ encoder: this.encoder });
        if (callstack !== undefined && callstack !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (callstack)), 'callstack');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(`${this.configuration.basePath}/checkHealth`, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} body
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    removeFileFromLock(ifMatch, lockId, body, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling removeFileFromLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling removeFileFromLock.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling removeFileFromLock.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}/removeFile`, body, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} codeHierarchyName
     * @param {?} codeHierarchyRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    updateCodeHierarchyResourceByCodeTableName(ifMatch, codeHierarchyName, codeHierarchyRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
        }
        if (codeHierarchyName === null || codeHierarchyName === undefined) {
            throw new Error('Required parameter codeHierarchyName was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
        }
        if (codeHierarchyRsrc === null || codeHierarchyRsrc === undefined) {
            throw new Error('Required parameter codeHierarchyRsrc was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/codeHierarchies/${encodeURIComponent(String(codeHierarchyName))}`, codeHierarchyRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} codeTableName
     * @param {?} codeTableRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    updateCodeTableResourceByCodeTableName(ifMatch, codeTableName, codeTableRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeTableResourceByCodeTableName.');
        }
        if (codeTableName === null || codeTableName === undefined) {
            throw new Error('Required parameter codeTableName was null or undefined when calling updateCodeTableResourceByCodeTableName.');
        }
        if (codeTableRsrc === null || codeTableRsrc === undefined) {
            throw new Error('Required parameter codeTableRsrc was null or undefined when calling updateCodeTableResourceByCodeTableName.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/codeTables/${encodeURIComponent(String(codeTableName))}`, codeTableRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} resource
     * @param {?=} restVersion
     * @param {?=} file
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    updateDocument1(ifMatch, documentId, resource, restVersion, file, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateDocument1.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling updateDocument1.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling updateDocument1.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'multipart/form-data'
        ];
        /** @type {?} */
        const canConsumeForm = this.canConsumeForm(consumes);
        /** @type {?} */
        let formParams;
        /** @type {?} */
        let useForm = false;
        /** @type {?} */
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: this.encoder });
        }
        if (resource !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], { type: 'application/json' }) : (/** @type {?} */ (resource))))) || formParams;
        }
        if (file !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('file', useForm ? new Blob([JSON.stringify(file)], { type: 'application/json' }) : (/** @type {?} */ (file))))) || formParams;
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}`, convertFormParamsToString ? formParams.toString() : formParams, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?} fileCheckoutRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    updateDocumentCheckout(ifMatch, documentId, documentCheckoutId, fileCheckoutRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateDocumentCheckout.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling updateDocumentCheckout.');
        }
        if (documentCheckoutId === null || documentCheckoutId === undefined) {
            throw new Error('Required parameter documentCheckoutId was null or undefined when calling updateDocumentCheckout.');
        }
        if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {
            throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling updateDocumentCheckout.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout/${encodeURIComponent(String(documentCheckoutId))}`, fileCheckoutRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} lockRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    updateLock(ifMatch, lockId, lockRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe = 'body', reportProgress = false, options) {
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling updateLock.');
        }
        if (lockRsrc === null || lockRsrc === undefined) {
            throw new Error('Required parameter lockRsrc was null or undefined when calling updateLock.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}`, lockRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    /**
     * @param {?} resource
     * @param {?=} restVersion
     * @param {?=} file
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    uploadDocument(resource, restVersion, file, observe = 'body', reportProgress = false, options) {
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling uploadDocument.');
        }
        /** @type {?} */
        let headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        /** @type {?} */
        let httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            const httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        const consumes = [
            'multipart/form-data'
        ];
        /** @type {?} */
        const canConsumeForm = this.canConsumeForm(consumes);
        /** @type {?} */
        let formParams;
        /** @type {?} */
        let useForm = false;
        /** @type {?} */
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: this.encoder });
        }
        if (resource !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], { type: 'application/json' }) : (/** @type {?} */ (resource))))) || formParams;
        }
        if (file !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('file', useForm ? new Blob([JSON.stringify(file)], { type: 'application/json' }) : (/** @type {?} */ (file))))) || formParams;
        }
        /** @type {?} */
        let responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(`${this.configuration.basePath}/documents`, convertFormParamsToString ? formParams.toString() : formParams, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
}
DefaultService.ɵfac = function DefaultService_Factory(t) { return new (t || DefaultService)(ɵngcc0.ɵɵinject(ɵngcc1.HttpClient), ɵngcc0.ɵɵinject(BASE_PATH, 8), ɵngcc0.ɵɵinject(Configuration, 8)); };
/** @nocollapse */
DefaultService.ctorParameters = () => [
    { type: HttpClient },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
    { type: Configuration, decorators: [{ type: Optional }] }
];
/** @nocollapse */ DefaultService.ɵprov = ɵɵdefineInjectable({ factory: function DefaultService_Factory() { return new DefaultService(ɵɵinject(HttpClient), ɵɵinject(BASE_PATH, 8), ɵɵinject(Configuration, 8)); }, token: DefaultService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DefaultService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.HttpClient }, { type: String, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [BASE_PATH]
            }] }, { type: Configuration, decorators: [{
                type: Optional
            }] }]; }, null); })();
if (false) {
    /** @type {?} */
    DefaultService.prototype.basePath;
    /** @type {?} */
    DefaultService.prototype.defaultHeaders;
    /** @type {?} */
    DefaultService.prototype.configuration;
    /** @type {?} */
    DefaultService.prototype.encoder;
    /** @type {?} */
    DefaultService.prototype.httpClient;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
const APIS = [DefaultService];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function BodyPart() { }
if (false) {
    /** @type {?|undefined} */
    BodyPart.prototype.contentDisposition;
    /** @type {?|undefined} */
    BodyPart.prototype.entity;
    /** @type {?|undefined} */
    BodyPart.prototype.headers;
    /** @type {?|undefined} */
    BodyPart.prototype.mediaType;
    /** @type {?|undefined} */
    BodyPart.prototype.messageBodyWorkers;
    /** @type {?|undefined} */
    BodyPart.prototype.parent;
    /** @type {?|undefined} */
    BodyPart.prototype.providers;
    /** @type {?|undefined} */
    BodyPart.prototype.parameterizedHeaders;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function BodyPartMediaType() { }
if (false) {
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.type;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.subtype;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.parameters;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.wildcardType;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.wildcardSubtype;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeHierarchyListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeHierarchyListRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeHierarchyListRsrc.prototype.codeHierarchyList;
    /** @type {?|undefined} */
    CodeHierarchyListRsrc.prototype.etag;
    /** @type {?} */
    CodeHierarchyListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeHierarchyRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.codeHierarchyName;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.lowerCodeTableName;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.upperCodeTableName;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.hierarchy;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.etag;
    /** @type {?} */
    CodeHierarchyRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function CodeRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeRsrc.prototype.code;
    /** @type {?|undefined} */
    CodeRsrc.prototype.description;
    /** @type {?|undefined} */
    CodeRsrc.prototype.displayOrder;
    /** @type {?|undefined} */
    CodeRsrc.prototype.effectiveDate;
    /** @type {?|undefined} */
    CodeRsrc.prototype.expiryDate;
    /** @type {?} */
    CodeRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeTableListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeTableListRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeTableListRsrc.prototype.codeTableList;
    /** @type {?|undefined} */
    CodeTableListRsrc.prototype.etag;
    /** @type {?} */
    CodeTableListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeTableRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.codeTableName;
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.codes;
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.etag;
    /** @type {?} */
    CodeTableRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function ContentDisposition() { }
if (false) {
    /** @type {?|undefined} */
    ContentDisposition.prototype.type;
    /** @type {?|undefined} */
    ContentDisposition.prototype.parameters;
    /** @type {?|undefined} */
    ContentDisposition.prototype.fileName;
    /** @type {?|undefined} */
    ContentDisposition.prototype.creationDate;
    /** @type {?|undefined} */
    ContentDisposition.prototype.modificationDate;
    /** @type {?|undefined} */
    ContentDisposition.prototype.readDate;
    /** @type {?|undefined} */
    ContentDisposition.prototype.size;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function EndpointsRsrc() { }
if (false) {
    /** @type {?|undefined} */
    EndpointsRsrc.prototype.links;
    /** @type {?|undefined} */
    EndpointsRsrc.prototype.releaseVersion;
    /** @type {?|undefined} */
    EndpointsRsrc.prototype.etag;
    /** @type {?} */
    EndpointsRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileCheckoutRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.links;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.fileCheckoutId;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.file;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.checkOutComment;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.checkInComment;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.validStartTimestamp;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.validEndTimestamp;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.displayLabel;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.etag;
    /** @type {?} */
    FileCheckoutRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileDetailsRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.links;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileId;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.filePath;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lastUpdatedTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.versionNumber;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileExtension;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileType;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.mimeType;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileSize;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.retention;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.security;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.metadata;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.versions;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.uploadedBy;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.uploadedOnTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lastUpdatedBy;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lastUpdatedByGuid;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.parent;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.validStartTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.validEndTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileCheckout;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lockedInd;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.etag;
    /** @type {?} */
    FileDetailsRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileListRsrc.prototype.links;
    /** @type {?|undefined} */
    FileListRsrc.prototype.pageNumber;
    /** @type {?|undefined} */
    FileListRsrc.prototype.pageRowCount;
    /** @type {?|undefined} */
    FileListRsrc.prototype.totalRowCount;
    /** @type {?|undefined} */
    FileListRsrc.prototype.totalPageCount;
    /** @type {?|undefined} */
    FileListRsrc.prototype.collection;
    /** @type {?|undefined} */
    FileListRsrc.prototype.etag;
    /** @type {?} */
    FileListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function FileMetadataRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileMetadataRsrc.prototype.metadataName;
    /** @type {?|undefined} */
    FileMetadataRsrc.prototype.metadataValue;
    /** @type {?|undefined} */
    FileMetadataRsrc.prototype.etag;
    /** @type {?} */
    FileMetadataRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileRsrc.prototype.links;
    /** @type {?|undefined} */
    FileRsrc.prototype.fileId;
    /** @type {?|undefined} */
    FileRsrc.prototype.filePath;
    /** @type {?|undefined} */
    FileRsrc.prototype.lastUpdatedTimestamp;
    /** @type {?|undefined} */
    FileRsrc.prototype.etag;
    /** @type {?} */
    FileRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileSecurityRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.grantorAccessInd;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.readAccessInd;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.writeAccessInd;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.etag;
    /** @type {?} */
    FileSecurityRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function FileVersionRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.versionNumber;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.fileSize;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.uploadedById;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.uploadedOnTimestamp;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.etag;
    /** @type {?} */
    FileVersionRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FormDataBodyPart() { }
if (false) {
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.contentDisposition;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.entity;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.headers;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.mediaType;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.messageBodyWorkers;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.parent;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.providers;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.simple;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.formDataContentDisposition;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.name;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.value;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.parameterizedHeaders;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function FormDataContentDisposition() { }
if (false) {
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.type;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.parameters;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.fileName;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.creationDate;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.modificationDate;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.readDate;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.size;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.name;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// WARNING: interface has both a type and a value, skipping emit
var HealthCheckResponseRsrc;
(function (HealthCheckResponseRsrc) {
    HealthCheckResponseRsrc.ValidationStatusEnum = {
        RED: (/** @type {?} */ ('RED')),
        YELLOW: (/** @type {?} */ ('YELLOW')),
        GREEN: (/** @type {?} */ ('GREEN'))
    };
})(HealthCheckResponseRsrc || (HealthCheckResponseRsrc = {}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function Hierarchy() { }
if (false) {
    /** @type {?|undefined} */
    Hierarchy.prototype.lowerCode;
    /** @type {?|undefined} */
    Hierarchy.prototype.upperCode;
    /** @type {?|undefined} */
    Hierarchy.prototype.effectiveDate;
    /** @type {?|undefined} */
    Hierarchy.prototype.expiryDate;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function InlineObject() { }
if (false) {
    /** @type {?} */
    InlineObject.prototype.resource;
    /** @type {?|undefined} */
    InlineObject.prototype.file;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function InlineObject1() { }
if (false) {
    /** @type {?} */
    InlineObject1.prototype.resource;
    /** @type {?|undefined} */
    InlineObject1.prototype.file;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function LockListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    LockListRsrc.prototype.links;
    /** @type {?|undefined} */
    LockListRsrc.prototype.pageNumber;
    /** @type {?|undefined} */
    LockListRsrc.prototype.pageRowCount;
    /** @type {?|undefined} */
    LockListRsrc.prototype.totalRowCount;
    /** @type {?|undefined} */
    LockListRsrc.prototype.totalPageCount;
    /** @type {?|undefined} */
    LockListRsrc.prototype.collection;
    /** @type {?|undefined} */
    LockListRsrc.prototype.etag;
    /** @type {?} */
    LockListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function LockRsrc() { }
if (false) {
    /** @type {?|undefined} */
    LockRsrc.prototype.links;
    /** @type {?|undefined} */
    LockRsrc.prototype.lockId;
    /** @type {?|undefined} */
    LockRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    LockRsrc.prototype.lockReason;
    /** @type {?|undefined} */
    LockRsrc.prototype.validStartTimestamp;
    /** @type {?|undefined} */
    LockRsrc.prototype.validEndTimestamp;
    /** @type {?|undefined} */
    LockRsrc.prototype.lockedFiles;
    /** @type {?|undefined} */
    LockRsrc.prototype.etag;
    /** @type {?} */
    LockRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MessageListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    MessageListRsrc.prototype.messages;
    /** @type {?|undefined} */
    MessageListRsrc.prototype.etag;
    /** @type {?} */
    MessageListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function MessageRsrc() { }
if (false) {
    /** @type {?|undefined} */
    MessageRsrc.prototype.path;
    /** @type {?|undefined} */
    MessageRsrc.prototype.message;
    /** @type {?|undefined} */
    MessageRsrc.prototype.messageTemplate;
    /** @type {?|undefined} */
    MessageRsrc.prototype.messageArguments;
    /** @type {?} */
    MessageRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MultiPart() { }
if (false) {
    /** @type {?|undefined} */
    MultiPart.prototype.contentDisposition;
    /** @type {?|undefined} */
    MultiPart.prototype.entity;
    /** @type {?|undefined} */
    MultiPart.prototype.headers;
    /** @type {?|undefined} */
    MultiPart.prototype.mediaType;
    /** @type {?|undefined} */
    MultiPart.prototype.messageBodyWorkers;
    /** @type {?|undefined} */
    MultiPart.prototype.parent;
    /** @type {?|undefined} */
    MultiPart.prototype.providers;
    /** @type {?|undefined} */
    MultiPart.prototype.bodyParts;
    /** @type {?|undefined} */
    MultiPart.prototype.parameterizedHeaders;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function ParameterizedHeader() { }
if (false) {
    /** @type {?|undefined} */
    ParameterizedHeader.prototype.value;
    /** @type {?|undefined} */
    ParameterizedHeader.prototype.parameters;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function RelLink() { }
if (false) {
    /** @type {?|undefined} */
    RelLink.prototype.rel;
    /** @type {?|undefined} */
    RelLink.prototype.href;
    /** @type {?|undefined} */
    RelLink.prototype.method;
    /** @type {?|undefined} */
    RelLink.prototype.etag;
    /** @type {?} */
    RelLink.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function SecurityKeyRsrc() { }
if (false) {
    /** @type {?|undefined} */
    SecurityKeyRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    SecurityKeyRsrc.prototype.displayLabel;
    /** @type {?|undefined} */
    SecurityKeyRsrc.prototype.etag;
    /** @type {?} */
    SecurityKeyRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
class ApiModule {
    /**
     * @param {?} parentModule
     * @param {?} http
     */
    constructor(parentModule, http) {
        if (parentModule) {
            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
        }
        if (!http) {
            throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
                'See also https://github.com/angular/angular/issues/20575');
        }
    }
    /**
     * @param {?} configurationFactory
     * @return {?}
     */
    static forRoot(configurationFactory) {
        return {
            ngModule: ApiModule,
            providers: [{ provide: Configuration, useFactory: configurationFactory }]
        };
    }
}
ApiModule.ɵfac = function ApiModule_Factory(t) { return new (t || ApiModule)(ɵngcc0.ɵɵinject(ApiModule, 12), ɵngcc0.ɵɵinject(ɵngcc1.HttpClient, 8)); };
ApiModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: ApiModule });
ApiModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
/** @nocollapse */
ApiModule.ctorParameters = () => [
    { type: ApiModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: HttpClient, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ApiModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [],
                exports: [],
                providers: []
            }]
    }], function () { return [{ type: ApiModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }, { type: ɵngcc1.HttpClient, decorators: [{
                type: Optional
            }] }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { APIS, ApiModule, BASE_PATH, COLLECTION_FORMATS, Configuration, DefaultService, HealthCheckResponseRsrc };

//# sourceMappingURL=wf1-wfdm-document-management-api.js.map