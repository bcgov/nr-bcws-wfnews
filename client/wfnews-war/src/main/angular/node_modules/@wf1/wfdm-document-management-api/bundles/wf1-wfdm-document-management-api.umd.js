(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('@wf1/wfdm-document-management-api', ['exports', '@angular/core', '@angular/common/http'], factory) :
    (global = global || self, factory((global.wf1 = global.wf1 || {}, global.wf1['wfdm-document-management-api'] = {}), global.ng.core, global.ng.common.http));
}(this, (function (exports, core, http) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * Custom HttpParameterCodec
     * Workaround for https://github.com/angular/angular/issues/18261
     */
    var /**
     * Custom HttpParameterCodec
     * Workaround for https://github.com/angular/angular/issues/18261
     */
    CustomHttpParameterCodec = /** @class */ (function () {
        function CustomHttpParameterCodec() {
        }
        /**
         * @param {?} k
         * @return {?}
         */
        CustomHttpParameterCodec.prototype.encodeKey = /**
         * @param {?} k
         * @return {?}
         */
        function (k) {
            return encodeURIComponent(k);
        };
        /**
         * @param {?} v
         * @return {?}
         */
        CustomHttpParameterCodec.prototype.encodeValue = /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            return encodeURIComponent(v);
        };
        /**
         * @param {?} k
         * @return {?}
         */
        CustomHttpParameterCodec.prototype.decodeKey = /**
         * @param {?} k
         * @return {?}
         */
        function (k) {
            return decodeURIComponent(k);
        };
        /**
         * @param {?} v
         * @return {?}
         */
        CustomHttpParameterCodec.prototype.decodeValue = /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            return decodeURIComponent(v);
        };
        return CustomHttpParameterCodec;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BASE_PATH = new core.InjectionToken('basePath');
    /** @type {?} */
    var COLLECTION_FORMATS = {
        'csv': ',',
        'tsv': '   ',
        'ssv': ' ',
        'pipes': '|'
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function ConfigurationParameters() { }
    if (false) {
        /** @type {?|undefined} */
        ConfigurationParameters.prototype.apiKeys;
        /** @type {?|undefined} */
        ConfigurationParameters.prototype.username;
        /** @type {?|undefined} */
        ConfigurationParameters.prototype.password;
        /** @type {?|undefined} */
        ConfigurationParameters.prototype.accessToken;
        /** @type {?|undefined} */
        ConfigurationParameters.prototype.basePath;
        /** @type {?|undefined} */
        ConfigurationParameters.prototype.withCredentials;
        /** @type {?|undefined} */
        ConfigurationParameters.prototype.encoder;
    }
    var Configuration = /** @class */ (function () {
        function Configuration(configurationParameters) {
            if (configurationParameters === void 0) { configurationParameters = {}; }
            this.apiKeys = configurationParameters.apiKeys;
            this.username = configurationParameters.username;
            this.password = configurationParameters.password;
            this.accessToken = configurationParameters.accessToken;
            this.basePath = configurationParameters.basePath;
            this.withCredentials = configurationParameters.withCredentials;
            this.encoder = configurationParameters.encoder;
        }
        /**
         * Select the correct content-type to use for a request.
         * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param contentTypes - the array of content types that are available for selection
         * @returns the selected content-type or <code>undefined</code> if no selection could be made.
         */
        /**
         * Select the correct content-type to use for a request.
         * Uses {\@link Configuration#isJsonMime} to determine the correct content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param {?} contentTypes - the array of content types that are available for selection
         * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
         */
        Configuration.prototype.selectHeaderContentType = /**
         * Select the correct content-type to use for a request.
         * Uses {\@link Configuration#isJsonMime} to determine the correct content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param {?} contentTypes - the array of content types that are available for selection
         * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
         */
        function (contentTypes) {
            var _this = this;
            if (contentTypes.length === 0) {
                return undefined;
            }
            /** @type {?} */
            var type = contentTypes.find(function (x) { return _this.isJsonMime(x); });
            if (type === undefined) {
                return contentTypes[0];
            }
            return type;
        };
        /**
         * Select the correct accept content-type to use for a request.
         * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param accepts - the array of content types that are available for selection.
         * @returns the selected content-type or <code>undefined</code> if no selection could be made.
         */
        /**
         * Select the correct accept content-type to use for a request.
         * Uses {\@link Configuration#isJsonMime} to determine the correct accept content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param {?} accepts - the array of content types that are available for selection.
         * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
         */
        Configuration.prototype.selectHeaderAccept = /**
         * Select the correct accept content-type to use for a request.
         * Uses {\@link Configuration#isJsonMime} to determine the correct accept content-type.
         * If no content type is found return the first found type if the contentTypes is not empty
         * @param {?} accepts - the array of content types that are available for selection.
         * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
         */
        function (accepts) {
            var _this = this;
            if (accepts.length === 0) {
                return undefined;
            }
            /** @type {?} */
            var type = accepts.find(function (x) { return _this.isJsonMime(x); });
            if (type === undefined) {
                return accepts[0];
            }
            return type;
        };
        /**
         * Check if the given MIME is a JSON MIME.
         * JSON MIME examples:
         *   application/json
         *   application/json; charset=UTF8
         *   APPLICATION/JSON
         *   application/vnd.company+json
         * @param mime - MIME (Multipurpose Internet Mail Extensions)
         * @return True if the given MIME is JSON, false otherwise.
         */
        /**
         * Check if the given MIME is a JSON MIME.
         * JSON MIME examples:
         *   application/json
         *   application/json; charset=UTF8
         *   APPLICATION/JSON
         *   application/vnd.company+json
         * @param {?} mime - MIME (Multipurpose Internet Mail Extensions)
         * @return {?} True if the given MIME is JSON, false otherwise.
         */
        Configuration.prototype.isJsonMime = /**
         * Check if the given MIME is a JSON MIME.
         * JSON MIME examples:
         *   application/json
         *   application/json; charset=UTF8
         *   APPLICATION/JSON
         *   application/vnd.company+json
         * @param {?} mime - MIME (Multipurpose Internet Mail Extensions)
         * @return {?} True if the given MIME is JSON, false otherwise.
         */
        function (mime) {
            /** @type {?} */
            var jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
            return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
        };
        return Configuration;
    }());
    if (false) {
        /** @type {?} */
        Configuration.prototype.apiKeys;
        /** @type {?} */
        Configuration.prototype.username;
        /** @type {?} */
        Configuration.prototype.password;
        /** @type {?} */
        Configuration.prototype.accessToken;
        /** @type {?} */
        Configuration.prototype.basePath;
        /** @type {?} */
        Configuration.prototype.withCredentials;
        /** @type {?} */
        Configuration.prototype.encoder;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var DefaultService = /** @class */ (function () {
        function DefaultService(httpClient, basePath, configuration) {
            this.httpClient = httpClient;
            this.basePath = 'http://localhost';
            this.defaultHeaders = new http.HttpHeaders();
            this.configuration = new Configuration();
            if (configuration) {
                this.configuration = configuration;
            }
            if (typeof this.configuration.basePath !== 'string') {
                if (typeof basePath !== 'string') {
                    basePath = this.basePath;
                }
                this.configuration.basePath = basePath;
            }
            this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
        }
        /**
         * @param consumes string[] mime-types
         * @return true: consumes contains 'multipart/form-data', false: otherwise
         */
        /**
         * @param {?} consumes string[] mime-types
         * @return {?} true: consumes contains 'multipart/form-data', false: otherwise
         */
        DefaultService.prototype.canConsumeForm = /**
         * @param {?} consumes string[] mime-types
         * @return {?} true: consumes contains 'multipart/form-data', false: otherwise
         */
        function (consumes) {
            var e_1, _a;
            /** @type {?} */
            var form = 'multipart/form-data';
            try {
                for (var consumes_1 = __values(consumes), consumes_1_1 = consumes_1.next(); !consumes_1_1.done; consumes_1_1 = consumes_1.next()) {
                    var consume = consumes_1_1.value;
                    if (form === consume) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (consumes_1_1 && !consumes_1_1.done && (_a = consumes_1.return)) _a.call(consumes_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        /**
         * @param {?} httpParams
         * @param {?} value
         * @param {?=} key
         * @return {?}
         */
        DefaultService.prototype.addToHttpParams = /**
         * @param {?} httpParams
         * @param {?} value
         * @param {?=} key
         * @return {?}
         */
        function (httpParams, value, key) {
            if (typeof value === "object" && value instanceof Date === false) {
                httpParams = this.addToHttpParamsRecursive(httpParams, value);
            }
            else {
                httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
            }
            return httpParams;
        };
        /**
         * @param {?} httpParams
         * @param {?=} value
         * @param {?=} key
         * @return {?}
         */
        DefaultService.prototype.addToHttpParamsRecursive = /**
         * @param {?} httpParams
         * @param {?=} value
         * @param {?=} key
         * @return {?}
         */
        function (httpParams, value, key) {
            var _this = this;
            if (value == null) {
                return httpParams;
            }
            if (typeof value === "object") {
                if (Array.isArray(value)) {
                    ((/** @type {?} */ (value))).forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
                }
                else if (value instanceof Date) {
                    if (key != null) {
                        httpParams = httpParams.append(key, ((/** @type {?} */ (value))).toISOString().substr(0, 10));
                    }
                    else {
                        throw Error("key may not be null if value is Date");
                    }
                }
                else {
                    Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
                }
            }
            else if (key != null) {
                httpParams = httpParams.append(key, value);
            }
            else {
                throw Error("key may not be null if value is not object or array");
            }
            return httpParams;
        };
        /**
         * @param {?} documentId
         * @param {?} fileCheckoutRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.addDocumentCheckout = /**
         * @param {?} documentId
         * @param {?} fileCheckoutRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (documentId, fileCheckoutRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling addDocumentCheckout.');
            }
            if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {
                throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling addDocumentCheckout.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout", fileCheckoutRsrc, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?} requestBody
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.addFilesToLock = /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?} requestBody
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, lockId, requestBody, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling addFilesToLock.');
            }
            if (lockId === null || lockId === undefined) {
                throw new Error('Required parameter lockId was null or undefined when calling addFilesToLock.');
            }
            if (requestBody === null || requestBody === undefined) {
                throw new Error('Required parameter requestBody was null or undefined when calling addFilesToLock.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)) + "/addFile", requestBody, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} lockRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.addLock = /**
         * @param {?} lockRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (lockRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (lockRsrc === null || lockRsrc === undefined) {
                throw new Error('Required parameter lockRsrc was null or undefined when calling addLock.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/lock", lockRsrc, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} targetFilePath
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.copyDocument = /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} targetFilePath
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, documentId, restVersion, targetFilePath, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling copyDocument.');
            }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling copyDocument.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (targetFilePath !== undefined && targetFilePath !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (targetFilePath)), 'targetFilePath');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/copy", null, {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} recursiveInd
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.deleteDocumentByDocumentID = /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} recursiveInd
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, documentId, restVersion, recursiveInd, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentByDocumentID.');
            }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentByDocumentID.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (recursiveInd !== undefined && recursiveInd !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursiveInd)), 'recursiveInd');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    '*/*'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.delete(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)), {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?} documentCheckoutId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.deleteDocumentCheckout = /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?} documentCheckoutId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, documentId, documentCheckoutId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentCheckout.');
            }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentCheckout.');
            }
            if (documentCheckoutId === null || documentCheckoutId === undefined) {
                throw new Error('Required parameter documentCheckoutId was null or undefined when calling deleteDocumentCheckout.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    '*/*'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.delete(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout/" + encodeURIComponent(String(documentCheckoutId)), {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.deleteLock = /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, lockId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling deleteLock.');
            }
            if (lockId === null || lockId === undefined) {
                throw new Error('Required parameter lockId was null or undefined when calling deleteLock.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    '*/*'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.delete(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)), {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} codeHierarchyName
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getCodeHierarchyListResource = /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} codeHierarchyName
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, codeHierarchyName, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
            }
            if (codeHierarchyName !== undefined && codeHierarchyName !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (codeHierarchyName)), 'codeHierarchyName');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/codeHierarchies", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} codeHierarchyName
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getCodeHierarchyResourceByCodeTableName = /**
         * @param {?} codeHierarchyName
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (codeHierarchyName, requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (codeHierarchyName === null || codeHierarchyName === undefined) {
                throw new Error('Required parameter codeHierarchyName was null or undefined when calling getCodeHierarchyResourceByCodeTableName.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/codeHierarchies/" + encodeURIComponent(String(codeHierarchyName)), {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} codeTableName
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getCodeTableListResource = /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} codeTableName
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, codeTableName, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
            }
            if (codeTableName !== undefined && codeTableName !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (codeTableName)), 'codeTableName');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/codeTables", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} codeTableName
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getCodeTableResourceByCodeTableName = /**
         * @param {?} codeTableName
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} effectiveAsOfDate
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (codeTableName, requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (codeTableName === null || codeTableName === undefined) {
                throw new Error('Required parameter codeTableName was null or undefined when calling getCodeTableResourceByCodeTableName.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/codeTables/" + encodeURIComponent(String(codeTableName)), {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getDocumentById = /**
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (documentId, restVersion, cacheControl, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling getDocumentById.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)), {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} documentId
         * @param {?} documentCheckoutId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getDocumentCheckout = /**
         * @param {?} documentId
         * @param {?} documentCheckoutId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (documentId, documentCheckoutId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckout.');
            }
            if (documentCheckoutId === null || documentCheckoutId === undefined) {
                throw new Error('Required parameter documentCheckoutId was null or undefined when calling getDocumentCheckout.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout/" + encodeURIComponent(String(documentCheckoutId)), {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} documentId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getDocumentCheckoutList = /**
         * @param {?} documentId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (documentId, requestId, restVersion, cacheControl, pragma, authorization, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckoutList.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (pageNumber !== undefined && pageNumber !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
            }
            if (pageRowCount !== undefined && pageRowCount !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
            }
            if (orderBy !== undefined && orderBy !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} versionNumber
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getDocumentFileBytesById = /**
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} versionNumber
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (documentId, restVersion, versionNumber, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling getDocumentFileBytesById.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (versionNumber !== undefined && versionNumber !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (versionNumber)), 'versionNumber');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    '*/*'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/bytes", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} parentId
         * @param {?=} recursive
         * @param {?=} lockId
         * @param {?=} metadata
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getDocumentList = /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} parentId
         * @param {?=} recursive
         * @param {?=} lockId
         * @param {?=} metadata
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (requestId, restVersion, cacheControl, pragma, authorization, parentId, recursive, lockId, metadata, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
            var _this = this;
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (parentId !== undefined && parentId !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (parentId)), 'parentId');
            }
            if (recursive !== undefined && recursive !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursive)), 'recursive');
            }
            if (lockId !== undefined && lockId !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (lockId)), 'lockId');
            }
            if (metadata) {
                metadata.forEach(function (element) {
                    queryParameters = _this.addToHttpParams(queryParameters, (/** @type {?} */ (element)), 'metadata');
                });
            }
            if (pageNumber !== undefined && pageNumber !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
            }
            if (pageRowCount !== undefined && pageRowCount !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
            }
            if (orderBy !== undefined && orderBy !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/documents", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} documentId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getDocumentLock = /**
         * @param {?} documentId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (documentId, requestId, restVersion, cacheControl, pragma, authorization, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling getDocumentLock.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (pageNumber !== undefined && pageNumber !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
            }
            if (pageRowCount !== undefined && pageRowCount !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
            }
            if (orderBy !== undefined && orderBy !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/fileLock", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} searchText
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getListOfLocks = /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} searchText
         * @param {?=} pageNumber
         * @param {?=} pageRowCount
         * @param {?=} orderBy
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (requestId, restVersion, cacheControl, pragma, authorization, searchText, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
            var _this = this;
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (searchText) {
                searchText.forEach(function (element) {
                    queryParameters = _this.addToHttpParams(queryParameters, (/** @type {?} */ (element)), 'searchText');
                });
            }
            if (pageNumber !== undefined && pageNumber !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
            }
            if (pageRowCount !== undefined && pageRowCount !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
            }
            if (orderBy !== undefined && orderBy !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/lock", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} lockId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getLock = /**
         * @param {?} lockId
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (lockId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (lockId === null || lockId === undefined) {
                throw new Error('Required parameter lockId was null or undefined when calling getLock.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)), {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getSwaggerDocument = /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/openapi.json", {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.getTopLevelResources = /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/", {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} newFilePath
         * @param {?=} recursiveInd
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.moveDocument = /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?=} restVersion
         * @param {?=} newFilePath
         * @param {?=} recursiveInd
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, documentId, restVersion, newFilePath, recursiveInd, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling moveDocument.');
            }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling moveDocument.');
            }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (newFilePath !== undefined && newFilePath !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (newFilePath)), 'newFilePath');
            }
            if (recursiveInd !== undefined && recursiveInd !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursiveInd)), 'recursiveInd');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/move", null, {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} callstack
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.queryTheHealthOfTheService = /**
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} callstack
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (requestId, restVersion, cacheControl, pragma, authorization, callstack, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            /** @type {?} */
            var queryParameters = new http.HttpParams({ encoder: this.encoder });
            if (callstack !== undefined && callstack !== null) {
                queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (callstack)), 'callstack');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.get(this.configuration.basePath + "/checkHealth", {
                params: queryParameters,
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?} body
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.removeFileFromLock = /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?} body
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, lockId, body, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling removeFileFromLock.');
            }
            if (lockId === null || lockId === undefined) {
                throw new Error('Required parameter lockId was null or undefined when calling removeFileFromLock.');
            }
            if (body === null || body === undefined) {
                throw new Error('Required parameter body was null or undefined when calling removeFileFromLock.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)) + "/removeFile", body, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} codeHierarchyName
         * @param {?} codeHierarchyRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.updateCodeHierarchyResourceByCodeTableName = /**
         * @param {?} ifMatch
         * @param {?} codeHierarchyName
         * @param {?} codeHierarchyRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, codeHierarchyName, codeHierarchyRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
            }
            if (codeHierarchyName === null || codeHierarchyName === undefined) {
                throw new Error('Required parameter codeHierarchyName was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
            }
            if (codeHierarchyRsrc === null || codeHierarchyRsrc === undefined) {
                throw new Error('Required parameter codeHierarchyRsrc was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/codeHierarchies/" + encodeURIComponent(String(codeHierarchyName)), codeHierarchyRsrc, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} codeTableName
         * @param {?} codeTableRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.updateCodeTableResourceByCodeTableName = /**
         * @param {?} ifMatch
         * @param {?} codeTableName
         * @param {?} codeTableRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, codeTableName, codeTableRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeTableResourceByCodeTableName.');
            }
            if (codeTableName === null || codeTableName === undefined) {
                throw new Error('Required parameter codeTableName was null or undefined when calling updateCodeTableResourceByCodeTableName.');
            }
            if (codeTableRsrc === null || codeTableRsrc === undefined) {
                throw new Error('Required parameter codeTableRsrc was null or undefined when calling updateCodeTableResourceByCodeTableName.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/codeTables/" + encodeURIComponent(String(codeTableName)), codeTableRsrc, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?} resource
         * @param {?=} restVersion
         * @param {?=} file
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.updateDocument1 = /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?} resource
         * @param {?=} restVersion
         * @param {?=} file
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, documentId, resource, restVersion, file, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling updateDocument1.');
            }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling updateDocument1.');
            }
            if (resource === null || resource === undefined) {
                throw new Error('Required parameter resource was null or undefined when calling updateDocument1.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'multipart/form-data'
            ];
            /** @type {?} */
            var canConsumeForm = this.canConsumeForm(consumes);
            /** @type {?} */
            var formParams;
            /** @type {?} */
            var useForm = false;
            /** @type {?} */
            var convertFormParamsToString = false;
            if (useForm) {
                formParams = new FormData();
            }
            else {
                formParams = new http.HttpParams({ encoder: this.encoder });
            }
            if (resource !== undefined) {
                formParams = (/** @type {?} */ (formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], { type: 'application/json' }) : (/** @type {?} */ (resource))))) || formParams;
            }
            if (file !== undefined) {
                formParams = (/** @type {?} */ (formParams.append('file', useForm ? new Blob([JSON.stringify(file)], { type: 'application/json' }) : (/** @type {?} */ (file))))) || formParams;
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)), convertFormParamsToString ? formParams.toString() : formParams, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?} documentCheckoutId
         * @param {?} fileCheckoutRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.updateDocumentCheckout = /**
         * @param {?} ifMatch
         * @param {?} documentId
         * @param {?} documentCheckoutId
         * @param {?} fileCheckoutRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, documentId, documentCheckoutId, fileCheckoutRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling updateDocumentCheckout.');
            }
            if (documentId === null || documentId === undefined) {
                throw new Error('Required parameter documentId was null or undefined when calling updateDocumentCheckout.');
            }
            if (documentCheckoutId === null || documentCheckoutId === undefined) {
                throw new Error('Required parameter documentCheckoutId was null or undefined when calling updateDocumentCheckout.');
            }
            if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {
                throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling updateDocumentCheckout.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout/" + encodeURIComponent(String(documentCheckoutId)), fileCheckoutRsrc, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?} lockRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.updateLock = /**
         * @param {?} ifMatch
         * @param {?} lockId
         * @param {?} lockRsrc
         * @param {?=} requestId
         * @param {?=} restVersion
         * @param {?=} cacheControl
         * @param {?=} pragma
         * @param {?=} authorization
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (ifMatch, lockId, lockRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (ifMatch === null || ifMatch === undefined) {
                throw new Error('Required parameter ifMatch was null or undefined when calling updateLock.');
            }
            if (lockId === null || lockId === undefined) {
                throw new Error('Required parameter lockId was null or undefined when calling updateLock.');
            }
            if (lockRsrc === null || lockRsrc === undefined) {
                throw new Error('Required parameter lockRsrc was null or undefined when calling updateLock.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (requestId !== undefined && requestId !== null) {
                headers = headers.set('RequestId', String(requestId));
            }
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            if (cacheControl !== undefined && cacheControl !== null) {
                headers = headers.set('Cache-Control', String(cacheControl));
            }
            if (pragma !== undefined && pragma !== null) {
                headers = headers.set('Pragma', String(pragma));
            }
            if (authorization !== undefined && authorization !== null) {
                headers = headers.set('Authorization', String(authorization));
            }
            if (ifMatch !== undefined && ifMatch !== null) {
                headers = headers.set('If-Match', String(ifMatch));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'application/json',
                'application/xml'
            ];
            /** @type {?} */
            var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
            if (httpContentTypeSelected !== undefined) {
                headers = headers.set('Content-Type', httpContentTypeSelected);
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.put(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)), lockRsrc, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        /**
         * @param {?} resource
         * @param {?=} restVersion
         * @param {?=} file
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        DefaultService.prototype.uploadDocument = /**
         * @param {?} resource
         * @param {?=} restVersion
         * @param {?=} file
         * @param {?=} observe
         * @param {?=} reportProgress
         * @param {?=} options
         * @return {?}
         */
        function (resource, restVersion, file, observe, reportProgress, options) {
            if (observe === void 0) { observe = 'body'; }
            if (reportProgress === void 0) { reportProgress = false; }
            if (resource === null || resource === undefined) {
                throw new Error('Required parameter resource was null or undefined when calling uploadDocument.');
            }
            /** @type {?} */
            var headers = this.defaultHeaders;
            if (restVersion !== undefined && restVersion !== null) {
                headers = headers.set('Rest-Version', String(restVersion));
            }
            /** @type {?} */
            var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
            if (httpHeaderAcceptSelected === undefined) {
                // to determine the Accept header
                /** @type {?} */
                var httpHeaderAccepts = [
                    'application/json',
                    'application/xml'
                ];
                httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
            }
            if (httpHeaderAcceptSelected !== undefined) {
                headers = headers.set('Accept', httpHeaderAcceptSelected);
            }
            // to determine the Content-Type header
            /** @type {?} */
            var consumes = [
                'multipart/form-data'
            ];
            /** @type {?} */
            var canConsumeForm = this.canConsumeForm(consumes);
            /** @type {?} */
            var formParams;
            /** @type {?} */
            var useForm = false;
            /** @type {?} */
            var convertFormParamsToString = false;
            if (useForm) {
                formParams = new FormData();
            }
            else {
                formParams = new http.HttpParams({ encoder: this.encoder });
            }
            if (resource !== undefined) {
                formParams = (/** @type {?} */ (formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], { type: 'application/json' }) : (/** @type {?} */ (resource))))) || formParams;
            }
            if (file !== undefined) {
                formParams = (/** @type {?} */ (formParams.append('file', useForm ? new Blob([JSON.stringify(file)], { type: 'application/json' }) : (/** @type {?} */ (file))))) || formParams;
            }
            /** @type {?} */
            var responseType = 'json';
            if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
                responseType = 'text';
            }
            return this.httpClient.post(this.configuration.basePath + "/documents", convertFormParamsToString ? formParams.toString() : formParams, {
                responseType: (/** @type {?} */ (responseType)),
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            });
        };
        DefaultService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        DefaultService.ctorParameters = function () { return [
            { type: http.HttpClient },
            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [BASE_PATH,] }] },
            { type: Configuration, decorators: [{ type: core.Optional }] }
        ]; };
        /** @nocollapse */ DefaultService.ɵprov = core.ɵɵdefineInjectable({ factory: function DefaultService_Factory() { return new DefaultService(core.ɵɵinject(http.HttpClient), core.ɵɵinject(BASE_PATH, 8), core.ɵɵinject(Configuration, 8)); }, token: DefaultService, providedIn: "root" });
        return DefaultService;
    }());
    if (false) {
        /** @type {?} */
        DefaultService.prototype.basePath;
        /** @type {?} */
        DefaultService.prototype.defaultHeaders;
        /** @type {?} */
        DefaultService.prototype.configuration;
        /** @type {?} */
        DefaultService.prototype.encoder;
        /** @type {?} */
        DefaultService.prototype.httpClient;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /** @type {?} */
    var APIS = [DefaultService];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function BodyPart() { }
    if (false) {
        /** @type {?|undefined} */
        BodyPart.prototype.contentDisposition;
        /** @type {?|undefined} */
        BodyPart.prototype.entity;
        /** @type {?|undefined} */
        BodyPart.prototype.headers;
        /** @type {?|undefined} */
        BodyPart.prototype.mediaType;
        /** @type {?|undefined} */
        BodyPart.prototype.messageBodyWorkers;
        /** @type {?|undefined} */
        BodyPart.prototype.parent;
        /** @type {?|undefined} */
        BodyPart.prototype.providers;
        /** @type {?|undefined} */
        BodyPart.prototype.parameterizedHeaders;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function BodyPartMediaType() { }
    if (false) {
        /** @type {?|undefined} */
        BodyPartMediaType.prototype.type;
        /** @type {?|undefined} */
        BodyPartMediaType.prototype.subtype;
        /** @type {?|undefined} */
        BodyPartMediaType.prototype.parameters;
        /** @type {?|undefined} */
        BodyPartMediaType.prototype.wildcardType;
        /** @type {?|undefined} */
        BodyPartMediaType.prototype.wildcardSubtype;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function CodeHierarchyListRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        CodeHierarchyListRsrc.prototype.links;
        /** @type {?|undefined} */
        CodeHierarchyListRsrc.prototype.codeHierarchyList;
        /** @type {?|undefined} */
        CodeHierarchyListRsrc.prototype.etag;
        /** @type {?} */
        CodeHierarchyListRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function CodeHierarchyRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        CodeHierarchyRsrc.prototype.links;
        /** @type {?|undefined} */
        CodeHierarchyRsrc.prototype.codeHierarchyName;
        /** @type {?|undefined} */
        CodeHierarchyRsrc.prototype.lowerCodeTableName;
        /** @type {?|undefined} */
        CodeHierarchyRsrc.prototype.upperCodeTableName;
        /** @type {?|undefined} */
        CodeHierarchyRsrc.prototype.hierarchy;
        /** @type {?|undefined} */
        CodeHierarchyRsrc.prototype.etag;
        /** @type {?} */
        CodeHierarchyRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function CodeRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        CodeRsrc.prototype.code;
        /** @type {?|undefined} */
        CodeRsrc.prototype.description;
        /** @type {?|undefined} */
        CodeRsrc.prototype.displayOrder;
        /** @type {?|undefined} */
        CodeRsrc.prototype.effectiveDate;
        /** @type {?|undefined} */
        CodeRsrc.prototype.expiryDate;
        /** @type {?} */
        CodeRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function CodeTableListRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        CodeTableListRsrc.prototype.links;
        /** @type {?|undefined} */
        CodeTableListRsrc.prototype.codeTableList;
        /** @type {?|undefined} */
        CodeTableListRsrc.prototype.etag;
        /** @type {?} */
        CodeTableListRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function CodeTableRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        CodeTableRsrc.prototype.links;
        /** @type {?|undefined} */
        CodeTableRsrc.prototype.codeTableName;
        /** @type {?|undefined} */
        CodeTableRsrc.prototype.codes;
        /** @type {?|undefined} */
        CodeTableRsrc.prototype.etag;
        /** @type {?} */
        CodeTableRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function ContentDisposition() { }
    if (false) {
        /** @type {?|undefined} */
        ContentDisposition.prototype.type;
        /** @type {?|undefined} */
        ContentDisposition.prototype.parameters;
        /** @type {?|undefined} */
        ContentDisposition.prototype.fileName;
        /** @type {?|undefined} */
        ContentDisposition.prototype.creationDate;
        /** @type {?|undefined} */
        ContentDisposition.prototype.modificationDate;
        /** @type {?|undefined} */
        ContentDisposition.prototype.readDate;
        /** @type {?|undefined} */
        ContentDisposition.prototype.size;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function EndpointsRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        EndpointsRsrc.prototype.links;
        /** @type {?|undefined} */
        EndpointsRsrc.prototype.releaseVersion;
        /** @type {?|undefined} */
        EndpointsRsrc.prototype.etag;
        /** @type {?} */
        EndpointsRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function FileCheckoutRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.links;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.fileCheckoutId;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.file;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.securityKey;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.checkOutComment;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.checkInComment;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.validStartTimestamp;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.validEndTimestamp;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.displayLabel;
        /** @type {?|undefined} */
        FileCheckoutRsrc.prototype.etag;
        /** @type {?} */
        FileCheckoutRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function FileDetailsRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.links;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.fileId;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.filePath;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.lastUpdatedTimestamp;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.versionNumber;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.fileExtension;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.fileType;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.mimeType;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.fileSize;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.retention;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.security;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.metadata;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.versions;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.uploadedBy;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.uploadedOnTimestamp;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.lastUpdatedBy;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.lastUpdatedByGuid;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.parent;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.validStartTimestamp;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.validEndTimestamp;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.fileCheckout;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.lockedInd;
        /** @type {?|undefined} */
        FileDetailsRsrc.prototype.etag;
        /** @type {?} */
        FileDetailsRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function FileListRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        FileListRsrc.prototype.links;
        /** @type {?|undefined} */
        FileListRsrc.prototype.pageNumber;
        /** @type {?|undefined} */
        FileListRsrc.prototype.pageRowCount;
        /** @type {?|undefined} */
        FileListRsrc.prototype.totalRowCount;
        /** @type {?|undefined} */
        FileListRsrc.prototype.totalPageCount;
        /** @type {?|undefined} */
        FileListRsrc.prototype.collection;
        /** @type {?|undefined} */
        FileListRsrc.prototype.etag;
        /** @type {?} */
        FileListRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function FileMetadataRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        FileMetadataRsrc.prototype.metadataName;
        /** @type {?|undefined} */
        FileMetadataRsrc.prototype.metadataValue;
        /** @type {?|undefined} */
        FileMetadataRsrc.prototype.etag;
        /** @type {?} */
        FileMetadataRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function FileRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        FileRsrc.prototype.links;
        /** @type {?|undefined} */
        FileRsrc.prototype.fileId;
        /** @type {?|undefined} */
        FileRsrc.prototype.filePath;
        /** @type {?|undefined} */
        FileRsrc.prototype.lastUpdatedTimestamp;
        /** @type {?|undefined} */
        FileRsrc.prototype.etag;
        /** @type {?} */
        FileRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function FileSecurityRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        FileSecurityRsrc.prototype.securityKey;
        /** @type {?|undefined} */
        FileSecurityRsrc.prototype.grantorAccessInd;
        /** @type {?|undefined} */
        FileSecurityRsrc.prototype.readAccessInd;
        /** @type {?|undefined} */
        FileSecurityRsrc.prototype.writeAccessInd;
        /** @type {?|undefined} */
        FileSecurityRsrc.prototype.etag;
        /** @type {?} */
        FileSecurityRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function FileVersionRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        FileVersionRsrc.prototype.versionNumber;
        /** @type {?|undefined} */
        FileVersionRsrc.prototype.fileSize;
        /** @type {?|undefined} */
        FileVersionRsrc.prototype.uploadedById;
        /** @type {?|undefined} */
        FileVersionRsrc.prototype.uploadedOnTimestamp;
        /** @type {?|undefined} */
        FileVersionRsrc.prototype.etag;
        /** @type {?} */
        FileVersionRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function FormDataBodyPart() { }
    if (false) {
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.contentDisposition;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.entity;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.headers;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.mediaType;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.messageBodyWorkers;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.parent;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.providers;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.simple;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.formDataContentDisposition;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.name;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.value;
        /** @type {?|undefined} */
        FormDataBodyPart.prototype.parameterizedHeaders;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function FormDataContentDisposition() { }
    if (false) {
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.type;
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.parameters;
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.fileName;
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.creationDate;
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.modificationDate;
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.readDate;
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.size;
        /** @type {?|undefined} */
        FormDataContentDisposition.prototype.name;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    // WARNING: interface has both a type and a value, skipping emit

    (function (HealthCheckResponseRsrc) {
        HealthCheckResponseRsrc.ValidationStatusEnum = {
            RED: (/** @type {?} */ ('RED')),
            YELLOW: (/** @type {?} */ ('YELLOW')),
            GREEN: (/** @type {?} */ ('GREEN'))
        };
    })(exports.HealthCheckResponseRsrc || (exports.HealthCheckResponseRsrc = {}));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function Hierarchy() { }
    if (false) {
        /** @type {?|undefined} */
        Hierarchy.prototype.lowerCode;
        /** @type {?|undefined} */
        Hierarchy.prototype.upperCode;
        /** @type {?|undefined} */
        Hierarchy.prototype.effectiveDate;
        /** @type {?|undefined} */
        Hierarchy.prototype.expiryDate;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function InlineObject() { }
    if (false) {
        /** @type {?} */
        InlineObject.prototype.resource;
        /** @type {?|undefined} */
        InlineObject.prototype.file;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function InlineObject1() { }
    if (false) {
        /** @type {?} */
        InlineObject1.prototype.resource;
        /** @type {?|undefined} */
        InlineObject1.prototype.file;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function LockListRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        LockListRsrc.prototype.links;
        /** @type {?|undefined} */
        LockListRsrc.prototype.pageNumber;
        /** @type {?|undefined} */
        LockListRsrc.prototype.pageRowCount;
        /** @type {?|undefined} */
        LockListRsrc.prototype.totalRowCount;
        /** @type {?|undefined} */
        LockListRsrc.prototype.totalPageCount;
        /** @type {?|undefined} */
        LockListRsrc.prototype.collection;
        /** @type {?|undefined} */
        LockListRsrc.prototype.etag;
        /** @type {?} */
        LockListRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function LockRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        LockRsrc.prototype.links;
        /** @type {?|undefined} */
        LockRsrc.prototype.lockId;
        /** @type {?|undefined} */
        LockRsrc.prototype.securityKey;
        /** @type {?|undefined} */
        LockRsrc.prototype.lockReason;
        /** @type {?|undefined} */
        LockRsrc.prototype.validStartTimestamp;
        /** @type {?|undefined} */
        LockRsrc.prototype.validEndTimestamp;
        /** @type {?|undefined} */
        LockRsrc.prototype.lockedFiles;
        /** @type {?|undefined} */
        LockRsrc.prototype.etag;
        /** @type {?} */
        LockRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function MessageListRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        MessageListRsrc.prototype.messages;
        /** @type {?|undefined} */
        MessageListRsrc.prototype.etag;
        /** @type {?} */
        MessageListRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function MessageRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        MessageRsrc.prototype.path;
        /** @type {?|undefined} */
        MessageRsrc.prototype.message;
        /** @type {?|undefined} */
        MessageRsrc.prototype.messageTemplate;
        /** @type {?|undefined} */
        MessageRsrc.prototype.messageArguments;
        /** @type {?} */
        MessageRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function MultiPart() { }
    if (false) {
        /** @type {?|undefined} */
        MultiPart.prototype.contentDisposition;
        /** @type {?|undefined} */
        MultiPart.prototype.entity;
        /** @type {?|undefined} */
        MultiPart.prototype.headers;
        /** @type {?|undefined} */
        MultiPart.prototype.mediaType;
        /** @type {?|undefined} */
        MultiPart.prototype.messageBodyWorkers;
        /** @type {?|undefined} */
        MultiPart.prototype.parent;
        /** @type {?|undefined} */
        MultiPart.prototype.providers;
        /** @type {?|undefined} */
        MultiPart.prototype.bodyParts;
        /** @type {?|undefined} */
        MultiPart.prototype.parameterizedHeaders;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function ParameterizedHeader() { }
    if (false) {
        /** @type {?|undefined} */
        ParameterizedHeader.prototype.value;
        /** @type {?|undefined} */
        ParameterizedHeader.prototype.parameters;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function RelLink() { }
    if (false) {
        /** @type {?|undefined} */
        RelLink.prototype.rel;
        /** @type {?|undefined} */
        RelLink.prototype.href;
        /** @type {?|undefined} */
        RelLink.prototype.method;
        /** @type {?|undefined} */
        RelLink.prototype.etag;
        /** @type {?} */
        RelLink.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    /**
     * WFDM Document Management API
     * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
     *
     * The version of the OpenAPI document: 1.2.0-SNAPSHOT
     *
     *
     * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
     * https://openapi-generator.tech
     * Do not edit the class manually.
     */
    /**
     * @record
     */
    function SecurityKeyRsrc() { }
    if (false) {
        /** @type {?|undefined} */
        SecurityKeyRsrc.prototype.securityKey;
        /** @type {?|undefined} */
        SecurityKeyRsrc.prototype.displayLabel;
        /** @type {?|undefined} */
        SecurityKeyRsrc.prototype.etag;
        /** @type {?} */
        SecurityKeyRsrc.prototype.type;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
     */
    var ApiModule = /** @class */ (function () {
        function ApiModule(parentModule, http) {
            if (parentModule) {
                throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
            }
            if (!http) {
                throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
                    'See also https://github.com/angular/angular/issues/20575');
            }
        }
        /**
         * @param {?} configurationFactory
         * @return {?}
         */
        ApiModule.forRoot = /**
         * @param {?} configurationFactory
         * @return {?}
         */
        function (configurationFactory) {
            return {
                ngModule: ApiModule,
                providers: [{ provide: Configuration, useFactory: configurationFactory }]
            };
        };
        ApiModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        declarations: [],
                        exports: [],
                        providers: []
                    },] }
        ];
        /** @nocollapse */
        ApiModule.ctorParameters = function () { return [
            { type: ApiModule, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: http.HttpClient, decorators: [{ type: core.Optional }] }
        ]; };
        return ApiModule;
    }());

    exports.APIS = APIS;
    exports.ApiModule = ApiModule;
    exports.BASE_PATH = BASE_PATH;
    exports.COLLECTION_FORMATS = COLLECTION_FORMATS;
    exports.Configuration = Configuration;
    exports.DefaultService = DefaultService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=wf1-wfdm-document-management-api.umd.js.map
