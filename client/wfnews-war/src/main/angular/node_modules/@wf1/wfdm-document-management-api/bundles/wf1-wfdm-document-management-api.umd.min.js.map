{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@wf1/wfdm-document-management-api/encoder.ts","ng://@wf1/wfdm-document-management-api/variables.ts","ng://@wf1/wfdm-document-management-api/configuration.ts","ng://@wf1/wfdm-document-management-api/api/default.service.ts","ng://@wf1/wfdm-document-management-api/api/api.ts","ng://@wf1/wfdm-document-management-api/model/healthCheckResponseRsrc.ts","ng://@wf1/wfdm-document-management-api/api.module.ts"],"names":["__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","CustomHttpParameterCodec","prototype","encodeKey","k","encodeURIComponent","encodeValue","v","decodeKey","decodeURIComponent","decodeValue","BASE_PATH","InjectionToken","Configuration","configurationParameters","this","apiKeys","username","password","accessToken","basePath","withCredentials","encoder","selectHeaderContentType","contentTypes","_this","type","find","x","isJsonMime","undefined","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","DefaultService","httpClient","configuration","defaultHeaders","HttpHeaders","canConsumeForm","consumes","consumes_1","consumes_1_1","addToHttpParams","httpParams","key","Date","addToHttpParamsRecursive","Array","isArray","forEach","elem","Error","append","toISOString","substr","Object","keys","addDocumentCheckout","documentId","fileCheckoutRsrc","requestId","restVersion","cacheControl","pragma","authorization","observe","reportProgress","options","headers","set","String","httpHeaderAcceptSelected","httpHeaderAccept","httpContentTypeSelected","responseType","startsWith","post","addFilesToLock","ifMatch","lockId","requestBody","put","addLock","lockRsrc","copyDocument","targetFilePath","queryParameters","HttpParams","params","deleteDocumentByDocumentID","recursiveInd","delete","deleteDocumentCheckout","documentCheckoutId","deleteLock","getCodeHierarchyListResource","effectiveAsOfDate","codeHierarchyName","get","getCodeHierarchyResourceByCodeTableName","getCodeTableListResource","codeTableName","getCodeTableResourceByCodeTableName","getDocumentById","getDocumentCheckout","getDocumentCheckoutList","pageNumber","pageRowCount","orderBy","getDocumentFileBytesById","versionNumber","getDocumentList","parentId","recursive","metadata","element","getDocumentLock","getListOfLocks","searchText","getLock","getSwaggerDocument","getTopLevelResources","moveDocument","newFilePath","queryTheHealthOfTheService","callstack","removeFileFromLock","body","updateCodeHierarchyResourceByCodeTableName","codeHierarchyRsrc","updateCodeTableResourceByCodeTableName","codeTableRsrc","updateDocument1","resource","file","formParams","updateDocumentCheckout","updateLock","uploadDocument","Injectable","args","providedIn","HttpClient","Optional","Inject","decorators","APIS","HealthCheckResponseRsrc","ValidationStatusEnum","RED","YELLOW","GREEN","ApiModule","parentModule","http","forRoot","configurationFactory","ngModule","providers","provide","useFactory","NgModule","imports","declarations","exports","SkipSelf","csv","tsv","ssv","pipes"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\nexport interface ConfigurationParameters {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n}\n\nexport class Configuration {\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\n","/**\n * WFDM Document Management API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.2.0-SNAPSHOT\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { CodeHierarchyListRsrc } from '../model/models';\nimport { CodeHierarchyRsrc } from '../model/models';\nimport { CodeTableListRsrc } from '../model/models';\nimport { CodeTableRsrc } from '../model/models';\nimport { EndpointsRsrc } from '../model/models';\nimport { FileCheckoutRsrc } from '../model/models';\nimport { FileDetailsRsrc } from '../model/models';\nimport { FileListRsrc } from '../model/models';\nimport { FormDataBodyPart } from '../model/models';\nimport { HealthCheckResponseRsrc } from '../model/models';\nimport { LockListRsrc } from '../model/models';\nimport { LockRsrc } from '../model/models';\nimport { MessageListRsrc } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DefaultService {\n\n    protected basePath = 'http://localhost';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    private canConsumeForm(consumes: string[]): boolean {\n        const form = 'multipart/form-data';\n        for (const consume of consumes) {\n            if (form === consume) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * @param documentId The documentId of the Document resource.\n     * @param fileCheckoutRsrc The Checkout rsrc\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addDocumentCheckout(documentId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileCheckoutRsrc>;\n    public addDocumentCheckout(documentId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileCheckoutRsrc>>;\n    public addDocumentCheckout(documentId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileCheckoutRsrc>>;\n    public addDocumentCheckout(documentId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling addDocumentCheckout.');\n        }\n        if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {\n            throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling addDocumentCheckout.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<FileCheckoutRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout`,\n            fileCheckoutRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param lockId The lockId being updated.\n     * @param requestBody fileid of file to add\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addFilesToLock(ifMatch: string, lockId: string, requestBody: Array<string>, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<LockRsrc>;\n    public addFilesToLock(ifMatch: string, lockId: string, requestBody: Array<string>, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<LockRsrc>>;\n    public addFilesToLock(ifMatch: string, lockId: string, requestBody: Array<string>, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<LockRsrc>>;\n    public addFilesToLock(ifMatch: string, lockId: string, requestBody: Array<string>, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling addFilesToLock.');\n        }\n        if (lockId === null || lockId === undefined) {\n            throw new Error('Required parameter lockId was null or undefined when calling addFilesToLock.');\n        }\n        if (requestBody === null || requestBody === undefined) {\n            throw new Error('Required parameter requestBody was null or undefined when calling addFilesToLock.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<LockRsrc>(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}/addFile`,\n            requestBody,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param lockRsrc The lock rsrc\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addLock(lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<LockRsrc>;\n    public addLock(lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<LockRsrc>>;\n    public addLock(lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<LockRsrc>>;\n    public addLock(lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (lockRsrc === null || lockRsrc === undefined) {\n            throw new Error('Required parameter lockRsrc was null or undefined when calling addLock.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<LockRsrc>(`${this.configuration.basePath}/lock`,\n            lockRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param documentId The documentId of the Document resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param targetFilePath The target file path for the copy.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public copyDocument(ifMatch: string, documentId: string, restVersion?: number, targetFilePath?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileDetailsRsrc>;\n    public copyDocument(ifMatch: string, documentId: string, restVersion?: number, targetFilePath?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileDetailsRsrc>>;\n    public copyDocument(ifMatch: string, documentId: string, restVersion?: number, targetFilePath?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileDetailsRsrc>>;\n    public copyDocument(ifMatch: string, documentId: string, restVersion?: number, targetFilePath?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling copyDocument.');\n        }\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling copyDocument.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (targetFilePath !== undefined && targetFilePath !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>targetFilePath, 'targetFilePath');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<FileDetailsRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/copy`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete Document by Document ID\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param documentId The documentId of the Document resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param recursiveInd Is the delete recursive?\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteDocumentByDocumentID(ifMatch: string, documentId: string, restVersion?: number, recursiveInd?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteDocumentByDocumentID(ifMatch: string, documentId: string, restVersion?: number, recursiveInd?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteDocumentByDocumentID(ifMatch: string, documentId: string, restVersion?: number, recursiveInd?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteDocumentByDocumentID(ifMatch: string, documentId: string, restVersion?: number, recursiveInd?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentByDocumentID.');\n        }\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentByDocumentID.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (recursiveInd !== undefined && recursiveInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>recursiveInd, 'recursiveInd');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a document checkout\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param documentId The documentId being updated.\n     * @param documentCheckoutId The documentCheckoutId of the checkout resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentCheckout.');\n        }\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentCheckout.');\n        }\n        if (documentCheckoutId === null || documentCheckoutId === undefined) {\n            throw new Error('Required parameter documentCheckoutId was null or undefined when calling deleteDocumentCheckout.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout/${encodeURIComponent(String(documentCheckoutId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete a lock\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param lockId The lockId of the lock resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteLock(ifMatch: string, lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<any>;\n    public deleteLock(ifMatch: string, lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<any>>;\n    public deleteLock(ifMatch: string, lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<any>>;\n    public deleteLock(ifMatch: string, lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling deleteLock.');\n        }\n        if (lockId === null || lockId === undefined) {\n            throw new Error('Required parameter lockId was null or undefined when calling deleteLock.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Code Hierarchy List Resource\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param codeHierarchyName Filter the results by the codeHierarchyName.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeHierarchyListRsrc>;\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeHierarchyListRsrc>>;\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeHierarchyListRsrc>>;\n    public getCodeHierarchyListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeHierarchyName?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n        if (codeHierarchyName !== undefined && codeHierarchyName !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>codeHierarchyName, 'codeHierarchyName');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeHierarchyListRsrc>(`${this.configuration.basePath}/codeHierarchies`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get CodeHierarchy resource by code table name.\n     * @param codeHierarchyName The identifier of the CodeHierarchy resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeHierarchyRsrc>;\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeHierarchyRsrc>>;\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeHierarchyRsrc>>;\n    public getCodeHierarchyResourceByCodeTableName(codeHierarchyName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (codeHierarchyName === null || codeHierarchyName === undefined) {\n            throw new Error('Required parameter codeHierarchyName was null or undefined when calling getCodeHierarchyResourceByCodeTableName.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeHierarchyRsrc>(`${this.configuration.basePath}/codeHierarchies/${encodeURIComponent(String(codeHierarchyName))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Code Table List Resource\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param codeTableName Filter the results by the codeTableName.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeTableListRsrc>;\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeTableListRsrc>>;\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeTableListRsrc>>;\n    public getCodeTableListResource(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, codeTableName?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n        if (codeTableName !== undefined && codeTableName !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>codeTableName, 'codeTableName');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeTableListRsrc>(`${this.configuration.basePath}/codeTables`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get CodeTable resource by code table name.\n     * @param codeTableName The identifier of the CodeTable resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param effectiveAsOfDate Return the results as of the effectiveAsOfDate.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeTableRsrc>;\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeTableRsrc>>;\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeTableRsrc>>;\n    public getCodeTableResourceByCodeTableName(codeTableName: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, effectiveAsOfDate?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (codeTableName === null || codeTableName === undefined) {\n            throw new Error('Required parameter codeTableName was null or undefined when calling getCodeTableResourceByCodeTableName.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>effectiveAsOfDate, 'effectiveAsOfDate');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<CodeTableRsrc>(`${this.configuration.basePath}/codeTables/${encodeURIComponent(String(codeTableName))}`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param documentId The documentId of the Document resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDocumentById(documentId: string, restVersion?: number, cacheControl?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileDetailsRsrc>;\n    public getDocumentById(documentId: string, restVersion?: number, cacheControl?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileDetailsRsrc>>;\n    public getDocumentById(documentId: string, restVersion?: number, cacheControl?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileDetailsRsrc>>;\n    public getDocumentById(documentId: string, restVersion?: number, cacheControl?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling getDocumentById.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<FileDetailsRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param documentId The documentId of the Document resource.\n     * @param documentCheckoutId The documentCheckoutId of the checkout resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDocumentCheckout(documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileCheckoutRsrc>;\n    public getDocumentCheckout(documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileCheckoutRsrc>>;\n    public getDocumentCheckout(documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileCheckoutRsrc>>;\n    public getDocumentCheckout(documentId: string, documentCheckoutId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckout.');\n        }\n        if (documentCheckoutId === null || documentCheckoutId === undefined) {\n            throw new Error('Required parameter documentCheckoutId was null or undefined when calling getDocumentCheckout.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<FileCheckoutRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout/${encodeURIComponent(String(documentCheckoutId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Document Checkout List\n     * @param documentId The document resource id.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDocumentCheckoutList(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileListRsrc>;\n    public getDocumentCheckoutList(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileListRsrc>>;\n    public getDocumentCheckoutList(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileListRsrc>>;\n    public getDocumentCheckoutList(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckoutList.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<FileListRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param documentId The documentId of the Document resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param versionNumber The versionId of the Document resource.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDocumentFileBytesById(documentId: string, restVersion?: number, versionNumber?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<string>;\n    public getDocumentFileBytesById(documentId: string, restVersion?: number, versionNumber?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpResponse<string>>;\n    public getDocumentFileBytesById(documentId: string, restVersion?: number, versionNumber?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*'}): Observable<HttpEvent<string>>;\n    public getDocumentFileBytesById(documentId: string, restVersion?: number, versionNumber?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*'}): Observable<any> {\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling getDocumentFileBytesById.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (versionNumber !== undefined && versionNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>versionNumber, 'versionNumber');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                '*/*'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<string>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/bytes`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Document List\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param parentId Parent Id\n     * @param recursive ChildrenRecursive\n     * @param lockId Lock Id\n     * @param metadata metadata\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDocumentList(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, parentId?: string, recursive?: string, lockId?: string, metadata?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileListRsrc>;\n    public getDocumentList(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, parentId?: string, recursive?: string, lockId?: string, metadata?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileListRsrc>>;\n    public getDocumentList(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, parentId?: string, recursive?: string, lockId?: string, metadata?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileListRsrc>>;\n    public getDocumentList(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, parentId?: string, recursive?: string, lockId?: string, metadata?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (parentId !== undefined && parentId !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>parentId, 'parentId');\n        }\n        if (recursive !== undefined && recursive !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>recursive, 'recursive');\n        }\n        if (lockId !== undefined && lockId !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>lockId, 'lockId');\n        }\n        if (metadata) {\n            metadata.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'metadata');\n            })\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<FileListRsrc>(`${this.configuration.basePath}/documents`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param documentId The documentId of the Document resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getDocumentLock(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<LockListRsrc>;\n    public getDocumentLock(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<LockListRsrc>>;\n    public getDocumentLock(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<LockListRsrc>>;\n    public getDocumentLock(documentId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling getDocumentLock.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<LockListRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/fileLock`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param searchText searchText\n     * @param pageNumber The page number of the results to be returned.\n     * @param pageRowCount The number of results per page.\n     * @param orderBy Comma separated list of property names to order the result set by.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getListOfLocks(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<LockListRsrc>;\n    public getListOfLocks(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<LockListRsrc>>;\n    public getListOfLocks(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<LockListRsrc>>;\n    public getListOfLocks(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, searchText?: Array<string>, pageNumber?: string, pageRowCount?: string, orderBy?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (searchText) {\n            searchText.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'searchText');\n            })\n        }\n        if (pageNumber !== undefined && pageNumber !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageNumber, 'pageNumber');\n        }\n        if (pageRowCount !== undefined && pageRowCount !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>pageRowCount, 'pageRowCount');\n        }\n        if (orderBy !== undefined && orderBy !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>orderBy, 'orderBy');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<LockListRsrc>(`${this.configuration.basePath}/lock`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param lockId The lockId of the lock resource.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getLock(lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<LockRsrc>;\n    public getLock(lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<LockRsrc>>;\n    public getLock(lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<LockRsrc>>;\n    public getLock(lockId: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (lockId === null || lockId === undefined) {\n            throw new Error('Required parameter lockId was null or undefined when calling getLock.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<LockRsrc>(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Swagger Document\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getSwaggerDocument(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<EndpointsRsrc>;\n    public getSwaggerDocument(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<EndpointsRsrc>>;\n    public getSwaggerDocument(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<EndpointsRsrc>>;\n    public getSwaggerDocument(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<EndpointsRsrc>(`${this.configuration.basePath}/openapi.json`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get Top Level Resources\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getTopLevelResources(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<EndpointsRsrc>;\n    public getTopLevelResources(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<EndpointsRsrc>>;\n    public getTopLevelResources(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<EndpointsRsrc>>;\n    public getTopLevelResources(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<EndpointsRsrc>(`${this.configuration.basePath}/`,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param documentId The documentId of the Document resource.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param newFilePath The new file path of the File.\n     * @param recursiveInd Is the delete recursive?\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public moveDocument(ifMatch: string, documentId: string, restVersion?: number, newFilePath?: string, recursiveInd?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileDetailsRsrc>;\n    public moveDocument(ifMatch: string, documentId: string, restVersion?: number, newFilePath?: string, recursiveInd?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileDetailsRsrc>>;\n    public moveDocument(ifMatch: string, documentId: string, restVersion?: number, newFilePath?: string, recursiveInd?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileDetailsRsrc>>;\n    public moveDocument(ifMatch: string, documentId: string, restVersion?: number, newFilePath?: string, recursiveInd?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling moveDocument.');\n        }\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling moveDocument.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (newFilePath !== undefined && newFilePath !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>newFilePath, 'newFilePath');\n        }\n        if (recursiveInd !== undefined && recursiveInd !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>recursiveInd, 'recursiveInd');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<FileDetailsRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/move`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Query the health of the service.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param callstack A comm separated list of the identifier of the calling components.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HealthCheckResponseRsrc>;\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<HealthCheckResponseRsrc>>;\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<HealthCheckResponseRsrc>>;\n    public queryTheHealthOfTheService(requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, callstack?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (callstack !== undefined && callstack !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>callstack, 'callstack');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.get<HealthCheckResponseRsrc>(`${this.configuration.basePath}/checkHealth`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param lockId The lockId being updated.\n     * @param body fileId of file to remove\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public removeFileFromLock(ifMatch: string, lockId: string, body: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<LockRsrc>;\n    public removeFileFromLock(ifMatch: string, lockId: string, body: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<LockRsrc>>;\n    public removeFileFromLock(ifMatch: string, lockId: string, body: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<LockRsrc>>;\n    public removeFileFromLock(ifMatch: string, lockId: string, body: string, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling removeFileFromLock.');\n        }\n        if (lockId === null || lockId === undefined) {\n            throw new Error('Required parameter lockId was null or undefined when calling removeFileFromLock.');\n        }\n        if (body === null || body === undefined) {\n            throw new Error('Required parameter body was null or undefined when calling removeFileFromLock.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<LockRsrc>(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}/removeFile`,\n            body,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update CodeHierarchy by code table name.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param codeHierarchyName The identifier of the CodeHierarchy resource.\n     * @param codeHierarchyRsrc The CodeHierarchy resource containing the new values.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeHierarchyRsrc>;\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeHierarchyRsrc>>;\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeHierarchyRsrc>>;\n    public updateCodeHierarchyResourceByCodeTableName(ifMatch: string, codeHierarchyName: string, codeHierarchyRsrc: CodeHierarchyRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');\n        }\n        if (codeHierarchyName === null || codeHierarchyName === undefined) {\n            throw new Error('Required parameter codeHierarchyName was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');\n        }\n        if (codeHierarchyRsrc === null || codeHierarchyRsrc === undefined) {\n            throw new Error('Required parameter codeHierarchyRsrc was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<CodeHierarchyRsrc>(`${this.configuration.basePath}/codeHierarchies/${encodeURIComponent(String(codeHierarchyName))}`,\n            codeHierarchyRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update CodeTable by code table name.\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param codeTableName The identifier of the CodeTable resource.\n     * @param codeTableRsrc The CodeTable resource containing the new values.\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<CodeTableRsrc>;\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<CodeTableRsrc>>;\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<CodeTableRsrc>>;\n    public updateCodeTableResourceByCodeTableName(ifMatch: string, codeTableName: string, codeTableRsrc: CodeTableRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeTableResourceByCodeTableName.');\n        }\n        if (codeTableName === null || codeTableName === undefined) {\n            throw new Error('Required parameter codeTableName was null or undefined when calling updateCodeTableResourceByCodeTableName.');\n        }\n        if (codeTableRsrc === null || codeTableRsrc === undefined) {\n            throw new Error('Required parameter codeTableRsrc was null or undefined when calling updateCodeTableResourceByCodeTableName.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<CodeTableRsrc>(`${this.configuration.basePath}/codeTables/${encodeURIComponent(String(codeTableName))}`,\n            codeTableRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param documentId The documentId of the Document resource.\n     * @param resource \n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param file \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDocument1(ifMatch: string, documentId: string, resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileDetailsRsrc>;\n    public updateDocument1(ifMatch: string, documentId: string, resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileDetailsRsrc>>;\n    public updateDocument1(ifMatch: string, documentId: string, resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileDetailsRsrc>>;\n    public updateDocument1(ifMatch: string, documentId: string, resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling updateDocument1.');\n        }\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling updateDocument1.');\n        }\n        if (resource === null || resource === undefined) {\n            throw new Error('Required parameter resource was null or undefined when calling updateDocument1.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'multipart/form-data'\n        ];\n\n        const canConsumeForm = this.canConsumeForm(consumes);\n\n        let formParams: { append(param: string, value: any): any; };\n        let useForm = false;\n        let convertFormParamsToString = false;\n        if (useForm) {\n            formParams = new FormData();\n        } else {\n            formParams = new HttpParams({encoder: this.encoder});\n        }\n\n        if (resource !== undefined) {\n            formParams = formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], {type: 'application/json'}) : <any>resource) as any || formParams;\n        }\n        if (file !== undefined) {\n            formParams = formParams.append('file', useForm ? new Blob([JSON.stringify(file)], {type: 'application/json'}) : <any>file) as any || formParams;\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<FileDetailsRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}`,\n            convertFormParamsToString ? formParams.toString() : formParams,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param documentId The checkoutId being updated.\n     * @param documentCheckoutId The documentCheckoutId of the checkout resource.\n     * @param fileCheckoutRsrc The new values in checkoutRsrc\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileCheckoutRsrc>;\n    public updateDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileCheckoutRsrc>>;\n    public updateDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileCheckoutRsrc>>;\n    public updateDocumentCheckout(ifMatch: string, documentId: string, documentCheckoutId: string, fileCheckoutRsrc: FileCheckoutRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling updateDocumentCheckout.');\n        }\n        if (documentId === null || documentId === undefined) {\n            throw new Error('Required parameter documentId was null or undefined when calling updateDocumentCheckout.');\n        }\n        if (documentCheckoutId === null || documentCheckoutId === undefined) {\n            throw new Error('Required parameter documentCheckoutId was null or undefined when calling updateDocumentCheckout.');\n        }\n        if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {\n            throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling updateDocumentCheckout.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<FileCheckoutRsrc>(`${this.configuration.basePath}/documents/${encodeURIComponent(String(documentId))}/checkout/${encodeURIComponent(String(documentCheckoutId))}`,\n            fileCheckoutRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * @param ifMatch The If-Match request-header must match the current eTag of the resource or the request will fail.\n     * @param lockId The lockId being updated.\n     * @param lockRsrc The new values in lock rsrc\n     * @param requestId The unique identity of the request assigned by the originator to help trace the request through the logs.\n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param cacheControl Used to specify directives for caches along the request-response chain\n     * @param pragma An implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the Cache-Control HTTP/1.1 header is not yet present.\n     * @param authorization Contains the credentials to authenticate a user agent with a server.\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateLock(ifMatch: string, lockId: string, lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<LockRsrc>;\n    public updateLock(ifMatch: string, lockId: string, lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<LockRsrc>>;\n    public updateLock(ifMatch: string, lockId: string, lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<LockRsrc>>;\n    public updateLock(ifMatch: string, lockId: string, lockRsrc: LockRsrc, requestId?: string, restVersion?: number, cacheControl?: string, pragma?: string, authorization?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (ifMatch === null || ifMatch === undefined) {\n            throw new Error('Required parameter ifMatch was null or undefined when calling updateLock.');\n        }\n        if (lockId === null || lockId === undefined) {\n            throw new Error('Required parameter lockId was null or undefined when calling updateLock.');\n        }\n        if (lockRsrc === null || lockRsrc === undefined) {\n            throw new Error('Required parameter lockRsrc was null or undefined when calling updateLock.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (requestId !== undefined && requestId !== null) {\n            headers = headers.set('RequestId', String(requestId));\n        }\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n        if (cacheControl !== undefined && cacheControl !== null) {\n            headers = headers.set('Cache-Control', String(cacheControl));\n        }\n        if (pragma !== undefined && pragma !== null) {\n            headers = headers.set('Pragma', String(pragma));\n        }\n        if (authorization !== undefined && authorization !== null) {\n            headers = headers.set('Authorization', String(authorization));\n        }\n        if (ifMatch !== undefined && ifMatch !== null) {\n            headers = headers.set('If-Match', String(ifMatch));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.put<LockRsrc>(`${this.configuration.basePath}/lock/${encodeURIComponent(String(lockId))}`,\n            lockRsrc,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Add Document Resource to the List of Document resources\n     * @param resource \n     * @param restVersion The version of the Rest API supported by the requesting client.\n     * @param file \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public uploadDocument(resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<FileDetailsRsrc>;\n    public uploadDocument(resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<FileDetailsRsrc>>;\n    public uploadDocument(resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<FileDetailsRsrc>>;\n    public uploadDocument(resource: FileDetailsRsrc, restVersion?: number, file?: FormDataBodyPart, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n        if (resource === null || resource === undefined) {\n            throw new Error('Required parameter resource was null or undefined when calling uploadDocument.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (restVersion !== undefined && restVersion !== null) {\n            headers = headers.set('Rest-Version', String(restVersion));\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'multipart/form-data'\n        ];\n\n        const canConsumeForm = this.canConsumeForm(consumes);\n\n        let formParams: { append(param: string, value: any): any; };\n        let useForm = false;\n        let convertFormParamsToString = false;\n        if (useForm) {\n            formParams = new FormData();\n        } else {\n            formParams = new HttpParams({encoder: this.encoder});\n        }\n\n        if (resource !== undefined) {\n            formParams = formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], {type: 'application/json'}) : <any>resource) as any || formParams;\n        }\n        if (file !== undefined) {\n            formParams = formParams.append('file', useForm ? new Blob([JSON.stringify(file)], {type: 'application/json'}) : <any>file) as any || formParams;\n        }\n\n        let responseType: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType = 'text';\n        }\n\n        return this.httpClient.post<FileDetailsRsrc>(`${this.configuration.basePath}/documents`,\n            convertFormParamsToString ? formParams.toString() : formParams,\n            {\n                responseType: <any>responseType,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","export * from './default.service';\nimport { DefaultService } from './default.service';\nexport const APIS = [DefaultService];\n","/**\n * WFDM Document Management API\n * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)\n *\n * The version of the OpenAPI document: 1.2.0-SNAPSHOT\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface HealthCheckResponseRsrc { \n    componentIdentifier?: string;\n    componentName?: string;\n    validationStatus?: HealthCheckResponseRsrc.ValidationStatusEnum;\n    statusDetails?: string;\n    dependencyComponentResponses?: Array<HealthCheckResponseRsrc>;\n    type: string;\n}\nexport namespace HealthCheckResponseRsrc {\n    export type ValidationStatusEnum = 'RED' | 'YELLOW' | 'GREEN';\n    export const ValidationStatusEnum = {\n        RED: 'RED' as ValidationStatusEnum,\n        YELLOW: 'YELLOW' as ValidationStatusEnum,\n        GREEN: 'GREEN' as ValidationStatusEnum\n    };\n}\n\n\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\n\nimport { DefaultService } from './api/default.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: []\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders<ApiModule> {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n"]}