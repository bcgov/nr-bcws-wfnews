import { __values } from 'tslib';
import { InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, NgModule, SkipSelf } from '@angular/core';
import { HttpHeaders, HttpParams, HttpClient } from '@angular/common/http';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * Custom HttpParameterCodec
 * Workaround for https://github.com/angular/angular/issues/18261
 */
var /**
 * Custom HttpParameterCodec
 * Workaround for https://github.com/angular/angular/issues/18261
 */
CustomHttpParameterCodec = /** @class */ (function () {
    function CustomHttpParameterCodec() {
    }
    /**
     * @param {?} k
     * @return {?}
     */
    CustomHttpParameterCodec.prototype.encodeKey = /**
     * @param {?} k
     * @return {?}
     */
    function (k) {
        return encodeURIComponent(k);
    };
    /**
     * @param {?} v
     * @return {?}
     */
    CustomHttpParameterCodec.prototype.encodeValue = /**
     * @param {?} v
     * @return {?}
     */
    function (v) {
        return encodeURIComponent(v);
    };
    /**
     * @param {?} k
     * @return {?}
     */
    CustomHttpParameterCodec.prototype.decodeKey = /**
     * @param {?} k
     * @return {?}
     */
    function (k) {
        return decodeURIComponent(k);
    };
    /**
     * @param {?} v
     * @return {?}
     */
    CustomHttpParameterCodec.prototype.decodeValue = /**
     * @param {?} v
     * @return {?}
     */
    function (v) {
        return decodeURIComponent(v);
    };
    return CustomHttpParameterCodec;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var BASE_PATH = new InjectionToken('basePath');
/** @type {?} */
var COLLECTION_FORMATS = {
    'csv': ',',
    'tsv': '   ',
    'ssv': ' ',
    'pipes': '|'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ConfigurationParameters() { }
if (false) {
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.apiKeys;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.username;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.password;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.accessToken;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.basePath;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.withCredentials;
    /** @type {?|undefined} */
    ConfigurationParameters.prototype.encoder;
}
var Configuration = /** @class */ (function () {
    function Configuration(configurationParameters) {
        if (configurationParameters === void 0) { configurationParameters = {}; }
        this.apiKeys = configurationParameters.apiKeys;
        this.username = configurationParameters.username;
        this.password = configurationParameters.password;
        this.accessToken = configurationParameters.accessToken;
        this.basePath = configurationParameters.basePath;
        this.withCredentials = configurationParameters.withCredentials;
        this.encoder = configurationParameters.encoder;
    }
    /**
     * Select the correct content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param contentTypes - the array of content types that are available for selection
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    /**
     * Select the correct content-type to use for a request.
     * Uses {\@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param {?} contentTypes - the array of content types that are available for selection
     * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
     */
    Configuration.prototype.selectHeaderContentType = /**
     * Select the correct content-type to use for a request.
     * Uses {\@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param {?} contentTypes - the array of content types that are available for selection
     * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
     */
    function (contentTypes) {
        var _this = this;
        if (contentTypes.length === 0) {
            return undefined;
        }
        /** @type {?} */
        var type = contentTypes.find(function (x) { return _this.isJsonMime(x); });
        if (type === undefined) {
            return contentTypes[0];
        }
        return type;
    };
    /**
     * Select the correct accept content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param accepts - the array of content types that are available for selection.
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    /**
     * Select the correct accept content-type to use for a request.
     * Uses {\@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param {?} accepts - the array of content types that are available for selection.
     * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
     */
    Configuration.prototype.selectHeaderAccept = /**
     * Select the correct accept content-type to use for a request.
     * Uses {\@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param {?} accepts - the array of content types that are available for selection.
     * @return {?} the selected content-type or <code>undefined</code> if no selection could be made.
     */
    function (accepts) {
        var _this = this;
        if (accepts.length === 0) {
            return undefined;
        }
        /** @type {?} */
        var type = accepts.find(function (x) { return _this.isJsonMime(x); });
        if (type === undefined) {
            return accepts[0];
        }
        return type;
    };
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param {?} mime - MIME (Multipurpose Internet Mail Extensions)
     * @return {?} True if the given MIME is JSON, false otherwise.
     */
    Configuration.prototype.isJsonMime = /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param {?} mime - MIME (Multipurpose Internet Mail Extensions)
     * @return {?} True if the given MIME is JSON, false otherwise.
     */
    function (mime) {
        /** @type {?} */
        var jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    };
    return Configuration;
}());
if (false) {
    /** @type {?} */
    Configuration.prototype.apiKeys;
    /** @type {?} */
    Configuration.prototype.username;
    /** @type {?} */
    Configuration.prototype.password;
    /** @type {?} */
    Configuration.prototype.accessToken;
    /** @type {?} */
    Configuration.prototype.basePath;
    /** @type {?} */
    Configuration.prototype.withCredentials;
    /** @type {?} */
    Configuration.prototype.encoder;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var DefaultService = /** @class */ (function () {
    function DefaultService(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = 'http://localhost';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    /**
     * @param {?} consumes string[] mime-types
     * @return {?} true: consumes contains 'multipart/form-data', false: otherwise
     */
    DefaultService.prototype.canConsumeForm = /**
     * @param {?} consumes string[] mime-types
     * @return {?} true: consumes contains 'multipart/form-data', false: otherwise
     */
    function (consumes) {
        var e_1, _a;
        /** @type {?} */
        var form = 'multipart/form-data';
        try {
            for (var consumes_1 = __values(consumes), consumes_1_1 = consumes_1.next(); !consumes_1_1.done; consumes_1_1 = consumes_1.next()) {
                var consume = consumes_1_1.value;
                if (form === consume) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (consumes_1_1 && !consumes_1_1.done && (_a = consumes_1.return)) _a.call(consumes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    /**
     * @param {?} httpParams
     * @param {?} value
     * @param {?=} key
     * @return {?}
     */
    DefaultService.prototype.addToHttpParams = /**
     * @param {?} httpParams
     * @param {?} value
     * @param {?=} key
     * @return {?}
     */
    function (httpParams, value, key) {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        }
        else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    };
    /**
     * @param {?} httpParams
     * @param {?=} value
     * @param {?=} key
     * @return {?}
     */
    DefaultService.prototype.addToHttpParamsRecursive = /**
     * @param {?} httpParams
     * @param {?=} value
     * @param {?=} key
     * @return {?}
     */
    function (httpParams, value, key) {
        var _this = this;
        if (value == null) {
            return httpParams;
        }
        if (typeof value === "object") {
            if (Array.isArray(value)) {
                ((/** @type {?} */ (value))).forEach(function (elem) { return httpParams = _this.addToHttpParamsRecursive(httpParams, elem, key); });
            }
            else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, ((/** @type {?} */ (value))).toISOString().substr(0, 10));
                }
                else {
                    throw Error("key may not be null if value is Date");
                }
            }
            else {
                Object.keys(value).forEach(function (k) { return httpParams = _this.addToHttpParamsRecursive(httpParams, value[k], key != null ? key + "." + k : k); });
            }
        }
        else if (key != null) {
            httpParams = httpParams.append(key, value);
        }
        else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    };
    /**
     * @param {?} documentId
     * @param {?} fileCheckoutRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.addDocumentCheckout = /**
     * @param {?} documentId
     * @param {?} fileCheckoutRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (documentId, fileCheckoutRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling addDocumentCheckout.');
        }
        if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {
            throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling addDocumentCheckout.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout", fileCheckoutRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} requestBody
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.addFilesToLock = /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} requestBody
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, lockId, requestBody, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling addFilesToLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling addFilesToLock.');
        }
        if (requestBody === null || requestBody === undefined) {
            throw new Error('Required parameter requestBody was null or undefined when calling addFilesToLock.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)) + "/addFile", requestBody, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} lockRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.addLock = /**
     * @param {?} lockRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (lockRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (lockRsrc === null || lockRsrc === undefined) {
            throw new Error('Required parameter lockRsrc was null or undefined when calling addLock.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(this.configuration.basePath + "/lock", lockRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} targetFilePath
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.copyDocument = /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} targetFilePath
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, documentId, restVersion, targetFilePath, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling copyDocument.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling copyDocument.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (targetFilePath !== undefined && targetFilePath !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (targetFilePath)), 'targetFilePath');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/copy", null, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} recursiveInd
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.deleteDocumentByDocumentID = /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} recursiveInd
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, documentId, restVersion, recursiveInd, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentByDocumentID.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentByDocumentID.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (recursiveInd !== undefined && recursiveInd !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursiveInd)), 'recursiveInd');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.delete(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)), {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.deleteDocumentCheckout = /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, documentId, documentCheckoutId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling deleteDocumentCheckout.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling deleteDocumentCheckout.');
        }
        if (documentCheckoutId === null || documentCheckoutId === undefined) {
            throw new Error('Required parameter documentCheckoutId was null or undefined when calling deleteDocumentCheckout.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.delete(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout/" + encodeURIComponent(String(documentCheckoutId)), {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.deleteLock = /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, lockId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling deleteLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling deleteLock.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.delete(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)), {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} codeHierarchyName
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getCodeHierarchyListResource = /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} codeHierarchyName
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, codeHierarchyName, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        if (codeHierarchyName !== undefined && codeHierarchyName !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (codeHierarchyName)), 'codeHierarchyName');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/codeHierarchies", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} codeHierarchyName
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getCodeHierarchyResourceByCodeTableName = /**
     * @param {?} codeHierarchyName
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (codeHierarchyName, requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (codeHierarchyName === null || codeHierarchyName === undefined) {
            throw new Error('Required parameter codeHierarchyName was null or undefined when calling getCodeHierarchyResourceByCodeTableName.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/codeHierarchies/" + encodeURIComponent(String(codeHierarchyName)), {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} codeTableName
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getCodeTableListResource = /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} codeTableName
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, codeTableName, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        if (codeTableName !== undefined && codeTableName !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (codeTableName)), 'codeTableName');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/codeTables", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} codeTableName
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getCodeTableResourceByCodeTableName = /**
     * @param {?} codeTableName
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} effectiveAsOfDate
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (codeTableName, requestId, restVersion, cacheControl, pragma, authorization, effectiveAsOfDate, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (codeTableName === null || codeTableName === undefined) {
            throw new Error('Required parameter codeTableName was null or undefined when calling getCodeTableResourceByCodeTableName.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (effectiveAsOfDate !== undefined && effectiveAsOfDate !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (effectiveAsOfDate)), 'effectiveAsOfDate');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/codeTables/" + encodeURIComponent(String(codeTableName)), {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getDocumentById = /**
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (documentId, restVersion, cacheControl, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentById.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)), {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getDocumentCheckout = /**
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (documentId, documentCheckoutId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckout.');
        }
        if (documentCheckoutId === null || documentCheckoutId === undefined) {
            throw new Error('Required parameter documentCheckoutId was null or undefined when calling getDocumentCheckout.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout/" + encodeURIComponent(String(documentCheckoutId)), {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} documentId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getDocumentCheckoutList = /**
     * @param {?} documentId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (documentId, requestId, restVersion, cacheControl, pragma, authorization, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentCheckoutList.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} versionNumber
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getDocumentFileBytesById = /**
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} versionNumber
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (documentId, restVersion, versionNumber, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentFileBytesById.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (versionNumber !== undefined && versionNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (versionNumber)), 'versionNumber');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                '*/*'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/bytes", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} parentId
     * @param {?=} recursive
     * @param {?=} lockId
     * @param {?=} metadata
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getDocumentList = /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} parentId
     * @param {?=} recursive
     * @param {?=} lockId
     * @param {?=} metadata
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (requestId, restVersion, cacheControl, pragma, authorization, parentId, recursive, lockId, metadata, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
        var _this = this;
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (parentId !== undefined && parentId !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (parentId)), 'parentId');
        }
        if (recursive !== undefined && recursive !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursive)), 'recursive');
        }
        if (lockId !== undefined && lockId !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (lockId)), 'lockId');
        }
        if (metadata) {
            metadata.forEach(function (element) {
                queryParameters = _this.addToHttpParams(queryParameters, (/** @type {?} */ (element)), 'metadata');
            });
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/documents", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} documentId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getDocumentLock = /**
     * @param {?} documentId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (documentId, requestId, restVersion, cacheControl, pragma, authorization, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling getDocumentLock.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/fileLock", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} searchText
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getListOfLocks = /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} searchText
     * @param {?=} pageNumber
     * @param {?=} pageRowCount
     * @param {?=} orderBy
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (requestId, restVersion, cacheControl, pragma, authorization, searchText, pageNumber, pageRowCount, orderBy, observe, reportProgress, options) {
        var _this = this;
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (searchText) {
            searchText.forEach(function (element) {
                queryParameters = _this.addToHttpParams(queryParameters, (/** @type {?} */ (element)), 'searchText');
            });
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageNumber)), 'pageNumber');
        }
        if (pageRowCount !== undefined && pageRowCount !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (pageRowCount)), 'pageRowCount');
        }
        if (orderBy !== undefined && orderBy !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (orderBy)), 'orderBy');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/lock", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} lockId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getLock = /**
     * @param {?} lockId
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (lockId, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling getLock.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)), {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getSwaggerDocument = /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/openapi.json", {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.getTopLevelResources = /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/", {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} newFilePath
     * @param {?=} recursiveInd
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.moveDocument = /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?=} restVersion
     * @param {?=} newFilePath
     * @param {?=} recursiveInd
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, documentId, restVersion, newFilePath, recursiveInd, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling moveDocument.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling moveDocument.');
        }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (newFilePath !== undefined && newFilePath !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (newFilePath)), 'newFilePath');
        }
        if (recursiveInd !== undefined && recursiveInd !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (recursiveInd)), 'recursiveInd');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/move", null, {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} callstack
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.queryTheHealthOfTheService = /**
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} callstack
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (requestId, restVersion, cacheControl, pragma, authorization, callstack, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        /** @type {?} */
        var queryParameters = new HttpParams({ encoder: this.encoder });
        if (callstack !== undefined && callstack !== null) {
            queryParameters = this.addToHttpParams(queryParameters, (/** @type {?} */ (callstack)), 'callstack');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.get(this.configuration.basePath + "/checkHealth", {
            params: queryParameters,
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} body
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.removeFileFromLock = /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} body
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, lockId, body, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling removeFileFromLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling removeFileFromLock.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling removeFileFromLock.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)) + "/removeFile", body, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} codeHierarchyName
     * @param {?} codeHierarchyRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.updateCodeHierarchyResourceByCodeTableName = /**
     * @param {?} ifMatch
     * @param {?} codeHierarchyName
     * @param {?} codeHierarchyRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, codeHierarchyName, codeHierarchyRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
        }
        if (codeHierarchyName === null || codeHierarchyName === undefined) {
            throw new Error('Required parameter codeHierarchyName was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
        }
        if (codeHierarchyRsrc === null || codeHierarchyRsrc === undefined) {
            throw new Error('Required parameter codeHierarchyRsrc was null or undefined when calling updateCodeHierarchyResourceByCodeTableName.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(this.configuration.basePath + "/codeHierarchies/" + encodeURIComponent(String(codeHierarchyName)), codeHierarchyRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} codeTableName
     * @param {?} codeTableRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.updateCodeTableResourceByCodeTableName = /**
     * @param {?} ifMatch
     * @param {?} codeTableName
     * @param {?} codeTableRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, codeTableName, codeTableRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateCodeTableResourceByCodeTableName.');
        }
        if (codeTableName === null || codeTableName === undefined) {
            throw new Error('Required parameter codeTableName was null or undefined when calling updateCodeTableResourceByCodeTableName.');
        }
        if (codeTableRsrc === null || codeTableRsrc === undefined) {
            throw new Error('Required parameter codeTableRsrc was null or undefined when calling updateCodeTableResourceByCodeTableName.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(this.configuration.basePath + "/codeTables/" + encodeURIComponent(String(codeTableName)), codeTableRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} resource
     * @param {?=} restVersion
     * @param {?=} file
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.updateDocument1 = /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} resource
     * @param {?=} restVersion
     * @param {?=} file
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, documentId, resource, restVersion, file, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateDocument1.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling updateDocument1.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling updateDocument1.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'multipart/form-data'
        ];
        /** @type {?} */
        var canConsumeForm = this.canConsumeForm(consumes);
        /** @type {?} */
        var formParams;
        /** @type {?} */
        var useForm = false;
        /** @type {?} */
        var convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: this.encoder });
        }
        if (resource !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], { type: 'application/json' }) : (/** @type {?} */ (resource))))) || formParams;
        }
        if (file !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('file', useForm ? new Blob([JSON.stringify(file)], { type: 'application/json' }) : (/** @type {?} */ (file))))) || formParams;
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)), convertFormParamsToString ? formParams.toString() : formParams, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?} fileCheckoutRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.updateDocumentCheckout = /**
     * @param {?} ifMatch
     * @param {?} documentId
     * @param {?} documentCheckoutId
     * @param {?} fileCheckoutRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, documentId, documentCheckoutId, fileCheckoutRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateDocumentCheckout.');
        }
        if (documentId === null || documentId === undefined) {
            throw new Error('Required parameter documentId was null or undefined when calling updateDocumentCheckout.');
        }
        if (documentCheckoutId === null || documentCheckoutId === undefined) {
            throw new Error('Required parameter documentCheckoutId was null or undefined when calling updateDocumentCheckout.');
        }
        if (fileCheckoutRsrc === null || fileCheckoutRsrc === undefined) {
            throw new Error('Required parameter fileCheckoutRsrc was null or undefined when calling updateDocumentCheckout.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(this.configuration.basePath + "/documents/" + encodeURIComponent(String(documentId)) + "/checkout/" + encodeURIComponent(String(documentCheckoutId)), fileCheckoutRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} lockRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.updateLock = /**
     * @param {?} ifMatch
     * @param {?} lockId
     * @param {?} lockRsrc
     * @param {?=} requestId
     * @param {?=} restVersion
     * @param {?=} cacheControl
     * @param {?=} pragma
     * @param {?=} authorization
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (ifMatch, lockId, lockRsrc, requestId, restVersion, cacheControl, pragma, authorization, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (ifMatch === null || ifMatch === undefined) {
            throw new Error('Required parameter ifMatch was null or undefined when calling updateLock.');
        }
        if (lockId === null || lockId === undefined) {
            throw new Error('Required parameter lockId was null or undefined when calling updateLock.');
        }
        if (lockRsrc === null || lockRsrc === undefined) {
            throw new Error('Required parameter lockRsrc was null or undefined when calling updateLock.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (requestId !== undefined && requestId !== null) {
            headers = headers.set('RequestId', String(requestId));
        }
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        if (cacheControl !== undefined && cacheControl !== null) {
            headers = headers.set('Cache-Control', String(cacheControl));
        }
        if (pragma !== undefined && pragma !== null) {
            headers = headers.set('Pragma', String(pragma));
        }
        if (authorization !== undefined && authorization !== null) {
            headers = headers.set('Authorization', String(authorization));
        }
        if (ifMatch !== undefined && ifMatch !== null) {
            headers = headers.set('If-Match', String(ifMatch));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'application/json',
            'application/xml'
        ];
        /** @type {?} */
        var httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.put(this.configuration.basePath + "/lock/" + encodeURIComponent(String(lockId)), lockRsrc, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    /**
     * @param {?} resource
     * @param {?=} restVersion
     * @param {?=} file
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    DefaultService.prototype.uploadDocument = /**
     * @param {?} resource
     * @param {?=} restVersion
     * @param {?=} file
     * @param {?=} observe
     * @param {?=} reportProgress
     * @param {?=} options
     * @return {?}
     */
    function (resource, restVersion, file, observe, reportProgress, options) {
        if (observe === void 0) { observe = 'body'; }
        if (reportProgress === void 0) { reportProgress = false; }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling uploadDocument.');
        }
        /** @type {?} */
        var headers = this.defaultHeaders;
        if (restVersion !== undefined && restVersion !== null) {
            headers = headers.set('Rest-Version', String(restVersion));
        }
        /** @type {?} */
        var httpHeaderAcceptSelected = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            /** @type {?} */
            var httpHeaderAccepts = [
                'application/json',
                'application/xml'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        /** @type {?} */
        var consumes = [
            'multipart/form-data'
        ];
        /** @type {?} */
        var canConsumeForm = this.canConsumeForm(consumes);
        /** @type {?} */
        var formParams;
        /** @type {?} */
        var useForm = false;
        /** @type {?} */
        var convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: this.encoder });
        }
        if (resource !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('resource', useForm ? new Blob([JSON.stringify(resource)], { type: 'application/json' }) : (/** @type {?} */ (resource))))) || formParams;
        }
        if (file !== undefined) {
            formParams = (/** @type {?} */ (formParams.append('file', useForm ? new Blob([JSON.stringify(file)], { type: 'application/json' }) : (/** @type {?} */ (file))))) || formParams;
        }
        /** @type {?} */
        var responseType = 'json';
        if (httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }
        return this.httpClient.post(this.configuration.basePath + "/documents", convertFormParamsToString ? formParams.toString() : formParams, {
            responseType: (/** @type {?} */ (responseType)),
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    };
    DefaultService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    DefaultService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [BASE_PATH,] }] },
        { type: Configuration, decorators: [{ type: Optional }] }
    ]; };
    /** @nocollapse */ DefaultService.ɵprov = ɵɵdefineInjectable({ factory: function DefaultService_Factory() { return new DefaultService(ɵɵinject(HttpClient), ɵɵinject(BASE_PATH, 8), ɵɵinject(Configuration, 8)); }, token: DefaultService, providedIn: "root" });
    return DefaultService;
}());
if (false) {
    /** @type {?} */
    DefaultService.prototype.basePath;
    /** @type {?} */
    DefaultService.prototype.defaultHeaders;
    /** @type {?} */
    DefaultService.prototype.configuration;
    /** @type {?} */
    DefaultService.prototype.encoder;
    /** @type {?} */
    DefaultService.prototype.httpClient;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/** @type {?} */
var APIS = [DefaultService];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function BodyPart() { }
if (false) {
    /** @type {?|undefined} */
    BodyPart.prototype.contentDisposition;
    /** @type {?|undefined} */
    BodyPart.prototype.entity;
    /** @type {?|undefined} */
    BodyPart.prototype.headers;
    /** @type {?|undefined} */
    BodyPart.prototype.mediaType;
    /** @type {?|undefined} */
    BodyPart.prototype.messageBodyWorkers;
    /** @type {?|undefined} */
    BodyPart.prototype.parent;
    /** @type {?|undefined} */
    BodyPart.prototype.providers;
    /** @type {?|undefined} */
    BodyPart.prototype.parameterizedHeaders;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function BodyPartMediaType() { }
if (false) {
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.type;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.subtype;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.parameters;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.wildcardType;
    /** @type {?|undefined} */
    BodyPartMediaType.prototype.wildcardSubtype;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeHierarchyListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeHierarchyListRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeHierarchyListRsrc.prototype.codeHierarchyList;
    /** @type {?|undefined} */
    CodeHierarchyListRsrc.prototype.etag;
    /** @type {?} */
    CodeHierarchyListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeHierarchyRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.codeHierarchyName;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.lowerCodeTableName;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.upperCodeTableName;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.hierarchy;
    /** @type {?|undefined} */
    CodeHierarchyRsrc.prototype.etag;
    /** @type {?} */
    CodeHierarchyRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function CodeRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeRsrc.prototype.code;
    /** @type {?|undefined} */
    CodeRsrc.prototype.description;
    /** @type {?|undefined} */
    CodeRsrc.prototype.displayOrder;
    /** @type {?|undefined} */
    CodeRsrc.prototype.effectiveDate;
    /** @type {?|undefined} */
    CodeRsrc.prototype.expiryDate;
    /** @type {?} */
    CodeRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeTableListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeTableListRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeTableListRsrc.prototype.codeTableList;
    /** @type {?|undefined} */
    CodeTableListRsrc.prototype.etag;
    /** @type {?} */
    CodeTableListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CodeTableRsrc() { }
if (false) {
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.links;
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.codeTableName;
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.codes;
    /** @type {?|undefined} */
    CodeTableRsrc.prototype.etag;
    /** @type {?} */
    CodeTableRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function ContentDisposition() { }
if (false) {
    /** @type {?|undefined} */
    ContentDisposition.prototype.type;
    /** @type {?|undefined} */
    ContentDisposition.prototype.parameters;
    /** @type {?|undefined} */
    ContentDisposition.prototype.fileName;
    /** @type {?|undefined} */
    ContentDisposition.prototype.creationDate;
    /** @type {?|undefined} */
    ContentDisposition.prototype.modificationDate;
    /** @type {?|undefined} */
    ContentDisposition.prototype.readDate;
    /** @type {?|undefined} */
    ContentDisposition.prototype.size;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function EndpointsRsrc() { }
if (false) {
    /** @type {?|undefined} */
    EndpointsRsrc.prototype.links;
    /** @type {?|undefined} */
    EndpointsRsrc.prototype.releaseVersion;
    /** @type {?|undefined} */
    EndpointsRsrc.prototype.etag;
    /** @type {?} */
    EndpointsRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileCheckoutRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.links;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.fileCheckoutId;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.file;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.checkOutComment;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.checkInComment;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.validStartTimestamp;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.validEndTimestamp;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.displayLabel;
    /** @type {?|undefined} */
    FileCheckoutRsrc.prototype.etag;
    /** @type {?} */
    FileCheckoutRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileDetailsRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.links;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileId;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.filePath;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lastUpdatedTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.versionNumber;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileExtension;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileType;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.mimeType;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileSize;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.retention;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.security;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.metadata;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.versions;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.uploadedBy;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.uploadedOnTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lastUpdatedBy;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lastUpdatedByGuid;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.parent;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.validStartTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.validEndTimestamp;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.fileCheckout;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.lockedInd;
    /** @type {?|undefined} */
    FileDetailsRsrc.prototype.etag;
    /** @type {?} */
    FileDetailsRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileListRsrc.prototype.links;
    /** @type {?|undefined} */
    FileListRsrc.prototype.pageNumber;
    /** @type {?|undefined} */
    FileListRsrc.prototype.pageRowCount;
    /** @type {?|undefined} */
    FileListRsrc.prototype.totalRowCount;
    /** @type {?|undefined} */
    FileListRsrc.prototype.totalPageCount;
    /** @type {?|undefined} */
    FileListRsrc.prototype.collection;
    /** @type {?|undefined} */
    FileListRsrc.prototype.etag;
    /** @type {?} */
    FileListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function FileMetadataRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileMetadataRsrc.prototype.metadataName;
    /** @type {?|undefined} */
    FileMetadataRsrc.prototype.metadataValue;
    /** @type {?|undefined} */
    FileMetadataRsrc.prototype.etag;
    /** @type {?} */
    FileMetadataRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileRsrc.prototype.links;
    /** @type {?|undefined} */
    FileRsrc.prototype.fileId;
    /** @type {?|undefined} */
    FileRsrc.prototype.filePath;
    /** @type {?|undefined} */
    FileRsrc.prototype.lastUpdatedTimestamp;
    /** @type {?|undefined} */
    FileRsrc.prototype.etag;
    /** @type {?} */
    FileRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FileSecurityRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.grantorAccessInd;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.readAccessInd;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.writeAccessInd;
    /** @type {?|undefined} */
    FileSecurityRsrc.prototype.etag;
    /** @type {?} */
    FileSecurityRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function FileVersionRsrc() { }
if (false) {
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.versionNumber;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.fileSize;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.uploadedById;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.uploadedOnTimestamp;
    /** @type {?|undefined} */
    FileVersionRsrc.prototype.etag;
    /** @type {?} */
    FileVersionRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FormDataBodyPart() { }
if (false) {
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.contentDisposition;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.entity;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.headers;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.mediaType;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.messageBodyWorkers;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.parent;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.providers;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.simple;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.formDataContentDisposition;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.name;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.value;
    /** @type {?|undefined} */
    FormDataBodyPart.prototype.parameterizedHeaders;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function FormDataContentDisposition() { }
if (false) {
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.type;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.parameters;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.fileName;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.creationDate;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.modificationDate;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.readDate;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.size;
    /** @type {?|undefined} */
    FormDataContentDisposition.prototype.name;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// WARNING: interface has both a type and a value, skipping emit
var HealthCheckResponseRsrc;
(function (HealthCheckResponseRsrc) {
    HealthCheckResponseRsrc.ValidationStatusEnum = {
        RED: (/** @type {?} */ ('RED')),
        YELLOW: (/** @type {?} */ ('YELLOW')),
        GREEN: (/** @type {?} */ ('GREEN'))
    };
})(HealthCheckResponseRsrc || (HealthCheckResponseRsrc = {}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function Hierarchy() { }
if (false) {
    /** @type {?|undefined} */
    Hierarchy.prototype.lowerCode;
    /** @type {?|undefined} */
    Hierarchy.prototype.upperCode;
    /** @type {?|undefined} */
    Hierarchy.prototype.effectiveDate;
    /** @type {?|undefined} */
    Hierarchy.prototype.expiryDate;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function InlineObject() { }
if (false) {
    /** @type {?} */
    InlineObject.prototype.resource;
    /** @type {?|undefined} */
    InlineObject.prototype.file;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function InlineObject1() { }
if (false) {
    /** @type {?} */
    InlineObject1.prototype.resource;
    /** @type {?|undefined} */
    InlineObject1.prototype.file;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function LockListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    LockListRsrc.prototype.links;
    /** @type {?|undefined} */
    LockListRsrc.prototype.pageNumber;
    /** @type {?|undefined} */
    LockListRsrc.prototype.pageRowCount;
    /** @type {?|undefined} */
    LockListRsrc.prototype.totalRowCount;
    /** @type {?|undefined} */
    LockListRsrc.prototype.totalPageCount;
    /** @type {?|undefined} */
    LockListRsrc.prototype.collection;
    /** @type {?|undefined} */
    LockListRsrc.prototype.etag;
    /** @type {?} */
    LockListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function LockRsrc() { }
if (false) {
    /** @type {?|undefined} */
    LockRsrc.prototype.links;
    /** @type {?|undefined} */
    LockRsrc.prototype.lockId;
    /** @type {?|undefined} */
    LockRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    LockRsrc.prototype.lockReason;
    /** @type {?|undefined} */
    LockRsrc.prototype.validStartTimestamp;
    /** @type {?|undefined} */
    LockRsrc.prototype.validEndTimestamp;
    /** @type {?|undefined} */
    LockRsrc.prototype.lockedFiles;
    /** @type {?|undefined} */
    LockRsrc.prototype.etag;
    /** @type {?} */
    LockRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MessageListRsrc() { }
if (false) {
    /** @type {?|undefined} */
    MessageListRsrc.prototype.messages;
    /** @type {?|undefined} */
    MessageListRsrc.prototype.etag;
    /** @type {?} */
    MessageListRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function MessageRsrc() { }
if (false) {
    /** @type {?|undefined} */
    MessageRsrc.prototype.path;
    /** @type {?|undefined} */
    MessageRsrc.prototype.message;
    /** @type {?|undefined} */
    MessageRsrc.prototype.messageTemplate;
    /** @type {?|undefined} */
    MessageRsrc.prototype.messageArguments;
    /** @type {?} */
    MessageRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @record
 */
function MultiPart() { }
if (false) {
    /** @type {?|undefined} */
    MultiPart.prototype.contentDisposition;
    /** @type {?|undefined} */
    MultiPart.prototype.entity;
    /** @type {?|undefined} */
    MultiPart.prototype.headers;
    /** @type {?|undefined} */
    MultiPart.prototype.mediaType;
    /** @type {?|undefined} */
    MultiPart.prototype.messageBodyWorkers;
    /** @type {?|undefined} */
    MultiPart.prototype.parent;
    /** @type {?|undefined} */
    MultiPart.prototype.providers;
    /** @type {?|undefined} */
    MultiPart.prototype.bodyParts;
    /** @type {?|undefined} */
    MultiPart.prototype.parameterizedHeaders;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function ParameterizedHeader() { }
if (false) {
    /** @type {?|undefined} */
    ParameterizedHeader.prototype.value;
    /** @type {?|undefined} */
    ParameterizedHeader.prototype.parameters;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function RelLink() { }
if (false) {
    /** @type {?|undefined} */
    RelLink.prototype.rel;
    /** @type {?|undefined} */
    RelLink.prototype.href;
    /** @type {?|undefined} */
    RelLink.prototype.method;
    /** @type {?|undefined} */
    RelLink.prototype.etag;
    /** @type {?} */
    RelLink.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * WFDM Document Management API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 * @record
 */
function SecurityKeyRsrc() { }
if (false) {
    /** @type {?|undefined} */
    SecurityKeyRsrc.prototype.securityKey;
    /** @type {?|undefined} */
    SecurityKeyRsrc.prototype.displayLabel;
    /** @type {?|undefined} */
    SecurityKeyRsrc.prototype.etag;
    /** @type {?} */
    SecurityKeyRsrc.prototype.type;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
var ApiModule = /** @class */ (function () {
    function ApiModule(parentModule, http) {
        if (parentModule) {
            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
        }
        if (!http) {
            throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
                'See also https://github.com/angular/angular/issues/20575');
        }
    }
    /**
     * @param {?} configurationFactory
     * @return {?}
     */
    ApiModule.forRoot = /**
     * @param {?} configurationFactory
     * @return {?}
     */
    function (configurationFactory) {
        return {
            ngModule: ApiModule,
            providers: [{ provide: Configuration, useFactory: configurationFactory }]
        };
    };
    ApiModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [],
                    exports: [],
                    providers: []
                },] }
    ];
    /** @nocollapse */
    ApiModule.ctorParameters = function () { return [
        { type: ApiModule, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: HttpClient, decorators: [{ type: Optional }] }
    ]; };
    return ApiModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */

export { APIS, ApiModule, BASE_PATH, COLLECTION_FORMATS, Configuration, DefaultService, HealthCheckResponseRsrc };
//# sourceMappingURL=wf1-wfdm-document-management-api.js.map
