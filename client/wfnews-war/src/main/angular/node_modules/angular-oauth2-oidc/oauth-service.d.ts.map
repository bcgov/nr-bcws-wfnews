{"version":3,"file":"oauth-service.d.ts","sources":["oauth-service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { NgZone } from '@angular/core';\r\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\nimport { ValidationHandler } from './token-validation/validation-handler';\r\nimport { UrlHelperService } from './url-helper.service';\r\nimport { OAuthEvent } from './events';\r\nimport { OAuthStorage, LoginOptions, ParsedIdToken } from './types';\r\nimport { AuthConfig } from './auth.config';\r\n/**\r\n * Service for logging in and logging out with\r\n * OIDC and OAuth2. Supports implicit flow and\r\n * password flow.\r\n */\r\nexport declare class OAuthService extends AuthConfig {\r\n    private ngZone;\r\n    private http;\r\n    private config;\r\n    private urlHelper;\r\n    /**\r\n     * The ValidationHandler used to validate received\r\n     * id_tokens.\r\n     */\r\n    tokenValidationHandler: ValidationHandler;\r\n    /**\r\n     * @internal\r\n     * Deprecated:  use property events instead\r\n     */\r\n    discoveryDocumentLoaded: boolean;\r\n    /**\r\n     * @internal\r\n     * Deprecated:  use property events instead\r\n     */\r\n    discoveryDocumentLoaded$: Observable<object>;\r\n    /**\r\n     * Informs about events, like token_received or token_expires.\r\n     * See the string enum EventType for a full list of events.\r\n     */\r\n    events: Observable<OAuthEvent>;\r\n    /**\r\n     * The received (passed around) state, when logging\r\n     * in with implicit flow.\r\n     */\r\n    state?: string;\r\n    private eventsSubject;\r\n    private discoveryDocumentLoadedSubject;\r\n    private silentRefreshPostMessageEventListener;\r\n    private grantTypesSupported;\r\n    private _storage;\r\n    private accessTokenTimeoutSubscription;\r\n    private idTokenTimeoutSubscription;\r\n    private sessionCheckEventListener;\r\n    private jwksUri;\r\n    private sessionCheckTimer;\r\n    private silentRefreshSubject;\r\n    private inImplicitFlow;\r\n    constructor(ngZone: NgZone, http: HttpClient, storage: OAuthStorage, tokenValidationHandler: ValidationHandler, config: AuthConfig, urlHelper: UrlHelperService);\r\n    /**\r\n     * Use this method to configure the service\r\n     * @param config the configuration\r\n     */\r\n    configure(config: AuthConfig): void;\r\n    private configChanged();\r\n    restartSessionChecksIfStillLoggedIn(): void;\r\n    private restartRefreshTimerIfStillLoggedIn();\r\n    private setupSessionCheck();\r\n    /**\r\n     *\r\n     * @param params Additional parameter to pass\r\n     */\r\n    setupAutomaticSilentRefresh(params?: object): void;\r\n    loadDiscoveryDocumentAndTryLogin(options?: LoginOptions): Promise<void>;\r\n    loadDiscoveryDocumentAndLogin(options?: LoginOptions): Promise<boolean>;\r\n    private debug(...args);\r\n    private validateUrlFromDiscoveryDocument(url);\r\n    private validateUrlForHttps(url);\r\n    private validateUrlAgainstIssuer(url);\r\n    private setupRefreshTimer();\r\n    private setupExpirationTimers();\r\n    private setupAccessTokenTimer();\r\n    private setupIdTokenTimer();\r\n    private clearAccessTokenTimer();\r\n    private clearIdTokenTimer();\r\n    private calcTimeout(storedAt, expiration);\r\n    /**\r\n     * DEPRECATED. Use a provider for OAuthStorage instead:\r\n     *\r\n     * { provide: OAuthStorage, useValue: localStorage }\r\n     *\r\n     * Sets a custom storage used to store the received\r\n     * tokens on client side. By default, the browser's\r\n     * sessionStorage is used.\r\n     * @ignore\r\n     *\r\n     * @param storage\r\n     */\r\n    setStorage(storage: OAuthStorage): void;\r\n    /**\r\n     * Loads the discovery document to configure most\r\n     * properties of this service. The url of the discovery\r\n     * document is infered from the issuer's url according\r\n     * to the OpenId Connect spec. To use another url you\r\n     * can pass it to to optional parameter fullUrl.\r\n     *\r\n     * @param fullUrl\r\n     */\r\n    loadDiscoveryDocument(fullUrl?: string): Promise<object>;\r\n    private loadJwks();\r\n    private validateDiscoveryDocument(doc);\r\n    /**\r\n     * Uses password flow to exchange userName and password for an\r\n     * access_token. After receiving the access_token, this method\r\n     * uses it to query the userinfo endpoint in order to get information\r\n     * about the user in question.\r\n     *\r\n     * When using this, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take happen that makes this operation\r\n     * fail.\r\n     *\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\r\n    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName: string, password: string, headers?: HttpHeaders): Promise<object>;\r\n    /**\r\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n     *\r\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take happen that makes this operation\r\n     * fail.\r\n     */\r\n    loadUserProfile(): Promise<object>;\r\n    /**\r\n     * Uses password flow to exchange userName and password for an access_token.\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\r\n    fetchTokenUsingPasswordFlow(userName: string, password: string, headers?: HttpHeaders): Promise<object>;\r\n    /**\r\n     * Refreshes the token using a refresh_token.\r\n     * This does not work for implicit flow, b/c\r\n     * there is no refresh_token in this flow.\r\n     * A solution for this is provided by the\r\n     * method silentRefresh.\r\n     */\r\n    refreshToken(): Promise<object>;\r\n    private removeSilentRefreshEventListener();\r\n    private setupSilentRefreshEventListener();\r\n    /**\r\n     * Performs a silent refresh for implicit flow.\r\n     * Use this method to get a new tokens when/ before\r\n     * the existing tokens expires.\r\n     */\r\n    silentRefresh(params?: object, noPrompt?: boolean): Promise<OAuthEvent>;\r\n    private canPerformSessionCheck();\r\n    private setupSessionCheckEventListener();\r\n    private handleSessionUnchanged();\r\n    private handleSessionChange();\r\n    private waitForSilentRefreshAfterSessionChange();\r\n    private handleSessionError();\r\n    private removeSessionCheckEventListener();\r\n    private initSessionCheck();\r\n    private startSessionCheckTimer();\r\n    private stopSessionCheckTimer();\r\n    private checkSession();\r\n    private createLoginUrl(state?, loginHint?, customRedirectUri?, noPrompt?, params?);\r\n    initImplicitFlowInternal(additionalState?: string, params?: string | object): void;\r\n    /**\r\n     * Starts the implicit flow and redirects to user to\r\n     * the auth servers login url.\r\n     *\r\n     * @param additionalState Optinal state that is passes around.\r\n     *  You find this state in the property ``state`` after ``tryLogin`` logged in the user.\r\n     * @param params Hash with additional parameter. If it is a string, it is used for the\r\n     *               parameter loginHint (for the sake of compatibility with former versions)\r\n     */\r\n    initImplicitFlow(additionalState?: string, params?: string | object): void;\r\n    private callOnTokenReceivedIfExists(options);\r\n    private storeAccessTokenResponse(accessToken, refreshToken, expiresIn, grantedScopes);\r\n    /**\r\n     * Checks whether there are tokens in the hash fragment\r\n     * as a result of the implicit flow. These tokens are\r\n     * parsed, validated and used to sign the user in to the\r\n     * current client.\r\n     *\r\n     * @param options Optinal options.\r\n     */\r\n    tryLogin(options?: LoginOptions): Promise<void>;\r\n    private validateNonceForAccessToken(accessToken, nonceInState);\r\n    protected storeIdToken(idToken: ParsedIdToken): void;\r\n    protected storeSessionState(sessionState: string): void;\r\n    protected getSessionState(): string;\r\n    private handleLoginError(options, parts);\r\n    /**\r\n     * @ignore\r\n     */\r\n    processIdToken(idToken: string, accessToken: string): Promise<ParsedIdToken>;\r\n    /**\r\n     * Returns the received claims about the user.\r\n     */\r\n    getIdentityClaims(): object;\r\n    /**\r\n     * Returns the granted scopes from the server.\r\n     */\r\n    getGrantedScopes(): object;\r\n    /**\r\n     * Returns the current id_token.\r\n     */\r\n    getIdToken(): string;\r\n    private padBase64(base64data);\r\n    /**\r\n     * Returns the current access_token.\r\n     */\r\n    getAccessToken(): string;\r\n    getRefreshToken(): string;\r\n    /**\r\n     * Returns the expiration date of the access_token\r\n     * as milliseconds since 1970.\r\n     */\r\n    getAccessTokenExpiration(): number;\r\n    private getAccessTokenStoredAt();\r\n    private getIdTokenStoredAt();\r\n    /**\r\n     * Returns the expiration date of the id_token\r\n     * as milliseconds since 1970.\r\n     */\r\n    getIdTokenExpiration(): number;\r\n    /**\r\n     * Checkes, whether there is a valid access_token.\r\n     */\r\n    hasValidAccessToken(): boolean;\r\n    /**\r\n     * Checkes, whether there is a valid id_token.\r\n     */\r\n    hasValidIdToken(): boolean;\r\n    /**\r\n     * Returns the auth-header that can be used\r\n     * to transmit the access_token to a service\r\n     */\r\n    authorizationHeader(): string;\r\n    /**\r\n     * Removes all tokens and logs the user out.\r\n     * If a logout url is configured, the user is\r\n     * redirected to it.\r\n     * @param noRedirectToLogoutUrl\r\n     */\r\n    logOut(noRedirectToLogoutUrl?: boolean): void;\r\n    /**\r\n     * @ignore\r\n     */\r\n    createAndSaveNonce(): Promise<string>;\r\n    protected createNonce(): Promise<string>;\r\n    private checkAtHash(params);\r\n    private checkSignature(params);\r\n}\r\n"]}