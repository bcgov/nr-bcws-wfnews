/**
 * Viewport breakpoint
 */
export interface ViewportBreakpoint {
    name: string;
    size: {
        width: number;
        height: number;
    };
}
/**
 * Viewport configuration
 */
export interface ViewportConfiguration {
    context: string;
    breakpoints: ViewportBreakpoint[];
}
/**
 * Viewport callback
 */
export declare type ViewportCallback<T> = (breakpoint: string) => T;
/**
 * Resolve relevant breakpoint range
 *
 * @param breakpoints - Breakpoints
 * @param first - First breakpoint name
 * @param last - Last breakpoint name
 *
 * @return Selected breakpoints
 */
export declare function range(breakpoints: ViewportBreakpoint[], first: string, last?: string): ViewportBreakpoint[];
export declare class Viewport {
    /**
     * Viewport configuration
     */
    config: Readonly<ViewportConfiguration>;
    /**
     * Viewport context
     */
    context: HTMLIFrameElement;
    /**
     * Create viewport resizer
     *
     * @constructor
     *
     * @param config - Viewport configuration
     * @param parent - Initialization context
     */
    constructor(config: ViewportConfiguration, parent: Window);
    /**
     * Load and embed document into viewport
     *
     * @param url - URL of document to load
     *
     * @return Promise resolving with no result
     */
    load(url: string, cb?: () => void): Promise<void>;
    /**
     * Change viewport offset (scroll within iframe)
     *
     * @param x - Horizontal offset
     * @param y - Vertical offset
     */
    offset(x: number, y?: number): void;
    /**
     * Set viewport to width (and height) or breakpoint name
     *
     * @param widthOrBreakpoint - Width in pixels or breakpoint name
     * @param height - Height in pixels
     */
    set(width: number, height?: number): void;
    set(breakpoint: string): void;
    /**
     * Reset viewport
     */
    reset(): void;
    /**
     * Execute a callback for all breakpoints between the first and last given
     *
     * If the callback return value is a Promise, callback invocations will be
     * chained to guarantee sequential execution.
     *
     * @example
     *   viewport.between("mobile", "tablet", name => {
     *     ...
     *   })
     *
     * @param first - First breakpoint name
     * @param last - Last breakpoint name
     * @param cb - Callback to execute after resizing
     *
     * @return Promise resolving with no result
     */
    between<T extends Promise<any>>(first: string, last: string, cb: ViewportCallback<T>): Promise<void>;
    between<T>(first: string, last: string, cb: ViewportCallback<T>): void;
    /**
     * Execute a callback for all breakpoints
     *
     * @example
     *   viewport.each(name => {
     *     ...
     *   })
     *
     * @param cb - Callback to execute after resizing
     *
     * @return Promise resolving with no result
     */
    each<T extends Promise<any>>(cb: ViewportCallback<T>): Promise<void>;
    each<T>(cb: ViewportCallback<T>): void;
    /**
     * Execute a callback starting at the given breakpoint
     *
     * @example
     *   viewport.from("tablet", name => {
     *     ...
     *   })
     *
     * @param first - First breakpoint name
     * @param cb - Callback to execute after resizing
     *
     * @return Promise resolving with no result
     */
    from<T extends Promise<any>>(first: string, cb: ViewportCallback<T>): Promise<void>;
    from<T>(first: string, cb: ViewportCallback<T>): void;
    /**
     * Execute a callback ending at the given breakpoint
     *
     * @example
     *   viewport.to("tablet", name => {
     *     ...
     *   })
     *
     * @param last - Last breakpoint name
     * @param cb - Callback to execute after resizing
     *
     * @return Promise resolving with no result
     */
    to<T extends Promise<any>>(last: string, cb: ViewportCallback<T>): Promise<void>;
    to<T>(last: string, cb: ViewportCallback<T>): void;
}
//# sourceMappingURL=viewport.d.ts.map