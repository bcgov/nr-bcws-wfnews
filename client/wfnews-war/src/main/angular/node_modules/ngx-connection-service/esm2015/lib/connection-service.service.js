/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { EventEmitter, Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { fromEvent, timer } from 'rxjs';
import { debounceTime, delay, retryWhen, startWith, switchMap, tap } from 'rxjs/operators';
import { HttpClient } from '@angular/common/http';
import * as _ from 'lodash';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
/**
 * Instance of this interface is used to report current connection status.
 * @record
 */
export function ConnectionState() { }
if (false) {
    /**
     * "True" if browser has network connection. Determined by Window objects "online" / "offline" events.
     * @type {?}
     */
    ConnectionState.prototype.hasNetworkConnection;
    /**
     * "True" if browser has Internet access. Determined by heartbeat system which periodically makes request to heartbeat Url.
     * @type {?}
     */
    ConnectionState.prototype.hasInternetAccess;
}
/**
 * Instance of this interface could be used to configure "ConnectionService".
 * @record
 */
export function ConnectionServiceOptions() { }
if (false) {
    /**
     * Controls the Internet connectivity heartbeat system. Default value is 'true'.
     * @type {?|undefined}
     */
    ConnectionServiceOptions.prototype.enableHeartbeat;
    /**
     * Url used for checking Internet connectivity, heartbeat system periodically makes "HEAD" requests to this URL to determine Internet
     * connection status. Default value is "//server.test-cors.org".
     * @type {?|undefined}
     */
    ConnectionServiceOptions.prototype.heartbeatUrl;
    /**
     * Callback function to used for executing heartbeat requests. Defaults to HttpClient.request(...) function.
     * @type {?|undefined}
     */
    ConnectionServiceOptions.prototype.heartbeatExecutor;
    /**
     * Interval used to check Internet connectivity specified in milliseconds. Default value is "30000".
     * @type {?|undefined}
     */
    ConnectionServiceOptions.prototype.heartbeatInterval;
    /**
     * Interval used to retry Internet connectivity checks when an error is detected (when no Internet connection). Default value is "1000".
     * @type {?|undefined}
     */
    ConnectionServiceOptions.prototype.heartbeatRetryInterval;
    /**
     * HTTP method used for requesting heartbeat Url. Default is 'head'.
     * @type {?|undefined}
     */
    ConnectionServiceOptions.prototype.requestMethod;
}
/**
 * InjectionToken for specifing ConnectionService options.
 * @type {?}
 */
export const ConnectionServiceOptionsToken = new InjectionToken('ConnectionServiceOptionsToken');
export class ConnectionService {
    /**
     * @param {?} http
     * @param {?} options
     */
    constructor(http, options) {
        this.http = http;
        this.stateChangeEventEmitter = new EventEmitter();
        this.currentState = {
            hasInternetAccess: false,
            hasNetworkConnection: window.navigator.onLine
        };
        this.serviceOptions = _.defaults({}, options, ConnectionService.DEFAULT_OPTIONS, {
            heartbeatExecutor: (/**
             * @return {?}
             */
            () => this.http.request(this.serviceOptions.requestMethod, this.serviceOptions.heartbeatUrl, { responseType: 'text' })),
        });
        this.checkNetworkState();
        this.checkInternetState();
    }
    /**
     * Current ConnectionService options. Notice that changing values of the returned object has not effect on service execution.
     * You should use "updateOptions" function.
     * @return {?}
     */
    get options() {
        return _.clone(this.serviceOptions);
    }
    /**
     * @private
     * @return {?}
     */
    checkInternetState() {
        if (!_.isNil(this.httpSubscription)) {
            this.httpSubscription.unsubscribe();
        }
        if (this.serviceOptions.enableHeartbeat) {
            this.httpSubscription = timer(0, this.serviceOptions.heartbeatInterval)
                .pipe(switchMap((/**
             * @return {?}
             */
            () => this.serviceOptions.heartbeatExecutor(this.serviceOptions))), retryWhen((/**
             * @param {?} errors
             * @return {?}
             */
            errors => errors.pipe(
            // log error message
            tap((/**
             * @param {?} val
             * @return {?}
             */
            val => {
                console.error('Http error:', val);
                this.currentState.hasInternetAccess = false;
                this.emitEvent();
            })), 
            // restart after 5 seconds
            delay(this.serviceOptions.heartbeatRetryInterval)))))
                .subscribe((/**
             * @param {?} result
             * @return {?}
             */
            result => {
                this.currentState.hasInternetAccess = true;
                this.emitEvent();
            }));
        }
        else {
            this.currentState.hasInternetAccess = false;
            this.emitEvent();
        }
    }
    /**
     * @private
     * @return {?}
     */
    checkNetworkState() {
        this.onlineSubscription = fromEvent(window, 'online').subscribe((/**
         * @return {?}
         */
        () => {
            this.currentState.hasNetworkConnection = true;
            this.checkInternetState();
            this.emitEvent();
        }));
        this.offlineSubscription = fromEvent(window, 'offline').subscribe((/**
         * @return {?}
         */
        () => {
            this.currentState.hasNetworkConnection = false;
            this.checkInternetState();
            this.emitEvent();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    emitEvent() {
        this.stateChangeEventEmitter.emit(this.currentState);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        try {
            this.offlineSubscription.unsubscribe();
            this.onlineSubscription.unsubscribe();
            this.httpSubscription.unsubscribe();
        }
        catch (e) {
        }
    }
    /**
     * Monitor Network & Internet connection status by subscribing to this observer. If you set "reportCurrentState" to "false" then
     * function will not report current status of the connections when initially subscribed.
     * @param {?=} reportCurrentState Report current state when initial subscription. Default is "true"
     * @return {?}
     */
    monitor(reportCurrentState = true) {
        return reportCurrentState ?
            this.stateChangeEventEmitter.pipe(debounceTime(300), startWith(this.currentState))
            :
                this.stateChangeEventEmitter.pipe(debounceTime(300));
    }
    /**
     * Update options of the service. You could specify partial options object. Values that are not specified will use default / previous
     * option values.
     * @param {?} options Partial option values.
     * @return {?}
     */
    updateOptions(options) {
        this.serviceOptions = _.defaults({}, options, this.serviceOptions);
        this.checkInternetState();
    }
}
ConnectionService.DEFAULT_OPTIONS = {
    enableHeartbeat: true,
    heartbeatUrl: '//server.test-cors.org/server?id=' + Date.now() + '&enable=true&status=200&credentials=false',
    heartbeatInterval: 30000,
    heartbeatRetryInterval: 1000,
    requestMethod: 'head',
};
ConnectionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ConnectionService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Inject, args: [ConnectionServiceOptionsToken,] }, { type: Optional }] }
];
/** @nocollapse */ ConnectionService.ngInjectableDef = i0.defineInjectable({ factory: function ConnectionService_Factory() { return new ConnectionService(i0.inject(i1.HttpClient), i0.inject(ConnectionServiceOptionsToken, 8)); }, token: ConnectionService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ConnectionService.DEFAULT_OPTIONS;
    /**
     * @type {?}
     * @private
     */
    ConnectionService.prototype.stateChangeEventEmitter;
    /**
     * @type {?}
     * @private
     */
    ConnectionService.prototype.currentState;
    /**
     * @type {?}
     * @private
     */
    ConnectionService.prototype.offlineSubscription;
    /**
     * @type {?}
     * @private
     */
    ConnectionService.prototype.onlineSubscription;
    /**
     * @type {?}
     * @private
     */
    ConnectionService.prototype.httpSubscription;
    /**
     * @type {?}
     * @private
     */
    ConnectionService.prototype.serviceOptions;
    /**
     * @type {?}
     * @private
     */
    ConnectionService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdGlvbi1zZXJ2aWNlLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtY29ubmVjdGlvbi1zZXJ2aWNlLyIsInNvdXJjZXMiOlsibGliL2Nvbm5lY3Rpb24tc2VydmljZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFhLFFBQVEsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNwRyxPQUFPLEVBQUMsU0FBUyxFQUE0QixLQUFLLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDaEUsT0FBTyxFQUFDLFlBQVksRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDekYsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ2hELE9BQU8sS0FBSyxDQUFDLE1BQU0sUUFBUSxDQUFDOzs7Ozs7O0FBSzVCLHFDQVNDOzs7Ozs7SUFMQywrQ0FBOEI7Ozs7O0lBSTlCLDRDQUEyQjs7Ozs7O0FBTTdCLDhDQTJCQzs7Ozs7O0lBdkJDLG1EQUEwQjs7Ozs7O0lBSzFCLGdEQUFzQjs7Ozs7SUFJdEIscURBQTRFOzs7OztJQUk1RSxxREFBMkI7Ozs7O0lBSTNCLDBEQUFnQzs7Ozs7SUFJaEMsaURBQW9EOzs7Ozs7QUFPdEQsTUFBTSxPQUFPLDZCQUE2QixHQUE2QyxJQUFJLGNBQWMsQ0FBQywrQkFBK0IsQ0FBQztBQUsxSSxNQUFNLE9BQU8saUJBQWlCOzs7OztJQTRCNUIsWUFBb0IsSUFBZ0IsRUFBcUQsT0FBaUM7UUFBdEcsU0FBSSxHQUFKLElBQUksQ0FBWTtRQW5CNUIsNEJBQXVCLEdBQUcsSUFBSSxZQUFZLEVBQW1CLENBQUM7UUFFOUQsaUJBQVksR0FBb0I7WUFDdEMsaUJBQWlCLEVBQUUsS0FBSztZQUN4QixvQkFBb0IsRUFBRSxNQUFNLENB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Q0FDdEIsQ0FBQzs7WUFWSCxVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7Ozs7WUF4RE8sVUFBVTs0Q0FxRnVCLE1BQU0sU0FBQyw2QkFBNkIsY0FBRyxRQUFROzs7Ozs7OztJQTNCdEYsa0NBTUU7Ozs7O0lBRUYsb0RBQXNFOzs7OztJQUV0RSx5Q0FHRTs7Ozs7SUFDRixnREFBMEM7Ozs7O0lBQzFDLCtDQUF5Qzs7Ozs7SUFDekMsNkNBQXVDOzs7OztJQUN2QywyQ0FBaUQ7Ozs7O0lBVXJDLGlDQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RXZlbnRFbWl0dGVyLCBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBPbkRlc3Ryb3ksIE9wdGlvbmFsfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7ZnJvbUV2ZW50LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24sIHRpbWVyfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZGVib3VuY2VUaW1lLCBkZWxheSwgcmV0cnlXaGVuLCBzdGFydFdpdGgsIHN3aXRjaE1hcCwgdGFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0h0dHBDbGllbnR9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcblxuLyoqXG4gKiBJbnN0YW5jZSBvZiB0aGlzIGludGVyZmFjZSBpcyB1c2VkIHRvIHJlcG9ydCBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdHVzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbm5lY3Rpb25TdGF0ZSB7XG4gIC8qKlxuICAgKiBcIlRydWVcIiBpZiBicm93c2VyIGhhcyBuZXR3b3JrIGNvbm5lY3Rpb24uIERldGVybWluZWQgYnkgV2luZG93IG9iamVjdHMgXCJvbmxpbmVcIiAvIFwib2ZmbGluZVwiIGV2ZW50cy5cbiAgICovXG4gIGhhc05ldHdvcmtDb25uZWN0aW9uOiBib29sZWFuO1xuICAvKipcbiAgICogXCJUcnVlXCIgaWYgYnJvd3NlciBoYXMgSW50ZXJuZXQgYWNjZXNzLiBEZXRlcm1pbmVkIGJ5IGhlYXJ0YmVhdCBzeXN0ZW0gd2hpY2ggcGVyaW9kaWNhbGx5IG1ha2VzIHJlcXVlc3QgdG8gaGVhcnRiZWF0IFVybC5cbiAgICovXG4gIGhhc0ludGVybmV0QWNjZXNzOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEluc3RhbmNlIG9mIHRoaXMgaW50ZXJmYWNlIGNvdWxkIGJlIHVzZWQgdG8gY29uZmlndXJlIFwiQ29ubmVjdGlvblNlcnZpY2VcIi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0aW9uU2VydmljZU9wdGlvbnMge1xuICAvKipcbiAgICogQ29udHJvbHMgdGhlIEludGVybmV0IGNvbm5lY3Rpdml0eSBoZWFydGJlYXQgc3lzdGVtLiBEZWZhdWx0IHZhbHVlIGlzICd0cnVlJy5cbiAgICovXG4gIGVuYWJsZUhlYXJ0YmVhdD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBVcmwgdXNlZCBmb3IgY2hlY2tpbmcgSW50ZXJuZXQgY29ubmVjdGl2aXR5LCBoZWFydGJlYXQgc3lzdGVtIHBlcmlvZGljYWxseSBtYWtlcyBcIkhFQURcIiByZXF1ZXN0cyB0byB0aGlzIFVSTCB0byBkZXRlcm1pbmUgSW50ZXJuZXRcbiAgICogY29ubmVjdGlvbiBzdGF0dXMuIERlZmF1bHQgdmFsdWUgaXMgXCIvL3NlcnZlci50ZXN0LWNvcnMub3JnXCIuXG4gICAqL1xuICBoZWFydGJlYXRVcmw/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDYWxsYmFjayBmdW5jdGlvbiB0byB1c2VkIGZvciBleGVjdXRpbmcgaGVhcnRiZWF0IHJlcXVlc3RzLiBEZWZhdWx0cyB0byBIdHRwQ2xpZW50LnJlcXVlc3QoLi4uKSBmdW5jdGlvbi5cbiAgICovXG4gIGhlYXJ0YmVhdEV4ZWN1dG9yPzogKG9wdGlvbnM/OiBDb25uZWN0aW9uU2VydmljZU9wdGlvbnMpID0+IE9ic2VydmFibGU8YW55PjtcbiAgLyoqXG4gICAqIEludGVydmFsIHVzZWQgdG8gY2hlY2sgSW50ZXJuZXQgY29ubmVjdGl2aXR5IHNwZWNpZmllZCBpbiBtaWxsaXNlY29uZHMuIERlZmF1bHQgdmFsdWUgaXMgXCIzMDAwMFwiLlxuICAgKi9cbiAgaGVhcnRiZWF0SW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbnRlcnZhbCB1c2VkIHRvIHJldHJ5IEludGVybmV0IGNvbm5lY3Rpdml0eSBjaGVja3Mgd2hlbiBhbiBlcnJvciBpcyBkZXRlY3RlZCAod2hlbiBubyBJbnRlcm5ldCBjb25uZWN0aW9uKS4gRGVmYXVsdCB2YWx1ZSBpcyBcIjEwMDBcIi5cbiAgICovXG4gIGhlYXJ0YmVhdFJldHJ5SW50ZXJ2YWw/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBIVFRQIG1ldGhvZCB1c2VkIGZvciByZXF1ZXN0aW5nIGhlYXJ0YmVhdCBVcmwuIERlZmF1bHQgaXMgJ2hlYWQnLlxuICAgKi9cbiAgcmVxdWVzdE1ldGhvZD86ICdnZXQnIHwgJ3Bvc3QnIHwgJ2hlYWQnIHwgJ29wdGlvbnMnO1xuXG59XG5cbi8qKlxuICogSW5qZWN0aW9uVG9rZW4gZm9yIHNwZWNpZmluZyBDb25uZWN0aW9uU2VydmljZSBvcHRpb25zLlxuICovXG5leHBvcnQgY29uc3QgQ29ubmVjdGlvblNlcnZpY2VPcHRpb25zVG9rZW46IEluamVjdGlvblRva2VuPENvbm5lY3Rpb25TZXJ2aWNlT3B0aW9ucz4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0Nvbm5lY3Rpb25TZXJ2aWNlT3B0aW9uc1Rva2VuJyk7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdGF0aWMgREVGQVVMVF9PUFRJT05TOiBDb25uZWN0aW9uU2VydmljZU9wdGlvbnMgPSB7XG4gICAgZW5hYmxlSGVhcnRiZWF0OiB0cnVlLFxuICAgIGhlYXJ0YmVhdFVybDogJy8vc2VydmVyLnRlc3QtY29ycy5vcmcvc2VydmVyP2lkPScgKyBEYXRlLm5vdygpICsgJyZlbmFibGU9dHJ1ZSZzdGF0dXM9MjAwJmNyZWRlbnRpYWxzPWZhbHNlJyxcbiAgICBoZWFydGJlYXRJbnRlcnZhbDogMzAwMDAsXG4gICAgaGVhcnRiZWF0UmV0cnlJbnRlcnZhbDogMTAwMCxcbiAgICByZXF1ZXN0TWV0aG9kOiAnaGVhZCcsXG4gIH07XG5cbiAgcHJpdmF0ZSBzdGF0ZUNoYW5nZUV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXI8Q29ubmVjdGlvblN0YXRlPigpO1xuXG4gIHByaXZhdGUgY3VycmVudFN0YXRlOiBDb25uZWN0aW9uU3RhdGUgPSB7XG4gICAgaGFzSW50ZXJuZXRBY2Nlc3M6IGZhbHNlLFxuICAgIGhhc05ldHdvcmtDb25uZWN0aW9uOiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZVxuICB9O1xuICBwcml2YXRlIG9mZmxpbmVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBvbmxpbmVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBodHRwU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgc2VydmljZU9wdGlvbnM6IENvbm5lY3Rpb25TZXJ2aWNlT3B0aW9ucztcblxuICAvKipcbiAgICogQ3VycmVudCBDb25uZWN0aW9uU2VydmljZSBvcHRpb25zLiBOb3RpY2UgdGhhdCBjaGFuZ2luZyB2YWx1ZXMgb2YgdGhlIHJldHVybmVkIG9iamVjdCBoYXMgbm90IGVmZmVjdCBvbiBzZXJ2aWNlIGV4ZWN1dGlvbi5cbiAgICogWW91IHNob3VsZCB1c2UgXCJ1cGRhdGVPcHRpb25zXCIgZnVuY3Rpb24uXG4gICAqL1xuICBnZXQgb3B0aW9ucygpOiBDb25uZWN0aW9uU2VydmljZU9wdGlvbnMge1xuICAgIHJldHVybiBfLmNsb25lKHRoaXMuc2VydmljZU9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LCBASW5qZWN0KENvbm5lY3Rpb25TZXJ2aWNlT3B0aW9uc1Rva2VuKSBAT3B0aW9uYWwoKSBvcHRpb25zOiBDb25uZWN0aW9uU2VydmljZU9wdGlvbnMpIHtcbiAgICB0aGlzLnNlcnZpY2VPcHRpb25zID0gXy5kZWZhdWx0cyhcbiAgICAgIHt9LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIENvbm5lY3Rpb25TZXJ2aWNlLkRFRkFVTFRfT1BUSU9OUyxcbiAgICAgIHtcbiAgICAgICAgaGVhcnRiZWF0RXhlY3V0b3I6ICgpID0+IHRoaXMuaHR0cC5yZXF1ZXN0KFxuICAgICAgICAgIHRoaXMuc2VydmljZU9wdGlvbnMucmVxdWVzdE1ldGhvZCxcbiAgICAgICAgICB0aGlzLnNlcnZpY2VPcHRpb25zLmhlYXJ0YmVhdFVybCxcbiAgICAgICAgICB7cmVzcG9uc2VUeXBlOiAndGV4dCd9XG4gICAgICAgICksXG4gICAgICB9KTtcblxuICAgIHRoaXMuY2hlY2tOZXR3b3JrU3RhdGUoKTtcbiAgICB0aGlzLmNoZWNrSW50ZXJuZXRTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0ludGVybmV0U3RhdGUoKSB7XG5cbiAgICBpZiAoIV8uaXNOaWwodGhpcy5odHRwU3Vic2NyaXB0aW9uKSkge1xuICAgICAgdGhpcy5odHRwU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VydmljZU9wdGlvbnMuZW5hYmxlSGVhcnRiZWF0KSB7XG4gICAgICB0aGlzLmh0dHBTdWJzY3JpcHRpb24gPSB0aW1lcigwLCB0aGlzLnNlcnZpY2VPcHRpb25zLmhlYXJ0YmVhdEludGVydmFsKVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5zZXJ2aWNlT3B0aW9ucy5oZWFydGJlYXRFeGVjdXRvcih0aGlzLnNlcnZpY2VPcHRpb25zKSksXG4gICAgICAgICAgcmV0cnlXaGVuKGVycm9ycyA9PlxuICAgICAgICAgICAgZXJyb3JzLnBpcGUoXG4gICAgICAgICAgICAgIC8vIGxvZyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgIHRhcCh2YWwgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0h0dHAgZXJyb3I6JywgdmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5oYXNJbnRlcm5ldEFjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KCk7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAvLyByZXN0YXJ0IGFmdGVyIDUgc2Vjb25kc1xuICAgICAgICAgICAgICBkZWxheSh0aGlzLnNlcnZpY2VPcHRpb25zLmhlYXJ0YmVhdFJldHJ5SW50ZXJ2YWwpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUocmVzdWx0ID0+IHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZS5oYXNJbnRlcm5ldEFjY2VzcyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5lbWl0RXZlbnQoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLmhhc0ludGVybmV0QWNjZXNzID0gZmFsc2U7XG4gICAgICB0aGlzLmVtaXRFdmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tOZXR3b3JrU3RhdGUoKSB7XG4gICAgdGhpcy5vbmxpbmVTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQod2luZG93LCAnb25saW5lJykuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFN0YXRlLmhhc05ldHdvcmtDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tJbnRlcm5ldFN0YXRlKCk7XG4gICAgICB0aGlzLmVtaXRFdmVudCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5vZmZsaW5lU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KHdpbmRvdywgJ29mZmxpbmUnKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50U3RhdGUuaGFzTmV0d29ya0Nvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hlY2tJbnRlcm5ldFN0YXRlKCk7XG4gICAgICB0aGlzLmVtaXRFdmVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBlbWl0RXZlbnQoKSB7XG4gICAgdGhpcy5zdGF0ZUNoYW5nZUV2ZW50RW1pdHRlci5lbWl0KHRoaXMuY3VycmVudFN0YXRlKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm9mZmxpbmVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMub25saW5lU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLmh0dHBTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vbml0b3IgTmV0d29yayAmIEludGVybmV0IGNvbm5lY3Rpb24gc3RhdHVzIGJ5IHN1YnNjcmliaW5nIHRvIHRoaXMgb2JzZXJ2ZXIuIElmIHlvdSBzZXQgXCJyZXBvcnRDdXJyZW50U3RhdGVcIiB0byBcImZhbHNlXCIgdGhlblxuICAgKiBmdW5jdGlvbiB3aWxsIG5vdCByZXBvcnQgY3VycmVudCBzdGF0dXMgb2YgdGhlIGNvbm5lY3Rpb25zIHdoZW4gaW5pdGlhbGx5IHN1YnNjcmliZWQuXG4gICAqIEBwYXJhbSByZXBvcnRDdXJyZW50U3RhdGUgUmVwb3J0IGN1cnJlbnQgc3RhdGUgd2hlbiBpbml0aWFsIHN1YnNjcmlwdGlvbi4gRGVmYXVsdCBpcyBcInRydWVcIlxuICAgKi9cbiAgbW9uaXRvcihyZXBvcnRDdXJyZW50U3RhdGUgPSB0cnVlKTogT2JzZXJ2YWJsZTxDb25uZWN0aW9uU3RhdGU+IHtcbiAgICByZXR1cm4gcmVwb3J0Q3VycmVudFN0YXRlID9cbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFdmVudEVtaXR0ZXIucGlwZShcbiAgICAgICAgZGVib3VuY2VUaW1lKDMwMCksXG4gICAgICAgIHN0YXJ0V2l0aCh0aGlzLmN1cnJlbnRTdGF0ZSksXG4gICAgICApXG4gICAgICA6XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlRXZlbnRFbWl0dGVyLnBpcGUoXG4gICAgICAgIGRlYm91bmNlVGltZSgzMDApXG4gICAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBvcHRpb25zIG9mIHRoZSBzZXJ2aWNlLiBZb3UgY291bGQgc3BlY2lmeSBwYXJ0aWFsIG9wdGlvbnMgb2JqZWN0LiBWYWx1ZXMgdGhhdCBhcmUgbm90IHNwZWNpZmllZCB3aWxsIHVzZSBkZWZhdWx0IC8gcHJldmlvdXNcbiAgICogb3B0aW9uIHZhbHVlcy5cbiAgICogQHBhcmFtIG9wdGlvbnMgUGFydGlhbCBvcHRpb24gdmFsdWVzLlxuICAgKi9cbiAgdXBkYXRlT3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPENvbm5lY3Rpb25TZXJ2aWNlT3B0aW9ucz4pIHtcbiAgICB0aGlzLnNlcnZpY2VPcHRpb25zID0gXy5kZWZhdWx0cyh7fSwgb3B0aW9ucywgdGhpcy5zZXJ2aWNlT3B0aW9ucyk7XG4gICAgdGhpcy5jaGVja0ludGVybmV0U3RhdGUoKTtcbiAgfVxuXG59XG4iXX0=