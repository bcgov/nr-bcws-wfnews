import { Pipe, ChangeDetectorRef, EventEmitter, NgZone, NgModule } from '@angular/core';
import * as moment from 'moment';
import { isMoment, duration, unix, isDate, utc, parseZone } from 'moment';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
import * as ɵngcc0 from '@angular/core';
const momentConstructor = moment;
class AddPipe {
    /**
     * @param {?} value
     * @param {?} amount
     * @param {?=} unit
     * @return {?}
     */
    transform(value, amount, unit) {
        if (typeof amount === 'undefined' || (typeof amount === 'number' && typeof unit === 'undefined')) {
            throw new Error('AddPipe: missing required arguments');
        }
        return momentConstructor(value).add(amount, unit);
    }
}
AddPipe.ɵfac = function AddPipe_Factory(t) { return new (t || AddPipe)(); };
AddPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amAdd", type: AddPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AddPipe, [{
        type: Pipe,
        args: [{ name: 'amAdd' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
const momentConstructor$1 = moment;
class CalendarPipe {
    /**
     * @param {?} cdRef
     * @param {?} ngZone
     */
    constructor(cdRef, ngZone) {
        this.cdRef = cdRef;
        this.ngZone = ngZone;
        // using a single static timer for all instances of this pipe for performance reasons
        CalendarPipe.initTimer(ngZone);
        CalendarPipe.refs++;
        // values such as Today will need to be replaced with Yesterday after midnight,
        // so make sure we subscribe to an EventEmitter that we set up to emit at midnight
        this.midnightSub = CalendarPipe.midnight.subscribe(() => {
            this.ngZone.run(() => this.cdRef.markForCheck());
        });
    }
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        let /** @type {?} */ formats = null;
        let /** @type {?} */ referenceTime = null;
        for (let /** @type {?} */ i = 0, /** @type {?} */ len = args.length; i < len; i++) {
            if (args[i] !== null) {
                if (typeof args[i] === 'object' && !isMoment(args[i])) {
                    formats = args[i];
                }
                else {
                    referenceTime = momentConstructor$1(args[i]);
                }
            }
        }
        return momentConstructor$1(value).calendar(referenceTime, formats);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (CalendarPipe.refs > 0) {
            CalendarPipe.refs--;
        }
        if (CalendarPipe.refs === 0) {
            CalendarPipe.removeTimer();
        }
        this.midnightSub.unsubscribe();
    }
    /**
     * @param {?} ngZone
     * @return {?}
     */
    static initTimer(ngZone) {
        // initialize the timer
        if (!CalendarPipe.midnight) {
            CalendarPipe.midnight = new EventEmitter();
            if (typeof window !== 'undefined') {
                const /** @type {?} */ timeToUpdate = CalendarPipe._getMillisecondsUntilUpdate();
                CalendarPipe.timer = ngZone.runOutsideAngular(() => {
                    return window.setTimeout(() => {
                        // emit the current date
                        CalendarPipe.midnight.emit(new Date());
                        // refresh the timer
                        CalendarPipe.removeTimer();
                        CalendarPipe.initTimer(ngZone);
                    }, timeToUpdate);
                });
            }
        }
    }
    /**
     * @return {?}
     */
    static removeTimer() {
        if (CalendarPipe.timer) {
            window.clearTimeout(CalendarPipe.timer);
            CalendarPipe.timer = null;
            CalendarPipe.midnight = null;
        }
    }
    /**
     * @return {?}
     */
    static _getMillisecondsUntilUpdate() {
        const /** @type {?} */ now = momentConstructor$1();
        const /** @type {?} */ tomorrow = momentConstructor$1().startOf('day').add(1, 'days');
        const /** @type {?} */ timeToMidnight = tomorrow.valueOf() - now.valueOf();
        return timeToMidnight + 1000; // 1 second after midnight
    }
}
CalendarPipe.ɵfac = function CalendarPipe_Factory(t) { return new (t || CalendarPipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef, 16), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone, 16)); };
CalendarPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amCalendar", type: CalendarPipe, pure: false });
/**
 * Internal reference counter, so we can clean up when no instances are in use
 */
CalendarPipe.refs = 0;
CalendarPipe.timer = null;
CalendarPipe.midnight = null;
/** @nocollapse */
CalendarPipe.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NgZone, },
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CalendarPipe, [{
        type: Pipe,
        args: [{ name: 'amCalendar', pure: false }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
const momentConstructor$2 = moment;
class DateFormatPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        if (!value) {
            return '';
        }
        return momentConstructor$2(value).format(args[0]);
    }
}
DateFormatPipe.ɵfac = function DateFormatPipe_Factory(t) { return new (t || DateFormatPipe)(); };
DateFormatPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amDateFormat", type: DateFormatPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DateFormatPipe, [{
        type: Pipe,
        args: [{ name: 'amDateFormat' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
const momentConstructor$3 = moment;
class DifferencePipe {
    /**
     * @param {?} value
     * @param {?} otherValue
     * @param {?=} unit
     * @param {?=} precision
     * @return {?}
     */
    transform(value, otherValue, unit, precision) {
        const /** @type {?} */ date = momentConstructor$3(value);
        const /** @type {?} */ date2 = (otherValue !== null) ? momentConstructor$3(otherValue) : momentConstructor$3();
        return date.diff(date2, unit, precision);
    }
}
DifferencePipe.ɵfac = function DifferencePipe_Factory(t) { return new (t || DifferencePipe)(); };
DifferencePipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amDifference", type: DifferencePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DifferencePipe, [{
        type: Pipe,
        args: [{ name: 'amDifference' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class DurationPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        if (typeof args === 'undefined' || args.length !== 1) {
            throw new Error('DurationPipe: missing required time unit argument');
        }
        return duration(value, /** @type {?} */ (args[0])).humanize();
    }
}
DurationPipe.ɵfac = function DurationPipe_Factory(t) { return new (t || DurationPipe)(); };
DurationPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amDuration", type: DurationPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DurationPipe, [{
        type: Pipe,
        args: [{ name: 'amDuration' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
class FromUnixPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        if (typeof value === 'string') {
            value = +value;
        }
        return unix(value);
    }
}
FromUnixPipe.ɵfac = function FromUnixPipe_Factory(t) { return new (t || FromUnixPipe)(); };
FromUnixPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amFromUnix", type: FromUnixPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FromUnixPipe, [{
        type: Pipe,
        args: [{ name: 'amFromUnix' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const momentConstructor$4 = moment;
class ParsePipe {
    /**
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    transform(value, format) {
        return momentConstructor$4(value, format);
    }
}
ParsePipe.ɵfac = function ParsePipe_Factory(t) { return new (t || ParsePipe)(); };
ParsePipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amParse", type: ParsePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ParsePipe, [{
        type: Pipe,
        args: [{ name: 'amParse' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
const momentConstructor$5 = moment;
class SubtractPipe {
    /**
     * @param {?} value
     * @param {?} amount
     * @param {?=} unit
     * @return {?}
     */
    transform(value, amount, unit) {
        if (typeof amount === 'undefined' || (typeof amount === 'number' && typeof unit === 'undefined')) {
            throw new Error('SubtractPipe: missing required arguments');
        }
        return momentConstructor$5(value).subtract(amount, unit);
    }
}
SubtractPipe.ɵfac = function SubtractPipe_Factory(t) { return new (t || SubtractPipe)(); };
SubtractPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amSubtract", type: SubtractPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SubtractPipe, [{
        type: Pipe,
        args: [{ name: 'amSubtract' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
const momentConstructor$6 = moment;
class TimeAgoPipe {
    /**
     * @param {?} cdRef
     * @param {?} ngZone
     */
    constructor(cdRef, ngZone) {
        this.cdRef = cdRef;
        this.ngZone = ngZone;
    }
    /**
     * @param {?} value
     * @param {?=} omitSuffix
     * @return {?}
     */
    transform(value, omitSuffix) {
        if (this.hasChanged(value, omitSuffix)) {
            this.lastTime = this.getTime(value);
            this.lastValue = value;
            this.lastOmitSuffix = omitSuffix;
            this.lastLocale = this.getLocale(value);
            this.removeTimer();
            this.createTimer();
            this.lastText = momentConstructor$6(value).from(momentConstructor$6(), omitSuffix);
        }
        else {
            this.createTimer();
        }
        return this.lastText;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeTimer();
    }
    /**
     * @return {?}
     */
    createTimer() {
        if (this.currentTimer) {
            return;
        }
        const /** @type {?} */ momentInstance = momentConstructor$6(this.lastValue);
        const /** @type {?} */ timeToUpdate = this.getSecondsUntilUpdate(momentInstance) * 1000;
        this.currentTimer = this.ngZone.runOutsideAngular(() => {
            if (typeof window !== 'undefined') {
                return window.setTimeout(() => {
                    this.lastText = momentConstructor$6(this.lastValue).from(momentConstructor$6(), this.lastOmitSuffix);
                    this.currentTimer = null;
                    this.ngZone.run(() => this.cdRef.markForCheck());
                }, timeToUpdate);
            }
        });
    }
    /**
     * @return {?}
     */
    removeTimer() {
        if (this.currentTimer) {
            window.clearTimeout(this.currentTimer);
            this.currentTimer = null;
        }
    }
    /**
     * @param {?} momentInstance
     * @return {?}
     */
    getSecondsUntilUpdate(momentInstance) {
        const /** @type {?} */ howOld = Math.abs(momentConstructor$6().diff(momentInstance, 'minute'));
        if (howOld < 1) {
            return 1;
        }
        else if (howOld < 60) {
            return 30;
        }
        else if (howOld < 180) {
            return 300;
        }
        else {
            return 3600;
        }
    }
    /**
     * @param {?} value
     * @param {?=} omitSuffix
     * @return {?}
     */
    hasChanged(value, omitSuffix) {
        return this.getTime(value) !== this.lastTime
            || this.getLocale(value) !== this.lastLocale
            || omitSuffix !== this.lastOmitSuffix;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getTime(value) {
        if (isDate(value)) {
            return value.getTime();
        }
        else if (isMoment(value)) {
            return value.valueOf();
        }
        else {
            return momentConstructor$6(value).valueOf();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getLocale(value) {
        return isMoment(value) ? value.locale() : null;
    }
}
TimeAgoPipe.ɵfac = function TimeAgoPipe_Factory(t) { return new (t || TimeAgoPipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef, 16), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone, 16)); };
TimeAgoPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amTimeAgo", type: TimeAgoPipe, pure: false });
/** @nocollapse */
TimeAgoPipe.ctorParameters = () => [
    { type: ChangeDetectorRef, },
    { type: NgZone, },
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TimeAgoPipe, [{
        type: Pipe,
        args: [{ name: 'amTimeAgo', pure: false }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.NgZone }]; }, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const momentConstructor$7 = moment;
class UtcPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return momentConstructor$7(value).utc();
    }
}
UtcPipe.ɵfac = function UtcPipe_Factory(t) { return new (t || UtcPipe)(); };
UtcPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amUtc", type: UtcPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UtcPipe, [{
        type: Pipe,
        args: [{ name: 'amUtc' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
class FromUtcPipe {
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        return utc(value);
    }
}
FromUtcPipe.ɵfac = function FromUtcPipe_Factory(t) { return new (t || FromUtcPipe)(); };
FromUtcPipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amFromUtc", type: FromUtcPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FromUtcPipe, [{
        type: Pipe,
        args: [{ name: 'amFromUtc' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const momentConstructor$8 = moment;
class LocalTimePipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return momentConstructor$8(value).local();
    }
}
LocalTimePipe.ɵfac = function LocalTimePipe_Factory(t) { return new (t || LocalTimePipe)(); };
LocalTimePipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amLocal", type: LocalTimePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalTimePipe, [{
        type: Pipe,
        args: [{ name: 'amLocal' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// under systemjs, moment is actually exported as the default export, so we account for that
const momentConstructor$9 = moment;
class LocalePipe {
    /**
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */
    transform(value, locale) {
        return momentConstructor$9(value).locale(locale);
    }
}
LocalePipe.ɵfac = function LocalePipe_Factory(t) { return new (t || LocalePipe)(); };
LocalePipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amLocale", type: LocalePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LocalePipe, [{
        type: Pipe,
        args: [{ name: 'amLocale' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ParseZonePipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return parseZone(value);
    }
}
ParseZonePipe.ɵfac = function ParseZonePipe_Factory(t) { return new (t || ParseZonePipe)(); };
ParseZonePipe.ɵpipe = /*@__PURE__*/ ɵngcc0.ɵɵdefinePipe({ name: "amParseZone", type: ParseZonePipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ParseZonePipe, [{
        type: Pipe,
        args: [{ name: 'amParseZone' }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ANGULAR_MOMENT_PIPES = [
    AddPipe,
    CalendarPipe,
    DateFormatPipe,
    DifferencePipe,
    DurationPipe,
    FromUnixPipe,
    ParsePipe,
    SubtractPipe,
    TimeAgoPipe,
    UtcPipe,
    FromUtcPipe,
    LocalTimePipe,
    LocalePipe,
    ParseZonePipe
];
class MomentModule {
}
MomentModule.ɵfac = function MomentModule_Factory(t) { return new (t || MomentModule)(); };
MomentModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MomentModule });
MomentModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MomentModule, [{
        type: NgModule,
        args: [{
                declarations: ANGULAR_MOMENT_PIPES,
                exports: ANGULAR_MOMENT_PIPES
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MomentModule, { declarations: [AddPipe, CalendarPipe, DateFormatPipe, DifferencePipe, DurationPipe, FromUnixPipe, ParsePipe, SubtractPipe, TimeAgoPipe, UtcPipe, FromUtcPipe, LocalTimePipe, LocalePipe, ParseZonePipe], exports: [AddPipe, CalendarPipe, DateFormatPipe, DifferencePipe, DurationPipe, FromUnixPipe, ParsePipe, SubtractPipe, TimeAgoPipe, UtcPipe, FromUtcPipe, LocalTimePipe, LocalePipe, ParseZonePipe] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { AddPipe, CalendarPipe, DateFormatPipe, DifferencePipe, DurationPipe, FromUnixPipe, ParsePipe, MomentModule, SubtractPipe, TimeAgoPipe, UtcPipe, FromUtcPipe, LocalTimePipe, LocalePipe, ParseZonePipe };

//# sourceMappingURL=ngx-moment.js.map