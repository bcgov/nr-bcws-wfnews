import { WFError } from "../modules/core/models/wf-error";

const digits = () => `must contain only numbers`;
const minMax = ([message, min, max]: any[]) => `must be between ${min} and ${max} characters`;
const invalidTransition = ([oldIncidentTypeCode, newIncidentTypeCode]: any[]) => `${oldIncidentTypeCode} to ${newIncidentTypeCode}`;
const fieldName = (name: any) => {
	switch(name) {
	case "incidentTimestamp":
	  return "Ignition"
	case "reportedTimestamp":
	  return "Reported"
	case "incidentSituation.fireBeingHeldDate":
	  return "Being Held"
	case "incidentSituation.fireUnderControlDate":
	  return "Under Control"
	case "incidentSituation.fireOutDate":
	  return "Out"
	default:
	  return name;
	}
}
 
export const ErrorMessages = {
    "error.wildfire.party.name.invalid": () => "Invalid wildfire party name",
    "error.wildfire.incident.number.sequence.invalid": () => "Invalid incident number sequence",
    "error.radio.tone.invalid": () => "Invalid radio tone",
    "error.radio.channel.invalid": () => "Invalid radio channel",
    "error.wildfire.org.unit.identifier.invalid": () => "Invalid wildfire org unit",
    "error.fire.location.point.invalid": () => "Invalid fire location point",
    "error.org.unit.type.invalid": () => "Invalid org unit type",

    "error.forest.fuel.type.code.invalid": () => "Invalid forest fuel type code",
    "error.forest.fuel.age.code.invalid": () => "Invalid forest fuel age code",
    "error.forest.fuel.density.code.invalid": () => "Invalid forest fuel density code",
    "error.value.at.risk.subtype.code.invalid": () => "Invalid value at risk suntype code",
    "error.general.incident.cause.category.code.invalid": () => "Invalid incident cause category code",
    "error.incident.location.point.invalid": () => "Invalid incident location point",
    "error.forest.fuel.report.type.code.invalid": () => "Invalid forest fuel report type code",
    "error.forest.fuel.category.code.invalid": () => "Invalid forest fuel category code",
    "error.weather.station.code.invalid": () => "Invalid weather station code",
    "error.land.ownership.class.code.invalid": () => "Invalid land ownership class code",
    "error.available.water.code.invalid": () => "Invalid available water code",
    "error.stage.of.control.code.invalid": () => "Invalid stage of control code",
    "error.field.report.type.code.invalid": () => "Invalid field report type code",
    "error.site.access.point.type.code.invalid": () => "Invalid site access point type code",
    "error.direction.code.invalid": () => "Invalid direction code",
    "error.fire.rank.code.invalid": () => "Invalid fire rank code",
    "error.slope.position.code.invalid": () => "Invalid slope position code",
    "error.slope.rating.code.invalid": () => "Invalid slope rating code",
    "error.value.at.risk.type.code.invalid": () => "Invalid value at risk type code",
    "error.probability.of.initial.attack.success.code.invalid": () => "Invalid probability of initial attack success type code",
    "error.investigation.requester.code.invalid": () => "Invalid investigation requester code",
    "error.investigation.determination.status.code.invalid": () => "Invalid investigation determination status code",
    "error.public.report.type.code.invalid": () => "Invalid public report type code",
    "error.fire.size.comparison.code.invalid": () => "Invalid fire size comparison code",
    "error.report.of.fire.type.code.invalid": () => "Invalid report of fire type code",
    "error.smoke.colour.code.invalid": () => "Invalid smoke colour code",
    "error.control.chance.of.success.code.invalid": () => "Invalid control chance of success code",
    "error.fire.analysis.status.code.invalid": () => "Invalid fire analysis status code",
    "error.detection.source.code.invalid": () => "Invalid detection source code",
    "error.fire.classification.code.invalid": () => "Invalid fire classification code",
    "error.agency.assist.type.code.invalid": () => "Invalid agency assist type code",
    "error.response.type.code.invalid": () => "Invalid response type code",
    "error.incident.category.code.invalid": () => "Invalid incident category code",
    "error.message.type.code.invalid": () => "Invalid message type code",
    "error.message.status.code.invalid": () => "Invalid message status code",
    "error.wildfire.party.type.code.invalid": () => "Invalid wildfire party type code",
    "error.incident.relationship.type.code.invalid": () => "Invalid incident relationship type code",
    "error.assessment.report.period.code.invalid": () => "Invalid assessment report period code",
    "error.perimeter.status.code.invalid": () => "Invalid perimeter status code",
    "error.collection.method.code.invalid": () => "Invalid collection method code",

    "error.report.of.fire.captured.date.notblank": () => "Captured date is required",
    "error.reported.by.call.sign.notblank": () => "Reported by call sign is required",
    "error.reported.by.call.sign.size": ({ messageArguments }: WFError) => `Reported by call sign ${minMax(messageArguments)}`,
    "error.professional.report.of.fire.number.digits": () => `Professional report of fire number ${digits()}`,
    "error.reported.action.comment.size": ({ messageArguments }: WFError) => `Reported action comment ${minMax(messageArguments)}`,
    "error.fire.size.hectares.digits": () => `Fire size hectares ${digits()}`,
    "error.wind.speed.kilometers.per.hour.digits": () => `Wind speed ${digits()}`,
    "error.value.at.risk.description.size": ({ messageArguments }: WFError) => `Value at risk description ${minMax(messageArguments)}`,
    "error.value.at.risk.distance.meters.digits": () => `Value at risk distance ${digits()}`,
    "error.access.distance.meters.digits": () => `Access distance ${digits()}`,
    "error.available.water.distance.meters.digits": () => `Available water distance ${digits()}`,
    "error.spotting.distance.to.fire.meters.digits": () => `Spotting distance to fire ${digits()}`,
    "error.paper.trailed.ind.notblank": () => "Paper trailed indicator is required",
    "error.field.photo.ind.notblank": () => "Field photo indicator is required",
    "error.actual.cost.of.control.digits": () => `Totoal cost of fire ${digits()}`,
    "error.estimated.cost.of.control.digits": () => `Estimated cost of control ${digits()}`,
    "error.field.report.type.code.notblank": () => "Field report type code is required",
    "error.fire.rank.code.notblank": () => "Fire rank is required",
    "error.fire.classification.code.notblank": () => "Fire classification is required",

    "error.incident.comment.notblank": () => "Incident comment is required",
    "error.incident.comment.size": ({ messageArguments }: WFError) => `Comment ${minMax(messageArguments)}`,

    "error.investigator.name.notblank": () => "Investigator name is required",
    "error.investigator.name.size": ({ messageArguments }: WFError) => `Investigator name ${minMax(messageArguments)}`,
    "error.investigation.reference.number.size": ({ messageArguments }: WFError) => `Reference number ${minMax(messageArguments)}`,
    "error.requested.date.notblank": () => "Requested date is required",
    "error.requested.date.blank": () => "Requested date should be blank",
    "error.requester.code.notblank": () => "Investigation requested by is required",
    "error.requester.code.blank": () => "Investigation requested by should be blank",
    "error.c.and.e.investigation.requester.code.notblank": () => "Investigation requested by is required",
    "error.o.and.c.investigation.requester.code.notblank": () => "Investigation requested by is required",
    "error.investigation.determination.status.code.notblank": () => "Investigation determination status code is required",

    "error.caller_name.size": ({ messageArguments }: WFError) => `Caller name ${minMax(messageArguments)}`,
    "error.caller.telephone.size": ({ messageArguments }: WFError) => `Caller telephone number ${minMax(messageArguments)}`,
    "error.caller.report.details.size": ({ messageArguments }: WFError) => `Caller report details ${minMax(messageArguments)}`,
    "error.fire.fighting.progress.note.size": ({ messageArguments }: WFError) => `Fire fighting progress ${minMax(messageArguments)}`,
    "error.values.being.threatened.note.size": ({ messageArguments }: WFError) => `Values being threatened note ${minMax(messageArguments)}`,
    "error.fire.size.comparison.code.notblank": () => "Fire size comparison code is required",
    "error.rate.of.spread.code.invalid": () => "Invalid rate of spread code",
    "error.rate.of.spread.code.notblank": () => "Rate of spread code is required",

    "error.report.of.fire.number.notblank": () => "Report of fire number is required",
    "error.report.of.fire.number.digits": () => `Report of fire number ${digits()}`,
    "error.report.of.fire.type.code.notblank": () => "Report of fire type code is required",
    "error.wildfire.year.notblank": () => "Wildfire year is required",
    "error.wildfire.year.digits": () => `Wildfire year ${digits()}`,
    "error.reported.date.notblank": () => "Reported date is required",
    "error.received.by.name.size": ({ messageArguments }: WFError) => `Received by name ${minMax(messageArguments)}`,
    "error.elevation.meters.digits": () => `Elevation ${digits()}`,
    "error.geometry.notblank": () => " Geometry is required",

    "error.response.objective.comment.size": ({ messageArguments }: WFError) => `Response objective comment ${minMax(messageArguments)}`,
    "error.evacuation.alert.ind.notblank": () => "Evacuation alert indicator is required",
    "error.evacuation.order.ind.notblank": () => "Evacuation order indicator is required",
    "error.private.asset.damage.ind.notblank": () => "Private asset damage indicator is required",
    "error.fire.analysis.estimated.cost.digits": () => `Fire analysis estimated cost ${digits()}`,
    "error.other.consideration.comment.size": ({ messageArguments }: WFError) => `Other consideration comment ${minMax(messageArguments)}`,
    "error.risk.estimated.cost.digits": () => `Risk estimated cost ${digits()}`,
    "error.fire.centre.priority.rank.digits": () => `Fire centre priority rank ${digits()}`,
    "error.provincial.priority.rank.digits": () => `Provincial priority rank ${digits()}`,

    "error.incident.number.sequence.notblank": () => "Incident number sequence is required",
    "error.incident.number.sequence.digits": () => `Incident number sequence ${digits()}`,
    "error.incident.name.size": ({ messageArguments }: WFError) => `Incident name ${minMax(messageArguments)}`,
    "error.reporter.action.comment.size": ({ messageArguments }: WFError) => `Reporter action comment ${minMax(messageArguments)}`,
    "error.discovery.size.hectares.digits": () => `Detection size ${digits()}`,
    "error.distance.to.primary.value.at.risk.meters.digits": () => `Distance to primary value at risk ${digits()}`,
    "error.discovery.size.hetares.digits": () => "Detection size is required",
    "error.claim.expected.ind.notblank": () => "Claim expected indicator is required",
    "error.rehabilitation.plan.required.ind.notblank": () => "Rehabilitation plan required indicator is required",
    "error.final.report.completed.ind.notblank": () => "Final report completed indicator is required",
    "error.agency.assistance.task.identifier.size": ({ messageArguments }: WFError) => `Agency assistance task identifier ${minMax(messageArguments)}`,
    "error.response.objective.description.size": ({ messageArguments }: WFError) => `Response objective description ${minMax(messageArguments)}`,
    "error.damage.to.natural.resources.estimate.digits": () => `Damage to natural resources estimat ${digits()}`,
    "error.incident.commander.name.notblank": () => "Incident commander name is required",
    "error.incident.commander.name.size": ({ messageArguments }: WFError) => `Incident commander name ${minMax(messageArguments)}`,
    "error.org.unit.identifier.notblank": () => "Org unit identifier is required",
    "error.incident.status.code.notblank": () => "Incident status code is required",
    "error.incident.number.label.size": ({ messageArguments }: WFError) => `Incident number label ${minMax(messageArguments)}`,
    "error.incident.type.code.notblank": () => "Incident type code is required",
    "error.incident.type.code.invalid": () => "Invalid incident type code",
    "error.incident.category.code.notblank": () => "Incident category code is required",
    "error.incident.date.notblank": () => "Incident date is required",
    "error.incident.label.notblank": () => "Incident ID is required",
    "error.fire.centre.org.unit.identifier.notblank": () => "Fire centre is required",
    "error.zone.org.unit.identifier.notblank": () => "Fire zone is required",
    "error.incident.location.latitude.notblank": () => "Latitude is required",
    "error.incident.location.longitude.notblank": () => "Longitude is required",
    "error.incident.location.point.elevation.meter.notblank": () => "Elevation is required",
    "error.geographic.description.notblank": () => "Geographic description is required",
    "error.contained.percentage.notblank": () => "Percent contained is required",
    "error.reported.forest.fuel.required": () => "Reported forest fuel is required",
    "error.adjacent.forest.fuel.required": () => "Adjacent forest fuel is required",

    "error.message.type.code.notblank": () => "Message type code is required",
    "error.message.context.size": ({ messageArguments }: WFError) => `Message context ${minMax(messageArguments)}`,

    "error.message.status.code.notblank": () => "Message status code is required",
    "error.status.code.notblank": () => "Status code is required",

    "error.wildfire.party.name.size": ({ messageArguments }: WFError) => `Wildfire party name ${minMax(messageArguments)}`,
    "error.wildfire.party.name.notblank": ({ path }: WFError) => path && path == 'firstActionedByParty' ? "First agency to action incident is required" : "Wildfire party name is required",

    "error.incident.relationship.type.code.notblank": () => "Relationship type code is required",

    "error.version.number.notblank": () => "Version number is required",
    "error.version.number.digits": () => `Version number ${digits()}`,
    "error.mapping.label.size": ({ messageArguments }: WFError) => `Mapping label ${minMax(messageArguments)}`,
    "error.collection.date.notblank": () => "Collection date is required",
    "error.collection.name.size": ({ messageArguments }: WFError) => `Collection name ${minMax(messageArguments)}`,
    "error.contact.name.size": ({ messageArguments }: WFError) => `Contact name ${minMax(messageArguments)}`,
    "error.contact.email.size": ({ messageArguments }: WFError) => `Contact email ${minMax(messageArguments)}`,
    "error.feature.size.hectares.notblank": () => "Feature size hectares is required",
    "error.feature.size.hectares.digits": () => `Feature size ${digits()}`,
    "error.feature.perimeter.meters.notblank": () => "Feature perimeter meters is required",
    "error.feature.perimeter.meters.digits": () => `Feature perimeter ${digits()}`,
    "error.water.removed.ind.notblank": () => "Water removed indicator is required",
    "error.unburned.areas.removed.ind.notblank": () => "Unburned areas removed indicator is required",
    "error.perimeter.comment.size": ({ messageArguments }: WFError) => `Perimeter comment ${minMax(messageArguments)}`,
    "error.perimeter.poly.notblank": () => "Perimeter poly is required",
    "error.perimeter.poly.invalid": () => "Invalid perimeter poly",
    "error.perimeter.status.code.notblank": () => "Perimeter status code is required",

    "error.other.fuel.description.size": ({ messageArguments }: WFError) => `Other fuel description ${minMax(messageArguments)}`,
    "error.forest.fuel.report.type.code.code.notblank": () => "forest fuel report type code is required",
    "error.forest.fuel.category.code.notblank": () => "Forest fuel category code is required",

    "error.incident.location.notblank": () => "Incident location is required",
    "error.geographic.description.size": ({ messageArguments }: WFError) => `Geographic description ${minMax(messageArguments)}`,
    "error.incident.location.point.elevation.meter.digits": () => `Incident location point elevation ${digits()}`,
    "error.incident.location.point.notblank": () => "Incident location point is required",

    "error.land.owner.name.notblank": () => "Land owner name is required",
    "error.land.owner.name.size": ({ messageArguments }: WFError) => `Land owner name ${minMax(messageArguments)}`,
    "error.land.owner.address.size": ({ messageArguments }: WFError) => `Land owner address ${minMax(messageArguments)}`,
    "error.land.owner.phone.number.size": ({ messageArguments }: WFError) => `Land owner phone number ${minMax(messageArguments)}`,
    "error.land.manager.name.size": ({ messageArguments }: WFError) => `Land manager name ${minMax(messageArguments)}`,
    "error.land.manager.address.size": ({ messageArguments }: WFError) => `Land manager address ${minMax(messageArguments)}`,
    "error.land.manager.phone.number.size": ({ messageArguments }: WFError) => `Land manager phone number ${minMax(messageArguments)}`,
    "error.land.manager.comment.size": ({ messageArguments }: WFError) => `Land manager comment ${minMax(messageArguments)}`,
    "error.land.manager.agency.notblank": () => "Land manager agency is required",
    "error.fire.wanted.ind.notblank": () => "Fire wanted indicator is required",
    "error.cost.sharing.agreement.ind.notblank": () => "Wildfire Response Agreement indicator is required",

    "error.wind.speed.kph.digits": () => `Wind speed ${digits()}`,
    "error.fire.size.hectares.notblank": () => "Fire size hectares is required",
    "error.interface.fire.ind.notblank": () => "Interface fire indicator is required",
    "error.stage.of.control.code.notblank": () => "Stage of control is required",
    "error.fire.out.timestamp.notblank": () => "Fire out date/time is required",
    "error.fire.being.held.date.notblank": () => "Fire being held date/time is required",
    "error.fire.contained.date.notblank": () => "Fire contained date/time is required",
    "error.fire.under.control.date.notblank": () => "Fire under control date/time is required",

    "error.radio.channel.label.notblank": () => "Radio channel label is required",
    "error.radio.channel.label.size": ({ messageArguments }: WFError) => `Radio channel label ${minMax(messageArguments)}`,
    "error.description.size": ({ messageArguments }: WFError) => `Description ${minMax(messageArguments)}`,
    "error.radio.channel.colour.notblank": () => "Radio channel colour is required",
    "error.radio.channel.tone.number.notblank": () => "Radio channel tone number is required",

    "error.assessment.report.period.code.notblank": () => "Assessment report period code is required",

    "error.comment.notblank": () => "Comment is required",
    "error.comment.size": ({ messageArguments }: WFError) => `Comment ${minMax(messageArguments)}`,

    "error.resource.in.uneditable.state": () => "Resource in uneditable state",

    "error.incident.situation.notblank": () => "Incident situtation is required",
    "error.collection.method.notblank": () => "Collection method is required",

    "error.weather.station.code.notblank": () => "Weather station is required",

    "error.updating.user.display.name.size": ({ messageArguments }: WFError) => `User display name ${minMax(messageArguments)}`,
    "error.incident.relationship.invalid": () => "Invalid incident relationship",

    "error.state.change.invalid": () => "Invalid state change",
    "error.verification.signoff.required": () => "Verification sign off required",
    "error.response.type.code.notblank": () => "Response type is required",
    // "error.estimated.cost.of.control.notblank": () => "Estimated Fire Cost is required",
    // "error.actual.cost.of.control.notblank": () => "Total Fire Cost is required",
    "error.value.at.risk.description.notblank": () => "Values at risk is required",
    "error.slope.rating.code.notblank": () => "Slope is required",
    "error.slope.position.code.notblank": () => "Slope position is required",
    "error.aspect.direction.code.notblank": () => "Aspect is required",
    "error.site.access.point.type.code.notblank": () => "Access type is required",
    "error.incident.land.authority.notblank": () => "Incident land authority is required",
    "error.land.ownership.class.code.notblank": () => "Land status is required",
    "error.origin.and.cause.investigation.notblank": () => "Origin and cause investigation is required",
    "error.investigation.resources.requested.ind.notblank": () => "Investigation resourcs requested indicator is required",
    "error.investigation.agency.responded.ind.notblank": () => "Investigation agency responded indicator is required",
    "error.reported.timestamp.notblank": () => "Reported date is required",
    "error.complete.cause.ind.notblank": () => "Cause complete indicator is required",
    "error.complete.cause.ind.notfalse": () => "Cause complete indicator needs to be checked",
    "error.general.incident.cause.category.code.notblank": () => "General incident cause category code is required",
    "error.incident.cause.reason.category.code.notblank": () => "Cause reason category code is required",
    "error.incident.cause.reason.kind.code.notblank": () => "Cause reason kind code is required",
    "error.forest.activity.category.code.notblank": () => "Forest activity category code is required",
    "error.forest.activity.kind.code.notblank": () => "Forest activity kind code is required",
    "error.incident.cause.activity.subkind.code.notblank": () => "Cause activity subkind code is required",
    "error.incident.cause.activity.category.code.notblank": () => "Cause activity category code is required",
    "error.incident.cause.activity.kind.code.notblank": () => "Cause activity kind code is required",
    "error.cause.certainty.code.notblank": () => "Cause certainty code is required",
    "error.incident.cause.status.code.notblank": () => "Cause status code is required",
    "error.incident.cause.comment.notblank": () => "Cause comment is required",

    "error.compliance.and.enforcement.investigation.notblank": () => "Compliance and Enforcement investigation is required",
    "error.discovery.timestamp.notblank": () => "Detection timestamp is required",
    "error.detection.source.code.notblank": () => "Detection source code is required",
    "error.first.field.report.received.timestamp.notblank": () => "First field report received timestamp is required",
    "error.first.agency.to.action.incident.timestamp.notblank": () => "First agency to action incident timestamp is required",

    "error.contained.percentage.min": () => "Contained percentage cannot be less than 0",
    "error.contained.percentage.max": () => "Contained percentage cannot be more than 100",
    "error.fire.size.hectares.min": () => "Fire size cannot be less than 0",
    "error.incident.timestamp.after.discovery": () => "Ignition time cannot be after detection time",
    "error.first.agency.to.action.timestamp.before.discovery": () => "First agency to action time cannot be before detection time",
    "error.first.field.report.timestamp.before.discovery": () => "Reported time cannot be before detection time",
    "error.lead.agency.start.timestamp.before.discovery": () => "Lead agency start time cannot be before detection time",
    "error.lead.agency.end.timestamp.before.start": () => "Lead agency end time cannot be before lead agency start time",
    "error.reported.timestamp.before.discovery": () => "Reported time cannot be before detection time",
    "error.incident.type.transition.invalid": ({ messageArguments }: WFError) => `${invalidTransition(messageArguments)} is an invalid incident type transition`,
    "error.incident.stageOfControl.timestampOrder": ({ messageArguments }: WFError) => `${fieldName(messageArguments[0])} can not be before ${fieldName(messageArguments[2])}`

};
